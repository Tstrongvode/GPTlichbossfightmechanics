Verse Language Reference

See the design goals of the Verse programming language and its features. Use this section as a reference.
UEFN
Verse Language Reference

These pages describe the Verse programming language and its syntax. Spend time getting familiar with the language, then use these pages as reference.

If this is your first time using Verse, or if you're learning programming for the first time, make sure to check out Programming with Verse to help you get started. You'll also find a useful onboarding guide.
What Is Verse?

Verse is a programming language developed by Epic Games that you can use to create your own gameplay in Unreal Editor for Fortnite, including customizing your devices for Fortnite Creative.

Verse‚Äôs primary design goals:

    Simple enough to learn as a first-time programmer.
    General enough for writing any kind of code and data.
    Productive in the context of building, iterating, and shipping a project in a team setting, and integrating code and content.
    Statically verified to catch as many categories of runtime problems as possible at compile time.
    Performant for writing real-time, open-world, multiplayer games.
    Complete so that every feature of the language supports programmer abstraction over that feature.
    Timeless ‚Äî built for the needs of today, and for foreseeable future needs, without being rooted in the past artifacts of other languages.

The design goals above informed key features of the Verse programming language:

    Strongly typed to minimize opportunities for uncaught errors in development or deployment and support static checking.
    Multi-paradigm to use the best of functional programming, object-oriented programming, and imperative programming, such as being as deterministic as possible. One example of this is that data is immutable by default, and given the same code and data, results will always be exactly the same.
    There is no distinction between statements and expressions. In Verse, everything is an expression, which means that everything has a result.
    Failure is control flow. Instead of using true / false values to change the flow of your program (such as with decision points), Verse uses failable expressions, which produce a value if they succeed or don‚Äôt if they fail. Failable expressions can only be executed in failure contexts, such as if expressions.
    The ability to do speculative execution within failure contexts, meaning you can try out actions without committing them. When an expression succeeds, the effects of the expression are committed, but if the expression fails, the effects of the expression are rolled back as though the expression never happened. This way, you can execute a series of actions that accumulate changes, but those actions will be undone if a failure occurs in the failure context.
    **Concurrency at the language level so you don‚Äôt need to rely on system-level threads across multiple processors to perform actions simultaneously. You can author time flow the same as you do control flow by using built-in concurrency expressions in the language.

Epic Games is continuing to develop the Verse programming language and add more features. For Verse code that you write today, you can expect Verse to provide backward compatibility and continue to work with future updates to the language.
Explore the Language

Use the following pages as a reference for the Verse programming language.
  Expressions

Everything in Verse is an expression and has a result. This page describes all the kinds of expressions in Verse.
UEFN
Expressions

An expression is the smallest unit of code that has a result when evaluated. In Verse everything is an expression, which means everything evaluates to a value.

An example is an if ... else expression, which in Verse evaluates to a value that depends on the content of the expression blocks. The following code evaluates to a string value, containing either ‚ÄúBig!‚Äù or ‚ÄúSmall!‚Äù depending on whether MyNumber was greater than 5:

if (MyNumber > 5):
    ‚ÄúBig!‚Äù
else
    ‚ÄúSmall!‚Äù

This means you can use an if ... else directly as input to functions instead of storing a result and using that result as input.

While this example is simple, there are contexts where this becomes more powerful. For example, loops evaluate to arrays of values, so you can quickly create new arrays based on existing ones.

In the following code, MyArray will contain all the values from NumberArray that are less than 5.

MyArray : []int = for(Number := NumberArray, Number < 5):
    Number

Failable Expressions

A failable expression is an expression that may succeed and produce a value, or fail and return no value. Failable expressions can only be executed in a failure context because that context will define what happens in the event that the expression fails.

Examples of failable expressions include indexing into an array because an invalid index will fail, and using operators such as comparing two values. For more on failable expressions in Verse, see Failure.
List of Expressions in Verse

The following table describes the different kinds of expressions in Verse. Follow the links to learn more about each expression.
Expression 	Description 	Is the Expression Failable?
Literals 	A literal is a fixed value in your code, such as a number or a character. In Verse, there are literals for the following types:

    logic
    int
    float
    string
    option
    enum

	 
Function Calls 	A function call is an expression, and can have two forms: FunctionName() and FunctionName[]. The result type of the function call expression is defined in the function signature. Refer to Function for more details. 	Only when the function call has the form FunctionName[], and the function definition has the <decides> specifier.
Comparison 	A comparison expression compares two things using one of the comparison operators:

    <
    >
    <=
    >=
    <>
    =

Refer to Operators for more details.
	Yes
Assignment 	An assignment expression stores a value at a mutable location, such as when initializing a constant or changing the value of a variable. Refer to Variables and Constants for more details. 	 
Math 	A math expression performs computations using the operators:

    +
    -
    *
    /

All of these operators also have assignment variants that can be used with pointers. Refer to Operators for more details.
	Only for integer division.
Decision 	A decision expression uses the operators not, and, and or to give you control over the success and failure decision flow. Refer to Operators for more details. 	Yes
Query 	A query expression uses the operator ? and checks whether a logic or option value is true. Otherwise, the expression fails. Refer to Operators for more details. 	Yes
Class and Struct Instantiation 	Creating an instance of a class or struct is an expression. Refer to Class and Struct. 	 
Control Flow 	Control flow is the order in which a computer executes instructions. You can use expressions such as if and loop to change that flow. Some control flow expressions, such as loop, only return void and so may not be useful everywhere you can use an expression. The following are control flow expressions in Verse:

    if
    case
    for
    loop
    sync
    race
    rush
    branch
    spawn

Refer to Control Flow for more details.
	 
Array 	An array is a container where you can store elements of the same type. The elements of an array are in the order you insert them into the array, and you can access the elements by their position in the array, called their index. For more info, see Array. 	Only when indexing into an array.
Tuple 	A tuple is a container where you can store elements of one or more types. The elements of a tuple are in the order you insert them into the tuple and you can access the elements by their position in the tuple, called their index.. For more info, see Tuple . 	 
Map 	A map is a container where you can store values associated with another value, called key-value pairs. Key-value pairs can be any combination of types as long as the key type is comparable. The elements of a map are in the order you insert the key-value pairs into the map, and you can access the elements by their unique keys. For more info, see Map 	 
Option 	An option is a container that can have one or no value of a type. For more info, see Option. 	 
Range 	Range expressions contain all the numbers between and including the two specified values with .. between, for example 1..5. Range expressions can only be used in some places, such as in for expressions. See Range for more details.

  Comments

A code comment explains something about the code. Comments are ignored when the program runs.
UEFN
Comments

A code comment explains something about the code, or the programmer's reason for why something is programmed the way it is. When the program runs, code comments are ignored.

1+2 # Hello

	single-line comment: Anything that appears between # and the end of line is part of the code comment.

1<# inline comment #>+2

	inline block comment: Anything that appears between <# and #> is part of the code comment. Inline block comments can be between expressions on a single line and don‚Äôt change the expressions.

DoThis()
<# And they
can run multiple
long lines #>
DoThat()

	multi-line block comment: Anything that appears between <# and #> is part of the code comment. Multi-line block comments can span multiple lines.

<# Block comments nest <# like this #> #>

	nested block comment: Anything that appears between <# and #> is part of the code comment, and they can nest. This can be useful if you want to comment out some expressions in a line for testing and debugging without changing an existing code comment.

<#>
    Here is a long
    description spanning
    multiple lines.
DoThis() # This expression is not part of the indented comment

	indented comment: Anything that appears on new lines after <#> and is indented four spaces over is part of the code comment. The first line that isn‚Äôt indented four spaces over is not part of the code comment and ends the code comment.

    verse
    comments

    Constants and Variables

Variables and constants can store information, or values, that your program uses.
UEFN
Constants and Variables
Constants

A constant is a location where a value is stored, and its value cannot change during the runtime of the program.

To create a constant, you have to specify its identifier and type, known as declaring a constant, and provide a value for the constant, known as initializing a constant.

A constant must be initialized when it is declared, and must be declared before it can be used.

Constant creation has the following syntax:

Identifier : type = expression

Declaring and initializing a constant with explicit type in Verse

Constants declared in a function can omit the type:

Identifier := expression

Declaring and initializing a constant with inferred type in Verse

If the type is omitted, the constant's type is inferred from the expression used to initialize the constant. Only local constants can omit the type because the type describes how the constant can be used. A constant in a module makes up part of the interface of the module that contains it. Without the type, that interface is nonobvious.

In the following example, a random number is generated in each iteration of the loop and used to initialize the constant RandomNumber. The random number will only break out of the loop it is less than twenty.

loop:
    Limit := 20 
    # For local constants, the type can be omitted.
    RandomNumber : int = GetRandomNumber() 
    # Providing the type explicitly can make the code easier to read.
    if (RandomNumber < Limit):
        break

Note that in each loop iteration, a new constant named RandomNumber is introduced and assigned the result of GetRandomNumber() as its value.
Variables

In addition to the constants described above, Verse also has variables.

Variables are similar to constants, but are defined with the keyword var, which means you can change their values at any point.

For example,

var MaxHealthUpgrade : int = 10

is an integer variable, and its value may not always be 10.

Variable creation has the following syntax:

var Identifier : type = expression

Declaring and initializing a variable in Verse

Note that the type must be explicitly specified for variables.

After you create a variable, you can assign a different value to it with the following syntax:

set Identifier = expression

Changing a variables value

Aside from =, a variety of other operators can be used to mutate a variable. For example,

var X:int = 0
set X += 1
set X *= 2

Global Variables

A global variable in Verse is a variable that is defined at the module scope ‚Äî for example, not in a function or a class. Currently, the only way to declare a global variable in Verse is to use the weak_map(session, t) type where the key type is the type of the current Fortnite island instance, or session, and the value type is any type t. For details on weak_map, see Map.

Since global variables are defined at the module scope, they are accessible by any code that has access to that module.

The following example shows how to create a global integer variable named GlobalInt that is incremented every time ExampleFunction() is called.

using { /Verse.org/Simulation } # For session

var GlobalInt:weak_map(session, int) = map{}

ExampleFunction():void=
    X := if (Y := GlobalInt[GetSession()]) then Y + 1 else 0
    if:
        set GlobalInt[GetSession()] = X
    Print("{X}")

Global variables have the following limitations:

    You can only access values for the current session you are in, not any other session.
    The global variable weak_map cannot be completely read or written to, so it's not possible to read or override values for all sessions.
    You cannot iterate through the values of a weak_map or see how many sessions are currently active, because a weak_map has no length.

    verse
    variables
    constants

Common Types

Common types support the fundamental operations that most programs use.
UEFN
Common Types

Verse is a strongly-typed programming language, which means a type is assigned to every identifier. With strong typing, code won't produce unpredictable results during runtime because the types for identifiers are known, along with how operations affect those types.

There are instances where the type is not explicitly required, such as when creating a constant. In the example MyConstant := 0, the type for MyConstant is inferred to be int because an integer value is assigned to it even though the int type wasn‚Äôt explicitly provided. In instances like this, the type is inferred.

Verse has built-in types that support the fundamental operations most programs need to perform. You can create your own types by combining these into larger structures, but these common types are important to understand as the foundation for using variables and constants in Verse.

The following pages describe the common types of Verse:
  Logic

The logic type represents the Boolean values true and false.
UEFN
Logic

Verse uses logic as the type for Boolean values, which means logic only has two possible values: true and false.

Both true and false are logic literals when you use them in Verse code.

The following is an example of how to create a logic variable named TargetLocked, initialized with the logic literal false:

var TargetLocked : logic = false

Logic Operations

The logic type supports query operations and comparison operations.
Query

Query expressions use the operator ? (query) and check if a logic value is true. Otherwise, the expression fails if the logic value is false.

# Determine whether to show the target-locked icon if a target is locked
if (TargetLocked?):
    ShowTargetLockedIcon()

For more on query operations, see Operators.
Comparison

For comparison operations, you can use the failable operator = to test if two logic values are equal, and the failable operator <> to test for inequality.

For example, the sample code below will make an "unavailable action" icon appear if the player has equipped a weapon but doesn't have a target, or has a target but no weapon. This can be expressed by comparing logic values that represent the two factors.

    If both are false, you won't see the icon because the player isn't trying to attack.
    If both are true, you won't see the icon because the player is able to attack.

# Initialize logic variables for demonstration purposes.
var TargetLocked : logic = false
var WeaponEquipped : logic = true
	
# Determine whether or not the "unavailable action" icon is appropriate.
if (WeaponEquipped <> TargetLocked):
    # The icon should show up, because the player appears to be trying to
    # attack, but is missing either a weapon or a target.
    ShowUnavailableIcon()

For more on comparison operations, see Operators.
Convert Failable Expression to Logic

You can cast a failable expression to a logic type using logic{failable-expression}, where failable-expression is an expression that can fail.

In the following example, the failable expression GetRandomInt(0, MineFrequency) <> 0 is converted to the logic value false if the random integer is 0 and true otherwise.

IsMined := logic{GetRandomInt(0, MineFrequency) <> 0}

Standard Library

The standard library provides functions to help with creating and using logic values. Refer to the Verse API Reference for more details on these functions.

  Int

The int type represents integer (non-fractional number) values.
UEFN
Int

Verse uses int as the type for storing and handling integers. An int in Verse can contain a positive number, a negative number, or zero, and has no fractional component. Supported integers range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807, inclusive.

You can include predefined int values within your code as int literals. An int literal is an integer in your code.

The following are examples of how you can create integer constants and variables with int literals:

# This variable will never change, because it is universally correct.
AnswerToTheQuestion : int = 42
# A quiver of arrows costs this many coins, and cannot change:
CoinsPerQuiver : int = 100
# A quiver of arrows contains this many arrows, and cannot change:
ArrowsPerQuiver : int = 15
# The player currently has 225 coins and 3 arrows. These values can change.
var Coins : int = 225
var Arrows : int = 3
# The game keeps track of the total number of purchases the player makes.
# So far, the player has not bought anything.
var TotalPurchases : int = 0

Int Operations

The int type supports math operations and comparisons with other integers.
Math

You can use the four basic math operations with integers in Verse: + for addition, - for subtraction, * for multiplication, and / for division.

For integers, the operator / is failable, and the result is a rational type if it succeeds.

The rational type can only be used as a parameter to the following functions:

    Floor(): Rounds the rational value down to the closest integer.
    Ceil(): Rounds the rational value up to the closest integer.

The following code uses integer division to determine how many arrows the player can buy with their coins. The integer division is used in an if expression because integer division is failable and so must be in a failure context:

if (NumberOfQuiversYouCanBuy : int = Floor(Coins / CoinsPerQuiver)):
    NumberOfArrowsYouCanBuy : int = NumberOfQuiversYouCanBuy * ArrowsPerQuiver

You can also combine operators for basic math operations (addition, subtraction, and multiplication), and updating a variable's value. These combined operators are the same as assigning the result to the first operand of the math operation. The following code uses int math to sell the player arrows in exchange for coins:

# Take coins from the player. This can cause the player to go into negative
# coins if there is no check that the player has enough coins in advance.
set Coins -= CoinsPerQuiver
# Give arrows to the player.
set Arrows += ArrowsPerQuiver
# Count this as a purchase. We do not have a variable for this.
set TotalPurchases += 1

The operator /= is not supported for int, since the result of integer division is a rational type and therefore cannot be assigned to an int.
Signed Integers

A signed integer is a value that can be positive, or negative, or zero. The operator - can be used to negate an integer if - appears before the integer, for example -3. You can also use the operator + before an integer to help align your code visually, but it won‚Äôt change the value of the integer.

# This is an alternate way to sell arrows to the player. It is
# functionally identical to the code in the Math section above.
set Coins += -CoinsPerQuiver
set Arrows += +ArrowsPerQuiver
set TotalPurchases += +1

Comparison

You can use the failable operator = to test if two integers are equal, and the failable operator <> to test for inequality.

Since numbers are ordered, you can use the failable operator < to test if one integer is less than another integer, and the failable operator > to test if one integer is greater than another.

You can use the failable operator <= to test if one integer is less than or equal to another integer, and the failable operator >= to test if one integer is greater than or equal to another integer.

# Check that the player can afford this purchase.
if (Coins >= CoinsPerQuiver):
    # They can! Proceed with the purchase
    set Coins -= CoinsPerQuiver
    set Arrows += ArrowsPerQuiver
    set TotalPurchases += 1

Standard Library

The standard library provides functions to help with creating and using integers, and common math structures and functions. Refer to the Verse API Reference for more details on these functions.
Alternate Representations of Integers

You can also use the hexadecimal numeral system to represent integers, which is base-16, instead of the decimal numeral system which uses base-10. This means that hexadecimal values are represented with the digits 0-9 and the letters A-F. For example, 0x7F is the same as 127, and 0xFACE is the same as 64206.
Implementation Details

In a future update, int will semantically represent an integer of any size, but currently, an int in Verse is implemented as a signed 64-bit integer. Until this update, an int must be in the range [-2^63, ‚Ä¶ , -1, 0, 1, ‚Ä¶ , 2^63 - 1], and integers, including the results of math operations that are outside this range for int sizes, will produce a runtime error called an integer overflow.

Although integers currently have these restrictions, Verse code with integers that you write today will semantically be the same as when integers can have arbitrary precision.

    verse
    int
    integer
    number
  Float

The float type represents all non-integer numerical values. It can hold large values and precise fractions.
UEFN
Float

Verse uses float as the type for storing and handling floating point numbers, such as 1.0, -50.5, and 3.14159.

A float in Verse is an IEEE 64-bit float, which means it can contain a positive or negative number that has a decimal point in the range [-2^1024 + 1, ‚Ä¶ , 0, ‚Ä¶ , 2^1024 - 1], or has the value NaN (Not a Number).

The implementation for float differs from the IEEE standard in the following ways:

    There is only one NaN value.
    NaN is equal to itself.
    Every number is equal to itself. If two numbers are equal, then no pure Verse code can observe the difference between them.
    0 cannot be negative.

You can include predefined float values within your code as float literals. A float literal is a floating point number in your code.

The following is an example of how to create a float variable named MaxHealth, initialized with the float literal 100.0:

MaxHealth : float = 100.0

Float Operations

Floats support math operations and comparisons with other floats.
Math

You can do the four basic math operations with floats in Verse: + for addition, - for subtraction, * for multiplication, and / for division.

There are also combined operators for doing the basic math operations (addition, subtraction, multiplication, and division), and updating the dereferenced value of a pointer. These combined operators are the same as assigning the result to the first operand of the math operation.

For example, the following code instantly halves the value of CurrentHealth:

# Start with the original health value
var CurrentHealth : float = 75.0
	
# Reduce it to half
set CurrentHealth *= 0.5
	
# CurrentHealth is now 37.5.

Signed Floating Point Numbers

A signed float is a value that can be positive, or negative, or zero. The operator - can be used to negate a float if - appears before the float, for example -3.2. You can also use the operator + before a float to help align your code visually, but it won‚Äôt change the value of the float. In the following code, a "life drain" attack heals the attacker for one eighth of the damage inflicted on the target.

# Set up the parameters that describe the situation
DamageInflicted : float = 10.0
LifeDrainMultiplier : float = 0.125
var CurrentAttackerHealth : float = 99.0
	
# Increase current health based on damage inflicted.
set CurrentAttackerHealth += DamageInflicted * HealingMultiplier
	
# CurrentAttackerHealth is now 100.25.

Comparison

You can use the failable operator = to test if two floats are equal, and the failable operator <> to test for inequality.

Since numbers are ordered, you can use the failable operator < to test if one float is less than another float, and the failable operator > to test if one float is greater than another float.

You can use the failable operator <= to test if one float is less than or equal to another float, and the failable operator >= to test if one float is greater than or equal to another float.

NaN is comparable like other floats, and NaN is larger than all other floats and equal to itself.

# Set up the parameters that describe the situation
DamageInflicted : float = 10.0
LifeDrainMultiplier : float = 0.125
var CurrentAttackerHealth : float = 99.0
MaxAttackerHealth : float = 100.0
	
# Increase current health based on damage inflicted.
set CurrentAttackerHealth += DamageInflicted * HealingMultiplier
	
# Ensure that the attacker does not heal beyond their maximum health
if (CurrentAttackerHealth > MaxAttackerHealth):
    # Too high! Reduce to the maximum value.
    set CurrentAttackerHealth = MaxAttackerHealth
	
# CurrentAttackerHealth is now 100.0.

Standard Library

The standard library provides functions to help with creating and using floats, and common math structures and functions. Refer to the Verse API Reference for more details on these functions.

    verse
    float
    floating point numbers
  String

The string type represents non-numerical values like words, names, sentences, and other collections of characters.
UEFN
String

Verse uses string as the type for storing and handling text, such as "Hello Verse" and "Epic Games". In Verse, a string can contain letters, numbers, punctuation, spaces, and emojis. A string containing no characters "" is called an empty string.

You can include predefined string values within your code as string literals. A string literal is a sequence of characters in your code surrounded by double quotation marks " ".

The following is an example of how to create a string variable named Hello, and initialized with the string literal "Hello world":

Hello : string = "Hello world"

Character Encoding

Character encoding is the mapping between a text character and data that the computer can understand, called a code point.

Verse uses the UTF-8 Unicode character-encoding scheme, a standard developed by the Unicode Consortium to provide comparable support for characters across languages, platforms, and devices.

For example, the emoji in this string "üêà" can also be represented by the emoji‚Äôs Unicode code point "{0u1f408}". For a full list of characters supported in Unicode and their corresponding code points, refer to the Unicode documentation.

The UTF-8 code unit is 8-bits (one byte), and encodes characters with code points that are one to four bytes long. Code points with a lower value use fewer bytes than code points with higher values. For example, "a" uses one byte "{0o61}", while "√°" uses two bytes "{0oC3}{0oA1}".
String Operations

Strings support concatenation, comparison, indexing, getting the length of the string, and string interpolation.
Concatenation

Concatenation is when one string is appended to another string. You can use the operator + to concatenate strings.

For example, the following code results in the variable Announcement containing the string "...And the winner is: Player One!".

# The winning player's name:
WinningPlayerName : string = "Player One"
# Build a message announcing the winner.
Announcement : string = "...And the winner is: " + WinningPlayerName + "!"

String Interpolation

You can inject a value into a string if it has a valid ToString() function defined in the current scope.

For example, the following code results in the variable Announcement containing the string "...And the winner is: Player One!".

# The winning player's name:
WinningPlayerName : string = "Player One"
# Build a message announcing the winner.
Announcement : string = "...And the winner is: {WinningPlayerName}!"

Comparison

Whether two strings are equal depends on whether they use the same characters.

Comparison of strings in Verse is done by comparing the code points of each character. Comparison of two strings is case sensitive, because uppercase and lowercase characters have different code points.

You can use the failable operator = to test if two strings are equal, and the failable operator <> to test for inequality.

There can be multiple ways to represent the same character in Unicode. For example, "√©" is "{0u0049}", but you can also use two code points: "{0u0065}", which is "e", and "{0u0301}", which is a combining accent. This means that if you compare these strings, which both appear to be the character "√©" but the strings use different code points, the strings will not be equal. "{0u0049}" is not the same as "{0u0065}{0u0301}".

The following example would check to see if the player has used the correct item to make progress in an adventure/puzzle game:

# This is the item the puzzle requires to unlock the next step:
ExpectedItemInternalName : string = "RedPotion"
# This is the item that the player has selected:
SelectedItemInternalName : string = "BluePotion"
	
# Check to see if the player has the right item selected.
if (SelectedItemInternalName = ExpectedItemInternalName):
    # They do! Report that the puzzle can proceed to the next step.
    return true

# They do not. Report that this item does not advance the puzzle.
return false

Length

You can get the number of UTF-8 code units in a string by accessing the member Length on the string. For example, "hey".Length is 3.

The length of a string accounts for the amount of data it takes to represent the string in UTF-8 code units. For example, "h√©y".Length is 4, because it takes an extra UTF-8 code unit to represent the character √©, even though the string appears to have three characters. The following code displays a "seconds" timer with two digits. It will pad the display with a leading zero if needed.

# SecondsRemaining is assumed to be non-negative
SecondsRemaining : int = 30
	
# Automatically convert the int representation to a string:
SecondsString:string = SecondsRemaining

# Set up the timer display string.
var Combined : string = "Time Remaining: "
	
# If the string is too long, replace it the maximum two-digit value, 99.
if (SecondsString.Length > 2):
    # Too much time on the clock! Set the string to a hard-coded max value.
    set Combined += "99"
else if (SecondsString.Length < 2):
    # Pad the display with a leading zero.
    set Combined += "0{SecondsString}"
else:
    # The string is already the exact length, so add it.
    set Combined += SecondsString

Index

You can access the UTF-8 code unit at a specific index of the string. The first UTF-8 code unit in a string has an index of 0, and each subsequent code unit index increases in number.

For example, "cat"[0] is "c" and "cat"[1] is "a".
Index 	0 	1 	2
Character 	"c" 	"a" 	"t"
Code Unit 	"{0o63}" 	"{0o61}" 	"{0o74}"

In cases where a string has characters that are represented by more than one code unit, there will be an index for each code unit. For example, "√°" is represented by two UTF-8 code units "{0oC3}{0oA1}", so "c√°t"[1] is "{0oC3}" and "c√°t"[2] is "{0oA1}".
Index 	0 	1 	2 	3
Character 	"c" 	"√°" 	  	"t"
Code Unit 	"{0o63}" 	"{0oC3}" 	"{0oA1}" 	"{0o74}"

The last index in a string is one less than the length of the string. For example, "cat".Length is 3 and the index for "t" in "cat" is 2.
Standard Library

The standard library provides functions to help with creating and using strings. Refer to the Verse API Reference for more details on these functions.
Alternate Representations of Characters

Some characters have alternate representations when they‚Äôre used in a string. For example, "{}" can be used for string interpolation or for the code points of characters, but they can also be used as the brace characters {} themselves in text.

To be able to use an alternate representation of a character in a string, you must add the escape character "\" before the character in the string. For example, "\{\}" is rendered as {} in text, and "\n" starts a new line in text.
Implementation Details

The string type is a type alias of []char, an array of UTF-8 code units. Because string is a type alias for an array, string has the same behavior as arrays.

There are two primitive types for characters, depending on their size and code point format ‚Äî char and char32. The only capabilities of char and char32 in Verse are for comparison, and to access their values.
Primitive Type 	Description 	Supported Formats
char 	A primitive type that represents a single UTF-8 code unit (one byte), up to the value 256 (0off). 	Code units of the form 0oXX. For example, 0o52.
char32 	A primitive type that represents a Unicode code point. 	Code points of the form 0uXXXX. For example, 0u0041.

You can also express literals with single quotes. Whether the primitive type of the string in single quotes is char or char32 depends on the UTF-8 code units used for the character. For example, 'e' is char, and '√©' is char32.

    verse
    string

  Rational

The rational type is used as the result of integer division.
UEFN
Rational

Three major numeric types are supported in Verse: int, used for integers, float, used for floating-point numbers, and rational, used for rational numbers.

The operations supported for the rational type are currently limited to these built-in operations:

Ceil(:rational):int

Floor(:rational):int

However, rational will likely show up often in error messages. For example:

Z:int = X / Y

This will fail the type checker with a message that indicates that rational is not a subtype of int.

See Int for more information on math operations and rational types.

    verse
    primer
    rational
  Any

Any is the supertype of all types, meaning whatever behavior is defined for it is also defined for all the any subtypes.
UEFN
Any

Verse has a special type, any, that is the supertype of all types (all other types are subtypes of any). Because of this, any supports very few operations, as all other types must be able to provide the same functionality that any provides.

For example, if any were to define a comparison operation (which it doesn't), then all other types would also have to define a comparison operation (which they don't).

There is very little that you can do with an any type. but it's good to be aware of this type as it may come up when writing code that produces an error.

But there are ways that you can use any:

Letters := enum:
    A
    B
    C

letter := class:
    Value : char

    Main(Arg : int) : void =
        X := if (Arg > 0)
            Letters.A
        else
            letter{Value := 'D'}

In the code example above, X is given the type any, as that is the lowest supertype of both Letters and letter.

More usefully, any can be used as the type for a parameter to a function that is ignored (but might be required as an argument for a method of an implemented interface).

For example:

FirstInt(X:int, :any) : int = X

The second argument to FirstInt is ignored, and can be of any type, so it is given the any type. FirstInt can be more generally written using parametric types. For example:

First(X:t, :any where t:type) : t = X

    verse
    primer
    any
    type
  Comparable

A subtype of any, comparable adds the requirement that any value of this type can be compared to any other value of this type.
UEFN
Comparable

The comparable type is used to compare values of this type to other values of the same type.

The = and <> operators make use of this type to define their signatures.

operator'='(:t, :comparable where t:subtype(comparable)):t
operator'<>'(:t, :comparable where t:subtype(comparable)):t

Each of these functions is defined as taking a first argument that is an arbitrary subtype of comparable and a second argument that is also an arbitrary subtype, and that returns the same type as the first argument.

The comparable type has many subtypes that you can use. These subtypes can be compared both with other values of the same type type, and other subtypes of comparable. These subtypes include:

    int
    logic
    float
    char
    char32
    array if all contained types are subtypes of comparable
    option if all contained types are subtypes of comparable
    tuple if all contained types are subtypes of comparable
    map if all contained types are subtypes of comparable

Classes can also be made to be subtypes of comparable with the unique specifier. Instances of classes with this specifier are only equal to themselves, even if the contained members are equal. For example:

int_ref := class<unique>:
    Contents:int

Main()<decides> : void =
    X := int_ref{Contents := 0}
    Y := int_ref{Contents := 0}
    X = X # Succeeds
    X = Y # Fails
    X <> Y # Succeeds

Currently float, option, and classes (regardless of the presence of unique) cannot be used as keys of maps, meaning map keys are required to be a subtype of comparable that is not given a name (and therefore, map key types cannot be parametric types, as the required subtyping cannot be described in Verse code).

Note that because a value of a subtype of comparable can be compared to any other value of another subtype of comparable, some unexpected results can occur. For example:

0 = 0.0

This example will fail because 0 is of type int, while 0.0 is of type float, and int and float do not share a subtyping relationship.

    verse
    primer
    type
    comparable
  Void

The void type can only be used as a return type of a function and indicates that the result of the function is not useful.
UEFN
Void

In addition to the standard types in Verse, there are some additional constructs that can be used the way you would use a type, but that technically are not types. void is one such construct.

When used as the result of a function, it indicates that the function can return any value, but when invoked, it will provide no particular result of interest.

For example:

Foo() : void = {}

In this example, Foo won't have a result that is useful. Specifically, its result type is true, which has the single inhabiting unit value false. void can also be used as the type for constants or function parameters, similarly indicating that the value can't be used for anything useful. In this way, a void constant or function parameter is similar in purpose to an any function parameter.

For example:

FirstInt(X:int, :void) : int = X

Technically, void can be thought of as a function defined as

void(:any) : true

When used as a type, you can think of it as being applied to whatever is assigned to the corresponding typed identifier.

Using a function in a type position is only allowed for a void function. Functions used in this way are known as functors.

    verse
    primer
    type
    void
  Operators

Operators are special functions defined in the Verse programming language to perform actions such as the math operations for addition and multiplication.
UEFN
Operators

Operators are special functions defined in the Verse programming language to perform actions such as math operations on their operands. For example, in the expression 1 + 2, the + is an operator, and 1 and 2 are both operands.

There are three formats for operators that you‚Äôll see in Verse:

    Prefix: There is only one operand and the operator is before the operand.
    Prefix operator Expressions in Verse

    Infix: There are two operands and the operator is between the operands.
    Infix operator Expressiosn in Verse

    Postfix: There is only one operand and the operator is after the operand.
    Postfix operator expressions in Verse

This page describes all the operators you can use in Verse, how they work, and their order of evaluation when used in combination with other operators.
List of All Operators and Operator Precedence

When multiple operators are used in the same expression, they are evaluated in the order of highest to lowest precedence. The table below lists all built-in operators in Verse and their precedence.
Name 	Operator 	Description 	Operator Format 	Operator Precedence 	Example
Query 	? 	The ? operator checks if a logic value is true. See Query for more details. 	Postfix 	9 	BossDefeated?
Not 	not 	The not operator negates the success or failure of an expression. See Not for more details. 	Prefix 	8 	not BossDefeated?
Positive 	+ 	You can use the + operator as a prefix to a number to help align your code visually, but it won't change the value of the number. See Math for more details. 	Prefix 	8 	+MyScore
Negative 	- 	You can use the operator - as a prefix to a number to negate the number value. See Math for more details. 	Prefix 	8 	-MyScore
Multiplication 	* 	The * multiplies two number values together. See Math for more details. 	Infix 	7 	MyScore * ScoreMultiplier
Division 	/ 	The / operator divides the first number operand by the second number operand. Integer division is failable. See Math for more details. 	Infix 	7 	MyScore / ScorePenalty
Addition 	+ 	The + operator adds two number values together. When used with strings and arrays, the two values are concatenated. See Math for more details. 	Infix 	6 	MyScore + ScoreBonus
Subtraction 	- 	The - operator subtracts the second number operand from the first operand. See Math for more details. 	Infix 	6 	MyScore - ScorePenalty
Addition assignment 	set += 	With this operator, you can combine addition and assignment in the same operation to update a variable's value. See Math for more details. 	Infix 	5 	set MyScore += ScoreBonus
Subtraction assignment 	set -= 	With this operator, you can combine subtraction and assignment in the same operation to update a variable's value. See Math for more details. 	Infix 	5 	set MyScore -= ScorePenalty
Multiplication assignment 	set *= 	With this operator, you can combine multiplication and assignment in the same operation to update a variable's value. See Math for more details. 	Infix 	5 	set MyScore *= ScoreMultiplier
Division assignment 	set /= 	With this operator, you can combine division and assignment in the same operation to update a variable's value, unless the variable is an integer. See Math for more details. 	Infix 	5 	set MyScore /= ScorePenalty
Equal to 	= 	The = operator succeeds when the left operand is equal to the right operand. Fails otherwise. See Comparison for more details. 	Infix 	4 	MyScore = HighScore
Not equal to 	<> 	The <> operator succeeds when the left operand is not equal to the right operand. Fails otherwise. See Comparison for more details. 	Infix 	4 	MyScore <> HighScore
Less than 	< 	The < operator succeeds when the left operand is less than the right operand. Fails otherwise. See Comparison for more details. 	Infix 	4 	MyScore < HighScore
Less than or equal to 	<= 	The <= operator succeeds when the left operand is less than or equal to the right operand. Fails otherwise. See Comparison for more details. 	Infix 	4 	MyScore <= HighScore
Greater than 	> 	The > operator succeeds when the left operand is greater than the right operand. Fails otherwise. See Comparison for more details. 	Infix 	4 	MyScore > HighScore
Greater than or equal to 	>= 	The >= operator succeeds when the left operand is greater than or equal to the right operand. Fails otherwise. See Comparison for more details. 	Infix 	4 	MyScore >= HighScore
And 	and 	The and operator succeeds only when all the operands succeed. See And / Or Operators for more details. 	Infix 	3 	BossDefeated? and TargetScoreReached?
Or 	or 	The or operator succeeds if at least one of the operands succeeds. See And / Or Operators for more details. 	Infix 	2 	BossDefeated? or TargetScoreReached?
Variable and constant initialization 	: = 	With this operator, you can store values in a constant or variable. See Constants and Variables for more details. 	Infix 	1 	MyScore : int = 42
Variable assignment 	set = 	With this operator, you can update the values stored in a variable. See Constants and Variables for more details. 	Infix 	1 	set MyScore = 42

If there are operators with the same precedence in the same expression, then they are evaluated left to right. For example in the expression 3*2/4, both operators * and / have the same precedence, so 3*2 is evaluated first and its result becomes the left operand for the / operator.

You can change the order in which operators are evaluated by grouping expressions with (). For example, (1+2)*3 and 1+(2*3) don't evaluate to the same result. See Grouping for more details.
Comparison

You can control the success and failure flow with comparison expressions, which use the inequality and equality operators. Comparison expressions are failable, so you can only use comparison operators in failure contexts, such as in if expressions.

The table below describes each operator and what types it supports. All comparison operators use the infix format.
Operator 	Supported BUilt-In Types 	Description
< 	

    float
    int

	The < operator succeeds when the left operand is less than the right operand. Fails otherwise.
<= 	

    float
    int

	The <= operator succeeds when the left operand is less than or equal to the right operand. Fails otherwise.
> 	

    float
    int

	The > operator succeeds when the left operand is greater than the right operand. Fails otherwise.
>= 	

    float
    int

	The >= operator succeeds when the left operand is greater than or equal to the right operand. Fails otherwise.
<> 	

    float
    int
    logic
    string
    enum

	The <> operator succeeds when the left operand is not equal to the right operand. Fails otherwise.
= 	

    float
    int
    logic
    string
    enum

	The = operator succeeds when the left operand is equal to the right operand. Fails otherwise.

Both <>and = are also supported for array, map, tuple, and class instances, but with restrictions. The array, map, and tuple instances can only contain supported types, and class instances are only supported if they contain at least one var member.
Decision

You can control the success and failure flow with decision expressions, which use the operators not, and, and or. Decision expressions are failable, so you can only use comparison operators in failure contexts, such as in if expressions. You can use any expressions that succeed or fail with decision operators.
Not Operator

The decision operator not negates the success or failure of an expression. The not operator uses the prefix format.

For example, when expression fails, not expression will succeed. When expression succeeds, not expression will fail and the effects of expression are never committed (as if the expression never happened).

For example, after the following code is executed, Example will still have the initial value 0:

var Example : int = 0
if (not (set Example = ExampleArray[0])) { ‚Ä¶ }

You can use not not expression as a way to check if an expression will succeed but make it so the expression never happens.
Outcome of the Expression p 	Outcome of the Expression not p 	Outcome of the Expression not not p
Succeeds and the result is p 	The expression fails, and the effects of p are not committed. The result of the expression is no value. 	The expression succeeds, but the effects of p are not committed. The result of the expression is true.
Fails and the result is no value 	The expression succeeds. The result of the expression is true. 	The expression fails. The result of the expression is no value.

Reference for the not operator evaluating an expression, represented by p.
And / Or Operators

The decision operator and uses the infix format and is a failable expression that succeeds if both operands succeed, or fails if at least one operand fails.

The decision operator or uses the infix format and is:

    A failure context for the first operand.
    A failable expression only if the second operand is failable.

The or operator skips evaluation of the second operand if the first operand succeeds.

The table below describes the results of all the operand combinations of success and failure for decision expressions using the operators and and or.
Outcome of the Expression p 	Outcome of the Expression q 	Outcome of the Expression p and q 	Outcome of the Expression p or q
Succeeds and result is p 	Succeeds and the result is q 	The expression succeeds, so the effects of both p and q are committed. The result of the expression is q. 	The expression succeeds, and only the effects of p are committed. q is not executed because p succeeded. The result of the expression is p.
Succeeds and the result is p 	Fails and the result is no value 	The expression fails, and the effects of both p and q are not committed. The result is no value. 	The expression succeeds, and only the effects of p are committed. q is not executed because p succeeded. The result of the expression is p.
Fails and the result is no value 	Succeeds and the result is q 	The expression fails, and the effects of both p and q are not committed. The result is no value. 	The expression succeeds, and only the effects of q are committed. The result of the expression is q.
Fails and the result is no value 	Fails and the result is no value 	The expression fails, and the effects of both p and q are not committed. The result is no value. 	The expression fails, and the effects of both p and q are not committed. The result of the expression is no value.

Reference for the and and or operators evaluating expressions, represented by p and q.
Math

With math expressions, you can do the four basic math operations (addition, subtraction, multiplication, and division) with number values, and add strings together. All the operators use the infix format, except + and - can also be a prefix for number values. There are also assign operators, e.g., set X += 10. They are almost the same as doing the operation and then assigning the result, set X = X + 10, the difference is that the X in this case is only evaluated once. The result of an assignment operator is the value used to update the variable.

The table below describes each operator and what types it supports.
Operator 	Supported Built-In Types 	Description
+ 	

    float
    int
    string
    array

	The + operator adds two number values together. When used with strings and arrays, the two values are concatenated. You can also use the operator + as a prefix to a number, for example +6, to help align your code visually, but it won't change the value of the number.
- 	

    float
    int

	The - operator subtracts the second number operand from the first operand. You can also use the operator - as a prefix to a number to negate the number value, for example -3.2.
* 	

    float
    int

	The * multiplies two number values together.
/ 	

    float
    int (failable)

	The / operator divides the first number operand by the second number operand Integer division is failable and returns the rational type. For more details on integer division, see int.
set += 	

    float
    int
    string
    array

	With this operator, you can combine addition and assignment in the same operation to update a variable's value.
set -= 	

    float
    int

	With this operator, you can combine subtraction and assignment in the same operation to update a variable's value.
set *= 	

    float
    int

	With this operator, you can combine multiplication and assignment in the same operation to update a variable's value.
set /= 	

    float

	With this operator, you can combine division and assignment in the same operation to update a variable's value, unless the variable is an integer. For more details on integer divsion, see int.
Query

Query expressions use the operator ? (query) and check if a logic value is true. Otherwise, the expression fails. The ? (query) operator uses the postfix format.
Outcome of the Expression p 	Outcome of the Expression p?
true 	Succeeds and result is true.
false 	Fails and result is no value.

Reference for the ? (query) operator evaluating expressions, represented by p.

For example:

if (IsMorning?):
    Say("Good Morning!")

Grouping

Group your Verse expressions to specify order of evaluation and improve readability.
UEFN
Grouping

Grouping expressions is a way to specify order of evaluation, which is useful if you need to work around operator precedence.

You can group expressions by using ().

For example, the expressions (y2 - y1) and (x2 - x1) below are evaluated before dividing the numbers.

(y2 - y1) / (x2 - x1)

As an example, take an in-game explosion that scales its damage based on the distance from the player, but where the player's armor can reduce the total damage:

BaseDamage : float = 100
Armor : float = 15

# Scale by square distance between the player and the explosion. 1.0 is the minimum
DistanceScaling : float = Max(1.0, Pow(PlayerDistance, 2.0))

# The farther the explosion is, the less damage the player takes
var ExplosionDamage : float = BaseDamage / DistanceScaling

# Reduce the damage by armor
set ExplosionDamage -= Armor 

# Avoid negative damage values so that explosions can't heal very high armor players.
set ExplosionDamage = Max(0.0, ExplosionDamage) 

Using grouping, you could rewrite the example above as:

BaseDamage : float = 100
Armor : float = 15
DistanceScaling : float = Max(1.0, Pow(PlayerDistance, 2.0))
ExplosionDamage : float = Max(0.0, (BaseDamage / DistanceScaling) - Armor)

Grouping expressions can also improve the readability of your code.
Code Blocks

A code block is a group of expressions, and introduces a new scope for variables and constants.
UEFN
Code Blocks

A code block, or block, is a group of zero or more expressions that introduces a new scoped body. (A block with zero expressions would be an empty block, and ideally would only be used as a placeholder to be filled in later.)

Code blocks can only appear after identifiers.

Scope refers to the part of the program where the association of an identifier (name) to a value is valid, and where that name can be used to refer to the value. For example, any constants or variables that you create within a code block only exist in the context of the code block. This means that the lifetime of objects is limited to the scope they're created in and they cannot be used outside of that code block.

The following example shows how to calculate the maximum number of arrows that can be bought with the number of coins the player has. The constant MaxArrowsYouCanBuy is created within the if block and therefore its scope is limited to the if block. When the constant MaxArrowsYouCanBuy is used in the print string, it produces an error because the name MaxArrowsYouCanBuy doesn't exist in the scope outside of the if expression.

CoinsPerQuiver : int = 100
ArrowsPerQuiver : int = 15
var Coins : int = 225

if (MaxQuiversYouCanBuy : int = Floor(Coins / CoinsPerQuiver)):
    MaxArrowsYouCanBuy : int = MaxQuiversYouCanBuy * ArrowsPerQuiver

Print("You can buy at most {MaxArrowsYouCanBuy} arrows with your coins.") # Error: Unknown identifier MaxArrowsYouCanBuy

Verse doesn't support reusing an identifier even if it's declared in a different scope, unless you can qualify the identifier by adding (qualifying_scope:) before the identifier, where qualifying_scope is the name of an identifier's module, class, or interface. Whenever you define and use the identifier, you must also add a qualifier to the identifier.

For more details, see module, class, and interface.
Code Block Formats

Code blocks have three possible formats in Verse. They are all semantically equivalent, so you can change the style of a code block without changing what it does.

If you nest a code block inside of another code block, you must still use an identifier at the beginning of the nested code block. To nest code, use the block expression.
Spaced Format

With this format, the block begins with :, with each expression that follows on its own line. Each line is uniformly indented four spaces.

if (test-arg-block):
    expression1
    expression2

Note that if (test-arg-block) is not part of the block, but the block starts at the end of that line with :.

You can also use ; to separate multiple expressions on a single line.
Multi-Line Braced Format

The block is enclosed by {}, and expressions are on new lines.

if (test-arg-block)
{
    expression1
    expression2
}

You can also use ; to separate multiple expressions on a single line.
Single-Line Dot Format

With this format, the block begins with . with each expression on the same line, and each expression is separated by ; instead of being placed on a new line.

if (test-arg-block). expression1; expression2

If you use the single-line dot format in an if expression that has an else, then you can only have one expression before the else. For example:

if (test-arg-block). expression1 else. expression2

    verse
    code blocks
  Functions

A function is reusable code that performs an action and produces different outputs based on the input you provide.
UEFN
Functions

A function is reusable code that provides instructions for performing an action, such as Dance() or Sleep(), and produces different outputs based on the input you provide.

Functions provide abstraction for behaviors, which means that these reusable functions hide the implementation details that aren't relevant for other parts of your code and that you don't need to see.

Let's use ordering food from a menu as an example for functions and abstraction. The function for ordering food could look something like this:

OrderFood(MenuItem : string) : food = {...}

When you order food at a restaurant, you tell the waiter which dish on the menu you want,OrderFood("Ramen"). You don't know how the restaurant will prepare your dish, but you expect to receive something that's considered a food after ordering. Other customers can order different dishes from the menu and also expect to receive their food.

This is why functions are useful - you only need to define these instructions in one place - in this case, defining what should happen when someone orders food. You can then reuse the function in different contexts - such as for every customer in the restaurant who orders off the food menu.

The sections below describe how to create a function, and how to use a function once it's defined.
Defining Functions

The function signature declares the function name (identifier), and the input (parameters) and output (result) of the function.

Verse functions can also have specifiers, which specify how to use or implement a function.

The function body is a block of code that defines what the function does when it's called.

The sections below explain these concepts in more detail.

Function syntax looks like:

Identifier(parameter1 : type, parameter2 : type) <specifier> : type = {}

Diagram of Verse function syntax
Parameters

A parameter is an input variable declared in a function signature and used in the body of the function. When you call a function, you must assign values to the parameters, if there are any. The assigned values are called arguments to the function.

A function can have no parameters - for example, Sleep() - or as many parameters as you need. You declare a parameter in the function signature by specifying an identifier and type between the parentheses (). If you have multiple parameters, they must be separated by commas ,.

For example:

Example(Parameter1 : int, Parameter2 : string) : string = {}

All of the following are valid:

Foo():void = {}

Bar(X:int):int = X

Baz(X:int, ?Y:int, ?Z:int = 0) = X + Y + Z

The syntax ?Y:int defines a named argument with the name Y of type int.

The syntax ?Z:int = 0 defines a named argument named Z of type int that is not required to be provided when the function is called, but uses 0 as its value if it is not provided.
Result

The result is the output of a function when that function is called. The return type specifies what type of value you can expect from the function if it successfully executes.

If you don't want your function to have a result, you can set the return type to void. Functions with void as the return type always return the value false, even when you specify a result expression in the function body.
Specifiers

In addition to specifiers on the function that describe the behavior of the defined function, there can be specifiers on the identifier (the name) of the function. For example:

Foo<public>(X:int)<decides>:int = X > 0

This example defines a function named Foo that is publicly accessible and has the decides effect. Specifiers after the parameter list and before the return type describe semantics of the function, and contribute to the type of the resulting function. Specifiers on the name of the function only indicate behavior related to the name of the defined function, such as its visibility.
Function Body

The function body is the block of code that defines what the function does. The function uses any parameters that you define in the function signature of the function body to create a result.

A function automatically returns the value produced by the last executed expression.

For example:

Foo()<decides>:void = {}

Bar():int =
    if (Foo[]):
        1
    else:
        2

The function Bar() returns either 1 or 2, depending on whether Foo[] fails.

To force the return of a particular value (and the immediate exit of the function), use the return expression.

For example:

Find(X:[]int, F(:int)<decides>:void)<decides>:int =
    for (Y:X, F(Y)):
        return Y
    false?

The expression return Y will exit the function Find, returning the value contained in Y to the caller of the function. Note false? is used as a way to force the function to fail. In this case, this is sensible, since no value matching the predicate F was found in X. In the case of a function defined as returning void, an expression doesn't need to be provided with the return expression.

For example:

AnyOf(X:[]int, F(:int)<decides>:void)<decides>:void =
    for (Y:X, F(Y)):
        return
    false?

Effects

Effects on a function describe additional behaviors that can be taken by the function when called. Specifically, the decides effect on a function indicates that the function could fail in a way that the caller might need to handle (or propagate to its caller by also being marked as decides).

For example:

Fail()<decides>:void = false?

This defines a function that always fails. Any caller would need to handle or propagate the failure. Note the syntax: the effect is described as a specifier on the function. The type of a function with such an effect can be made to closely resemble the definition of the function via the type macro:

type{_()<decides>void}

Calling Functions

A function call is an expression that evaluates (known as calling or invoking) a function.

There are two forms for function calls in Verse:

    FunctionName(Arguments): This form requires that the function call succeeds and can be used in any context.

    FunctionName[Arguments]: This form means that the function call can fail. To use this form, the function must be defined with the specifier <decides> and called in a failure context.

Invocation is performed by using parentheses if the function does not have the decides effect. For example:

Foo()
Bar(1)
Baz(1, ?Y := 2)
Baz(3, ?Y := 4, ?Z := 5)
Baz(6, ?Z := 7, ?Y := 8)

Note how named arguments, for example ?Y:int, are passed by referring to the name prepended by ? and providing a value to the right of :=. Note also that the named argument ?Z is optional. Importantly, the order of the named arguments at the call site is irrelevant except for any side effect that may occur while producing the value for the named argument.

To invoke a function that has the decides effect, square brackets should be used. This allows array indexing, which incurs the decides effect, to follow similar syntax to functions marked with the decides effect. For example:

Foo()<decides>:void = {}

Bar():int =
    if (Foo[]):
        1
    else:
        2

Tuple Unpacking

A function that accepts multiple arguments is indistinguishable when invoked from a function that accepts a single tuple argument with elements of the same types as the multiple arguments. The lack of distinction when invoked also applies to the type of each function - they have the same type.

For example:

Second(:any, X:t where t:type):t = X

This is equivalent to:

Second(X:tuple(any, t) where t:type):t = X(1)

Both can be invoked as:

X := 1
Y := 2
Second(X, Y)

or

X:tuple(int, int) = (1, 2)
Second(X)

Both satisfy the type type{_(:any, :t where t:type):t}.
The Function Type

A function's type is made up of its parameter type (potentially defined as an unpacked tuple), its effect, and its result type. For example:

type{_(:type1, :type2)<effect1>:type3}

This is the type of a function that takes two arguments of type1 and type2 (or equivalently, one argument of type tuple(type1, type2)), produces effect effect1, and returns a value of type type3.
Overloading

Multiple functions can share the same name as long as there are no arguments that would satisfy more than one such function. This is known as overloading.

For example:

Next(X:int):int = X + 1

Next(X:float):float = X + 1

int_list := class:
    Head:int
    Tail:?int_list = false

Next(X:int_list)<decides>:int_list = X.Tail?

There is no overlap in what arguments any of these functions accept. The correct function to invoke can be resolved unambiguously by the types provided. For example:

Next(0)
Next(0.0)
Next(int_list{Head := 0, Tail := int_list{Head := 1}})

However, the following is disallowed:

First(X:int, :any):int = X

First(X:[]int)<decides>int = X[0]

This is because tuple and array have a subtyping relationship: array is a supertype of tuple when the array's base type is a supertype of all of the tuple's element types. For example:

X := (1, 2)
First(X)

In this example. the call to First can be satisfied by either definition of First. In the case of classes and interfaces, no overloading can occur, as a class may later be modified to implement an interface or two classes may be changed to have an inheritance relationship. Instead, method overriding should be used. For example,

as_int := interface:
    AsInt():int

ToInt(X:as_int):int = X.AsInt()

thing1 := class(as_int):
    AsInt():int = 1

thing2 := class(as_int):
    AsInt():int = 2

Main()<decides>:void =
    X := thing1{}
    ToInt(X) = 1
    Y := thing2{}
    ToInt(Y) = 2

A function that is part of a class definition is called a method, and has additional functionality. Refer to Class to learn more about methods after you're familiar with functions in Verse.

    verse
    functions

Failure

Failure is a way to control the sequence in which a program performs actions, called the control flow.
UEFN
Failure

Failure is control flow in Verse.

Unlike other programming languages that use the Boolean values true and false to change the flow of a program, Verse uses expressions that can either succeed or fail. These expressions are called failable expressions, and can only be executed in a failure context.

Using failure for control flow means that work doesn‚Äôt have to be duplicated, and that you can avoid subtle errors.

For example, in other languages, you have to check that an index for an array is valid before accessing the array element at that index, which is a common cause of errors in other languages.

In Verse, validation and access are combined to avoid this.

For example:

    if (Element := MyArray[Index]):
        Log(Element)

Failable Expression

A failable expression is an expression that can either succeed and produce a value, or fail and return no value. Examples of failable expressions include indexing into an array because an invalid index will fail, and using operators such as comparing two values.

Code that you write isn‚Äôt failable by default. For example, to write a function that can fail, you must add the effect specifier <decides> to the function definition. Currently it is also necessary to add <transacts> when using <decides>.

For a full list of expressions that are failable, refer to the list of Expressions in Verse.
Failure Context

A failure context is a context where it is allowable to execute failable expressions. The context defines what happens if the expression fails. Any failure within a failure context will cause the entire context to fail.

A failure context allows nested expressions to be failure expressions, such as function arguments or expressions in a block expression.

A useful aspect of failure contexts in Verse is that they are a form of speculative execution, meaning that you can try out actions without committing them. When an expression succeeds, the effects of the expression are committed, such as changing the value of a variable. If the expression fails, the effects of the expression are rolled back, as though the expression never happened.

This way, you can execute a series of actions that accumulate changes, but those actions will be undone if they fail anywhere.

To make this work, all functions called in the failure context must have the effect specifier <transacts>, and the compiler will complain if they don't.

User-defined functions do not have the transacts effect by default. An explicit <transacts> specifier must be added to their definitions. Some native functions also do not have the transacts effect and can't be called in failure contexts.

An example of a native function without transacts could be an audio_component with a BeginSound() method. If the sound is started then even if it is stopped it could have been noticed.

The following list includes all of the failure contexts in Verse:

    The condition in if expressions.

    if (test-arg-block) { ‚Ä¶ }

    The iteration expressions and filter expressions in for expressions. Note that for is special in that it creates a failure context for each iteration. If iterations are nested, then the failure contexts will also be nested. When an expression fails, the innermost failure context is aborted, and the enclosing iteration, if any, continues with the next iteration.

    for (Item : Collection, test-arg-block) { ‚Ä¶ }

    The body of a function or method that has the <decides> effect specifier.

    IsEqual()<decides><transacts> : void = { ‚Ä¶ }

    The operand for the not operator.

    not expression

    The left operand for or.

    expression1 or expression2

    Initializing a variable that has the option type.

    option{expression}

    verse
    failure

      Specifiers and Attributes

Learn about specifiers and attributes, and how to apply additional semantics and behavior to your Verse code.
UEFN
Specifiers and Attributes

Specifiers in Verse describe behavior related to semantics, and can be added to identifiers and certain keywords. Specifier syntax uses < and >, with the keyword in between, such as IsPuzzleSolved()<decides><transacts> : void.

Attributes in Verse describe behavior that is used outside of the Verse language (unlike specifiers, which describe Verse semantics). Attribute syntax uses @ followed by the keyword, such as @editable.

The following sections describe all of the specifiers and attributes in Verse and when you can use them.
Effect Specifiers

Effects in Verse indicate categories of behavior that a function is allowed to exhibit. You can add effect specifiers to:

    The () after the name in a function definition: name()<specifier> : type = codeblock.
    The class keyword: name := class<specifier>():.

Effect specifiers are divided into two categories:

    Exclusive: You can have only one or none of the exclusive effect specifiers added to a function, or to the class keyword. If no exclusive effect specifier is added, the default effect is no_rollback.
    Additive: You can add all, some, or none of the additive effect specifiers to a function or the class keyword.

Click image to enlarge.
Example 	Effect

name() : type = codeblock

	

no_rollback: This is the default effect when no exclusive effect is specified. The no_rollback effect indicates that any actions performed by the function cannot be undone and so the function cannot be used in a failure context. This effect cannot be manually specified.
Exclusive Effects 	 

name()<transacts> : type = codeblock

	

transacts: This effect indicates that any actions performed by the function can be rolled back. The transacts effect is required any time a mutable variable (var) is written. You‚Äôll be notified when you compile your code if the transacts effect was added to a function that can‚Äôt be rolled back. Note that this check is not done for functions with the native specifier.

name()<varies> : type = codeblock

	

varies: This effect indicates that the same input to the function may not always produce the same output. The varies effect also indicates that the behavior of the function is not guaranteed to stay the same with new versions of its containing package.

name()<computes> : type = codeblock

	

computes: This effect requires that the function has no side effects, and is not guaranteed to complete. There‚Äôs an unchecked requirement that the function, when provided with the same arguments, produces the same result. Any function that doesn‚Äôt have the native specifier that would otherwise have the converges effect is a good example of using the computes effect.

name()<converges> : type = codeblock

	

converges: This effect guarantees that not only is there no side effect from the execution of the related function, but that the function definitely completes (does not infinitely recurse). This effect can only appear in functions that have the native specifer, but this isn‚Äôt checked by the compiler. Code that provides default values of class fields or values for global variables is required to have this effect.
Additive Effects 	 

name()<transacts><decides> : type = codeblock

	

decides: Indicates that the function can fail, and that calling this function is a failable expression. Function definitions with the decides effect must also have the transacts effect, which means the actions performed by this function can be rolled back (as if the actions were never performed), if there‚Äôs a failure anywhere in the function.

name()<suspends> : type = codeblock

	

suspends: Indicates that the function is async. Creates an async context for the body of the function.

In all cases, calling a function that has a specific effect will require the caller to have that effect as well.
Access Specifiers

Access specifiers define what can interact with a member and how. Access specifiers can be applied to the following:

    The identifier for a member: name<specifier> : type = value
    The keyword var for a member: var<specifier> name : type = value

name<public> : type = value

	

Public: The identifier is universally accessible. You can use this specifier on:

    module
    class
    interface
    struct
    enum
    method
    data

name<protected> : type = value

	

Protected: The identifier can only be accessed by the current class and any subtypes. You can use this specifier on:

    class
    interface
    struct
    enum
    non-module method
    data

name<private> : type = value

	

Private: The identifier can only be accessed in the current, immediately enclosing, scope (be it a module, class, struct, etc.). You can use this specifier on:

    class
    interface
    struct
    enum
    non-module method
    data

name<internal> : type = value

	

Internal: The identifier can only be accessed in the current immediately enclosing, module. This is the default access level. You can use this specifier on:

    module
    class
    interface
    struct
    enum
    method
    data

Class Specifiers

Class specifiers define certain characteristics of classes or their members, such as whether you can create a subclass of a class.

pet := class<abstract>():
    Speak() : void

cat := class(pet):
    Speak() : void = {}

	

abstract: When a class or a class method has the abstract specifier, you cannot create an instance of the class. Abstract classes are intended to be used as a superclass with partial implementation or as a common interface. This is useful when it doesn't make sense to have instances of a superclass but you don't want to duplicate properties and behaviors across similar classes.

cat := class<concrete>():
     # field must be initialized because the class is concrete
    Name : string = "Cat"

	

concrete: When a class has the concrete specifier, it must be possible to construct it with an empty archetype, which means that every field of the class must have a default value. Every subclass of a concrete class is implicitly concrete. A concrete class can only inherit directly from an abstract class if both classes are defined in the same module.

unique_class := class<unique>:
    Field : int

Main()<decides> : void =
    X := unique_class{Field := 1}
    X = X # X is equal to itself
    Y := unique_class{Field := 1}
    X <> Y # X and Y are unique and therefore not equal

	

unique: The unique specifier can be applied to a class to make it a unique class. To construct an instance of a unique class, Verse allocates a unique identity for the resulting instance. This allows instances of unique classes to be compared for equality by comparing their identities. Classes without the unique specifier don't have any such identity, and so can only be compared for equality based on the values of their fields. This means that unique classes can be compared with the = and <> operators, and are subtypes of the comparable type.

cat := class<final>():

	

final: You can only use the final specifier on classes and members of classes:

    When a class has the final specifier, you cannot create a subclass of the class.
    When a field has the final specifier, you cannot override the field in a subclass.
    When a method has the final specifier, you cannot override the method in a subclass.

pets := module:
    cat<public> := class<public>:
        Sound<public> : string = "Meow"

MakeCat():void =
    # cat is successfully constructed outside of its module
    MyNewCat := pets.cat{}

	

public: When a class has the public specifier, anyone can construct an instance of that class, even outside of the module where the class was defined.

pets := module:
    cat<public> := class<internal>:
        Sound<public> : string = "Meow"

GetCatSound(InCat:pets.cat):string =
    return InCat.Sound # Valid: References the cat class but does not call its constructor

MakeCat():void =
    MyNewCat := pets.cat{} # Error: Invalid access of internal class constructor

	

internal: When a class has the internal specifier, you can only call its constructor within the same module or submodules.
Implementation Specifiers

It's not possible to use implementation specifiers when writing code, but you will see them when looking at the UEFN APIs.

GetCreativeObjectsWithTag<native><public>(Tag:tag)<transacts>:[]creative_object_interface

	

native: Indicates that the definition details of the element are implemented in C++. Verse definitions with the native specifier auto-generate C++ definitions. A Verse developer can then fill out its implementation. You can see this specifier used on:

    class
    interface
    enum
    method
    data

creative_device<native><public> := class<concrete>:
    OnBegin<public>()<suspends>:void = external {}

    OnEnd<native_callable><public>():void = external {}

	

native_callable: Indicates that an instance method is both native (implemented in C++) and may be called by other C++ code. You can see this specifier used on an instance method. This specifier doesn‚Äôt propagate to subclasses and so you don‚Äôt need to add it to a definition when overriding a method that has this specifier
Attributes

Attributes in Verse describe behavior that is used outside of the Verse language (unlike specifiers, which describe Verse semantics). Attributes can be added on the line of code before definitions.

Attribute syntax uses @ followed by the keyword.

@editable
Platform : color_changing_tiles_device = color_changing_tiles_device{}

	

editable: Indicates this field is an exposed property that can be changed directly from UEFN so you don't need to modify the Verse code to change its value. For more details, see Customize Device Properties.

    verse
    effects
    attributes
    specifiers
  Control Flow

Control flow is the order in which a computer executes instructions. Verse has a number of ways to change the control flow of your program.
UEFN
Control Flow

Code is generally executed line by line, in the order the expressions appear. This is called sequential execution. You can, however, change the order in which expressions are executed by using control flow expressions.

For example, you can make decisions about what expressions to execute next using if and case expressions, or repeat a sequence of expressions more than once with loop and for. The following pages describe these expressions in detail, and include examples of how to use them.

  Block

The block expression is how you nest code blocks, and behaves similarly to the general code blocks.
UEFN
Block

Since Verse requires an identifier before a code block, block expressions are how you nest code blocks, and block expressions behave similarly to code blocks.

As with code blocks, block introduces a new nested scope body, constraining the lifetimes of any variables created in the block in a way that they cannot be used outside of the block.

expression0
block:
    expression1
    expression2
expression3

`block` Diagram

Unless there is an early exit, the block expression uses the last expression executed in the block as its result. For example, if the last expression in the block is Example : int = 6 then the block expression has 6 as a result.

    verse
    expressions
    block
  If

The if expression is how you make a decision, based on one or more conditions, about what expressions should be executed next.
UEFN
If

With the if expression, you can make decisions that change the flow of the program. As with other programming languages, the Verse if expression supports conditional execution, but in Verse, the conditions use success and failure to drive the decision.

For example, you can write code that defines the fall height a player can drop before taking damage.

var PlayerFallHeight : float = CalculatePlayerFallHeight()

# Players take damage if they fall more than 3 meters
if (PlayerFallHeight > 3.0):
    DealDamage()

# Reset the player‚Äôs fall height
ZeroPlayerFallHeight()

In this example, if PlayerFallHeight is greater than three meters, then the condition succeeds and DealDamage() is executed before the player‚Äôs fall height is reset. Otherwise, the condition fails so the player doesn‚Äôt take any damage but the player‚Äôs fall height is reset.
if

The player fall height example would use the following syntax:

expression0
if (test-arg-block):
    expression1
expression2

After executing expression0, the Verse program enters the if-block. If the test-arg-block succeeds, then the Verse program executes expression1, which can be one expression or a block of expressions. Otherwise, if the test-arg-block fails, the Verse program skips expression1 and only executes expression2.
Diagram of how if expressions work with the example of fall height

Flow diagram for if-block logic.
if ... else

You can also specify an expression to execute when the if expression fails.

For example, the player should gain a double-jump ability if they fall less than three meters and if their jump meter is at 100 percent. But if they fall more than three meters or their jump meter isn‚Äôt at 100 percent, then the character‚Äôs arms will flap to let the player know they cannot double jump.

    var PlayerFallHeight : float = CalculatePlayerFallHeight()

    if (PlayerFallHeight < 3.0 and JumpMeter = 100):
    # Perform a double jump.
        ActivateDoubleJump()
    # Reset the player‚Äôs fall height.
        ZeroPlayerFallHeight()
    else:
    # Flap the character‚Äôs arms to tell the player they
    # cannot double jump right now!
        ActivateFlapArmsAnimation()

    # Set the double-jump cooldown so rapidly pressing Jump does
    # not cause the "flap arms" animation to play inappropriately.
    SetDoubleJumpCooldown()

In this example, the condition of if evaluates whether PlayerFallHeight is less than three meters and if JumpMeter is equal to 100 percent. If the condition succeeds, ActivateDoubleJump() and ZeroPlayerFallHeight() are executed before SetDoubleJumpCooldown().

If the if condition fails, then the expression ActivateFlapArmsAnimation() following else is executed before SetDoubleJumpCooldown().

Syntactically, the if-else example looks like this:

expression0
if (test-arg-block):
    expression1
else:
    expression2
expression3

Example of how if/else expressions work using logic for jumping and fall heights

Flow diagram for if-else-block logic.
if ... else if ... else

If a player has 100 percent shields when they fall more than three meters, they should take maximal damage but still survive. And let‚Äôs modify the rule that gives players a double-jump ability, such that players will only gain double-jump if they fall less than three meters and if their jump meter is greater than 75 percent.

    var PlayerFallHeight : float = CalculatePlayerFallHeight()

    if (PlayerFallHeight > 3.0 and shields = 100):
        DealMaximalDamage()
        return false
    else if (PlayerFallHeight < 3.0 and JumpMeter > 75):
        ActivateDoubleJump()
        return false
    else:
        return true

    # Reset the player‚Äôs fall height
    ZeroPlayerFallHeight()

Syntactically, the if-else if-else example looks like this:

    expression0

    if (test-arg-block0):
        expression1
    else if (test-arg-block1):
        expression2
    else:
        expression3
    expression4

An example of if/else if/else expression in Verse using shield and jumping variables

Flow diagram for if-else if-else-block logic.
if ... then

You can write any of the if conditions in the previous examples on multiple lines without changing how they work:

expression0
if:
	test-arg-block
then:
    expression1
expression2

The code block test-arg-block can contain one or more lines of conditions but they must all succeed to execute expression1 before expression2, otherwise only expression2 will be executed.

The example from the if ... else section rewritten in this format looks like:

var PlayerFallHeight : float = CalculatePlayerFallHeight()

if:
    PlayerFallHeight < 3.0
    JumpMeter = 100
then:
    # Perform a double jump.
    ActivateDoubleJump()
    # Reset the player‚Äôs fall height.
    ZeroPlayerFallHeight()
else:
    # Flap the character‚Äôs arms to tell the player they
    # cannot double jump right now!
    ActivateFlapArmsAnimation()

# Set the double-jump cooldown so rapidly pressing Jump does
# not cause the "flap arms" animation to play inappropriately.	
SetDoubleJumpCooldown()

Single-Line Expression

You can write an if else as a single-line expression, similar to ternary operators in other programming languages. For example, if you want to assign a maximum or minimum Recharge value based on a player‚Äôs ShieldLevel, you can write the following Verse code:

Recharge : int = if(ShieldLevel < 50) then GetMaxRecharge() else GetMinRecharge()

Predicate Requirements

The predicate of the if, which is the expression between the parentheses (), is unlike other programming languages, in that it is not expected to return a Boolean (called logic in Verse). Instead, the predicate is expected to have the decides effect (note that though subtyping normally allows for a subset of effects in places allowing a set of effects, if requires the overall effect of the predicate to include decides). The effect is removed from the surrounding scope. That is to say, the decides effect from all operations in the if predicate is consumed by the if construct. For example, in the code below, Main does not have the decides effect, though it invokes Foo, which does.

Foo()<transacts><decides> : void = {}

Bar() : void = {}

Main() : void =
    if (Foo[]):
        Bar()

This is because, rather than using a logic input to if to choose which branch is taken, the success of the operations contained in the predicate of the if is used to decide the appropriate branch - the then branch if all operations succeed, the else branch (if present) if any operations fail. Note that this means arbitrary operations can be used in the if predicate, including introducing constants. For example:

Main(X : int) : void =
    Y = array{1, 2, 3}
    if:
        Z0 := Y[X]
        Z1 := Y[X + 1]
    then:
        Use(Z0)
        Use(Z1)

Put another way, the scope of the then branch includes any names introduced in the if predicate.
Transactional Behavior

Another deviation of if with respect to other programming languages is the transactional behavior of the predicate to if. The predicate to if must not have the no_rollback effect (implicitly used by all functions that do not explicitly specify transacts, varies, or computes). This is because in the event the predicate fails, all operations taken during the execution of the predicate (short of any operation impacting resources outside of the runtime, such as file I/O, or writing to console) are undone before execution of the else branch. For example:

int_ref := class:
    var Contents : int

    Incr(X : int_ref)<transacts> : void =
        set X.Contents += 1

Foo(X : int) : int =
    Y := int_ref{Contents := 0}
    if:
        Incr(Y)
        X > 0
    then:
        Y.Contents
    else:
        Y.Contents

The function Foo(-1) will return 0, while Foo(1) will return 1. This is because, though the call to Incr occurs before the test of X > 0, the mutation of Y it causes is undone before execution of the else branch. Note that Incr had to manually specify the transacts effect. By default, transactional behavior is not provided, indicated by the implicit no_rollback effect, but it can be added by specifying the transacts effect manually (overriding the implicit no_rollback effect).
Case

The case expression is how you make a decision, from a list of choices, about what expressions should be executed next.
UEFN
Case

With case expressions, you can control the flow of a program from a list of choices. The case statement in Verse is a way to test one value against multiple possible values (as though you were using =), and running code based on which one matches.

The use of case expressions can be found in all kinds of applications, like in games where there is a non-playable character (NPC).

For example, let's say you use the Guard Spawner device to spawn a guard with its patrol option enabled. After the guard spawns into the game, it has a few possible active states, including Idle, Patrol, Alert, Attack, and Harvest. A high-level state-transition diagram for this could look like:
In-game state transition in Verse

You can observe these state transitions in-game.
Example of Guard states in-game

In this video, the guard has its patrol option enabled as the default behavior.

In the video, the guard transitions from patrolling the science base to harvesting some resources. Then the guard spots the player, which sends the guard into an alert state (indicated by the hovering question mark) before entering its attack state (indicated by the hovering exclamation mark).

Depending on the state the guard is in, it will exhibit certain behaviors, and these behaviors are typically coded as functions that are called when the program chooses to enter a specific state.

As code, this high-level guard-state transition could look like this:

    case(GuardStateVariable):
        idle_state =>
            RunIdleAnimation()
            SearchPlayerCharacter()
        harvest_state =>
            GatherResources()
        alert_state=>
            RunAlertAnimation()
            PlayAlertSound()
            DisplayAlertUIElement()
            TargetPlayerCharacter()
        attack_state =>
            RunAttackAnimation()
            DisplayAttackUIElement()
            TargetPlayerCharacter()
            AttackPlayerCharacter()
        _ =>
            RunPatrolAnimation()
            SearchPlayerCharacter()
            SearchResources()

This case expression passes a label that tells the program which functions to run if the guard enters a specific state.

In this expression, the guard's patrol_state is the default case because a guard with patrol enabled should run its default patrol behavior.

Syntactically, this is the same as:

    expression0
    case (test-arg-block):
    label1 =>
        expression1
    label2 =>
        expression2
    _ =>
        expression3 for the default case
    expression4

Case flow diagram in Verse

Each pattern in the case block, such as label1 and label2, must use the form constant => block, where the constant can be an integer, logic, string, char, or enum constant. So case statements only work with in, logic, string, char, and enums.
Structure

Structurally, the Verse case expression runs code based on input of the GuardStateVariable test argument block, and it functionally works the same as a series of if expressions.
Example of running expression3, the alert_state

In this example, the Verse program runs expression3 if GuardStateVariable resolves to alert_state. If the program passes in patrol_state, Verse structurally jumps to the default case, and runs expression5.
Example of running the default state, expression5
Using Case with Other Control Flow

The blocks in a case statement are allowed to break and continue if the case statement is inside of a loop. Blocks of case statements are also allowed to return from the function they are in.

For example:

    loop:
        case (x):
            42 => break
            _ => {}

This absurd loop will either complete immediately if x = 42 or loop forever.

Another example:

    Foo(x : int) : int =
        case (x):
            100 => return 200
            _ => return 100

This example is equivalent to:

    Foo(x : int) : int =
        case (x):
            100 => 200
            _ => 100

This is because the case statement is the last expression of the function.
Default Case

Case statements that do not have a _=> case (a default case) will fail if none of the cases match. It's fine to use such case statements in failure contexts (such as functions with the decides effect).

Case statements that match all of the cases of an enumeration will be non-failing even if they do not have a _=> case.

    verse
    expressions
  Loop and Break

The loop expression repeats the expressions in its code block. End the loop with either a break or return.
UEFN
Loop and Break

With the loop expression, the expressions in the loop block are repeated for every iteration of the loop.

The GIF below of the Fortnite Emote Clean Sweep is an example of how a loop works. The GIF plays to the end, then repeats from the beginning, and the player emoting is like the expressions in a loop block.
GIF of a character sweeping

    # GIF
    loop:
        DoCleanSweepEmote()

Like a GIF, a loop block will repeat forever unless instructed to do otherwise. This is called an infinite loop.

Infinite loops are not very useful in most cases since they will block progress for the program, so Verse provides a way to end and / or suspend.

    End: You can end a loop by exiting with either break or return.
    Suspend: You can suspend a loop if it's used in an async expression. See Concurrency Overview for more details.

It's also possible to do both in the same loop. In this example, the loop block repeats until the random number that's generated is less than twenty.

    loop:
        # generate random number
        RandomNumber : int = GetRandomInt(0, 100)
        # check if random number is less than twenty
        if (RandomNumber < 20):
            # exit loop
            break

Syntactically, this is the same as:

    expression0
    loop:
        expression-block
        if (test-arg-block):
            break
        expression-block
    expression2

Loop flow diagram

Unlike some of the other control flow expressions, the loop expression returns void, so it may not be useful in cases where you want an expression to return a result. If the loop is inside a function, then it's possible to return a value with return, but this will exit not only out of the loop but also out of the function.
Nested Loop Expressions

You can nest one loop inside another loop. The first loop is sometimes called the outer loop, and the second loop is called the inner loop. When the break expression is executed in an inner loop, it only breaks out of the inner loop.

In the example below, the outer loop continues to expression3, then the if expression after the inner loop exits and can execute expression1 and the inner loop again.

    expression0
    # outer loop
    loop:
        expression1
        # inner loop
        loop:
            expression2
            if (test-arg-block0):
                # exit inner loop
                break
        expression3
        if (test-arg-block1):
            # exit outer loop
            break
    expression4

Nest loop block diagram

    verse
    loop and break
    loop block
          For

The for expression iterates over a bounded number of items and repeats the expressions in its code block the same number of times.
UEFN
For

The for expressions, sometimes called for loops, are the same as loop expressions, except that for expressions iterate over a bounded number of items. This means the number of iterations is known before the for loop is executed, and decisions on when to exit the loop are automated for you.

The Sequencer device is an example of a for loop with bounded iterations when you set the Sequencer device Looping setting to a number. The Sequencer's pulse repeats as many times as specified by the device Looping setting.
Using Verse to program the Sequencer Device in UEFN

In this example, two Trigger devices are in the Sequencer's path. When the Sequencer's pulse reaches a Trigger device, the device sends a signal to display text on one of the Billboard devices, and repeats three times.

As code, this example could look like:

for (X := 0..2):
    TriggerDevice1.Transmit()
    TriggerDevice2.Transmit()

The for expression contains two parts:

    Iteration specification: The expressions within the parentheses and the first expression must be a generator. In this example, it is (X := 0..2).
    Body: The expressions after the parentheses. In this example, that is the two lines with Transmit().

For flow diagram in Verse
Generator

A generator produces a sequence of values, one at a time, and gives the value a name. In this example, the generator is X := 0..2, so each iteration of the loop, the generator produces the next value and gives the value the name X. When the generator reaches the end of the sequence, the for loop ends. This decision flow of checking if the loop variable has a valid value is built into the for expression. Generators only support ranges, arrays, and maps.
Iterating over a Range

The range type represents a series of integers; for example, 0..3, and Min..Max.

The start of the range is the first value in the expression ‚Äî for example 0 ‚Äî and the end of the range is the value following .. in the expression ‚Äî for example, 3. The range contains all the integers between, and including, the start and end values. For example, the range expression 0..3 contains the numbers 0, 1, 2, and 3. Range expressions only support int values, and can only be used in for, sync, race, and rush expressions.

for (Number := 0 .. 3):
    Log("{Number}")

The result will add four lines to the log containing the numbers 0, 1, 2, and 3.

A for expression can return the results from each iteration in an array. In the following example, Numbers is an immutable array with the int values -1 to -10.

Numbers := for (Number := 1..10):
    -Number

Iterating over an Array or a Map

Iterations over arrays and maps can be just the values, or the key-value pair for maps and the index-value pair for arrays.

In this case, only the values of the array are used, and Values is an immutable array with the int values 2, 3, and 5.

Values := for (X : array{1, 2, 4}):
    X+1

The same can be done with a map, and ¬¥Values is, in this case, an immutable array with the int values 3, 7`.

Values :=  for  (X := map{ 1=>3,  0=>7 }):
    X

The X->Y pattern can be used to deconstruct an index-value or key-value pair. The index (or key) is bound to the left part (X) and the value is bound to to the right part (Y). An example of Index-value pairs from an array, Values is an immutable array with the int values 1, 3, and 6.

Values := for ( X -> Y : array{1, 2, 4}) :
    X + Y

An example of Index-value pairs from a map, Values is an immutable array with the int values 4, and 7.

Values  :=  for ( X->Y := map{ 1=>3,  0=>7 }):
    X + Y

Filter

You can add failable expressions to the for expression to filter out values from the generator. If the filter fails, then there's no result for that iteration, and for skips to the next value produced by the generator.

For example, the filter Num <> 0 is added to the for expression to exclude 0 from the returned results.

NoZero := for (Number := -5..5, Number <> 0):
    Number

Syntactically, this is the same as:

expression0
for (Item : Collection, test-arg-block):
    expression1
expression2

For with Condition diagram in Verse
Definition

You can also add named expressions to the iteration specification, and the name can be used in both the iteration specification and the body.

Values := for ( X := 1..5; Y:=SomeFunction(X); Y < 10):
    Y

Result: an array with at most 5 items where all values are less than 10.
Nested For

You can nest a for loop inside another for loop. There are two ways to do this:

    Single For Expression: Specified by multiple generators. The result is a one-dimensional array.

    Multiple For Expressions: Separate for blocks. The result is a multidimensional array.

The sections below describe these further.
Single For Expression

You can have multiple loops in a single for expression by adding more generators. The result of a single for expression with multiple generators is a one-dimensional array.

In this example, Values is an immutable array with the int values 13, 14, 23 and 24.

    Values := for(X:=1..2, Y:=3..4):
        X * 10 + Y

Semantically, this is the same as:

expression0
for (Item : Collection, Item2 : Collection2):
    expression1
expression2

Nested For flow diagram in Verse
Multiple For Expressions

You can also nest a for expression in another for-loop body. Since one for expression returns a one-dimensional array, nesting a for expression returns a two-dimensional array.

In this case, Values is an immutable array with two immutable int arrays. The first array contains the values 13, and 14, and the second array contains 23 and 24. (This can be written as array{ array{13, 14}, array{23, 24} }.)

Values := for ( X := 1..2 ):
    for (Y := 3..4):
        X * 10 + Y

Failure

If anything fails inside the iteration specification, then any changes due to that iteration will be rolled back.

for(X := 1..5; S := IncrementSomeVariable(); X < 3):
    X

The result of this for expression is array{1,2}, with only two calls to IncrementSomeVariable after the evaluation of the for loop because the other calls were rolled back when the filter X < 3 failed.

    verse
    expressions


  Defer

Use the defer expression to execute code just before exiting the current scope.
UEFN
Defer

The defer expression delays the execution of code until the current scope exits. You can use the defer expression to handle cleanup tasks like resetting variables. Even when there is an early exit (such as return or break) from the current scope, the expressions in a defer block will run as long as defer is encountered before the exit.

The following code shows how to use defer to reset a variable to zero while still using that same variable as a return value. In this function, RoundScore is returned and the expressions in the defer block run immediately after.

This means you do not need to create a temporary variable to save the value of RoundScore before it gets reset to zero.

OnRoundEnd<public>() : void =
var ScoreThisRound : int = AddRoundScoreToTotalScore()
Print("Points scored this round: {ScoreThisRound}")

<# Adds RoundScore to TotalScore and resets RoundScore to 0.
Returns the RoundScore added. #>
AddRoundScoreToTotalScore<public>() : int = 
	defer:
		set RoundScore = 0
		UpdateUI()
	set TotalScore += RoundScore
	return RoundScore

Defer Expression Use

You can use a defer expression within any sequential code block such as a block, loop, for, if, branch, or even another defer.

Expressions within a defer block must be immediate (and not async) ‚Äî with one exception. Async expressions can still be used within a defer if they are made immediate by using:

    spawn
    branch (if the defer is within an async block such as in a coroutine)

A defer has no result, and cannot be used as an argument or an assignment value.
defer 	defer before an exit

expression0
defer:
    expression1
    expression2
expression3

	

name() : type =
    expression0
    defer:
        expression1
        expression2
    return expression3

Click image to enlarge.
	

Click image to enlarge.

A defer expression will only execute if it is encountered before an early exit occurs.
defer with early return 	defer with a canceled async expression

expression0
if (conditions):
    return
defer:
    expression1
expression2

	

expression0
race:
    block: # canceled during slow-async-expression
        slow-async-expression
        defer:
            expression1
        expression2
     block: # finishes first
         fast-async-expression
         defer:
             expression3
         expression4
expression5

Click image to enlarge.
	

Click image to enlarge.

Multiple defer expressions appearing in the same scope accumulate. The order they are executed is the reverse order they are encountered ‚Äî first-in-last-out (FILO) order. Since the last encountered defer in a given scope is executed first, expressions inside that last encountered defer can refer to context (such as variables) that will be cleaned up by other defer expressions that were encountered earlier and executed later.

Verse does not have deterministic destruction, but defer allows behavior similar to RAII to ensure cleanup.
Multiple defer expressions in a code block 	Multiple defer expressions in different code blocks

expression0
defer:
    expression1
expression2
defer:
    expression3
expression4

	

expression0
if (conditions):
    expression1
    defer:
        expression2
    expression3
expression4
defer:
    expression5
expression6

Click image to enlarge.
	

Click image to enlarge.

Exiting early is allowed within a defer block as long as the exit does not transfer control outside the scope of the defer. For example, using a loop with break is allowed within a defer, but that break must keep the code execution within the defer block. It cannot refer to a loop outside of the defer block.

Any variables that have been encountered in the outer nesting scope of a defer can be used within that defer expression.

Remember that defer runs last at the time of scope exit. This means that it uses whatever the state of the program is (including variable values) at that time, not at the time when the defer is encountered. The code below will print 10 because defer runs immediately after MyScore is set to 10.

var MyScore = 5
defer: 
	Print(MyScore)
set MyScore = 10

Using a defer expression as the last expression within a scope is the same as not using it at all. For example, these two sets of expressions will run in exactly the same order, so defer is not needed:
Without defer 	With defer

expression0
expression1
expression2

	

expression0
expression1
defer:
    expression2

    verse
    expressions
    defer
    raii
    destructors
  Time Flow and Concurrency

You can author time flow the way you author control flow, by executing expressions simultaneously using built-in concurrency expressions in Verse.
UEFN
Time Flow and Concurrency

An important aspect of games and simulations is specifying the order and overlap of operations that take time. Need two or two hundred monsters all acting simultaneously? Planning a swarm of robots that can march in (or out of) step? Thinking about a fleet of spaceships that invade over time?

Time-flow control is at the heart of the Verse programming language, and this is accomplished with concurrent expressions.

You could say that time flow is a type of flow control, but where control flow is about the order in which a computer executes instructions based on the order of expressions in the program, time flow controls the execution in time, not sequence, based on how concurrency expressions are used.

Time flow is another way of saying concurrency.
  Concurrency Overview

See how concurrency expressions impact time flow in Verse.
UEFN
Concurrency Overview

An expression in Verse can be either immediate or async. This describes the time an expression can take to evaluate relative to simulation updates.

Think of a simulation update as when a new frame is shown.

There are cases when multiple simulation updates can occur before a new frame, such as if an online game goes out of sync with the server.
immediate 	async
An immediate expression evaluates with no delay, meaning that the evaluation will complete within the current simulation update. 	An async expression has the possibility of taking time to evaluate, but doesn‚Äôt necessarily have to. An async expression may or may not complete in the current simulation update, or in a later one.
Async Contexts

Async expressions can be used in any Verse code that has an async context.

An async context is the body of a function that has the suspends effect specifier. The suspends effect indicates that async functions can suspend and cooperatively transfer control to other concurrent expressions at various points over several simulation updates before they complete.

The OnBegin() function in a Verse device is a common async function used as a starting point for async code.

Calling an async function has the same syntax as calling an immediate function:

OnBegin<override>()<suspends> : void =
    HideAllPlatforms()

HideAllPlatforms()<suspends> : void =
    for (Platform : Platforms):
        Platform.Hide()
        Sleep(Delay)

Like any other expression, an async expression can have a result. The result of an async expression is only available once it has completed.

# Npc is undefined until it is bound after MoveToNearestNPC() completes which may be several frames into the future
Npc := Player.MoveToNearestNPC()

#Only called after MoveToNearestNPC() completes
Print("Moved to {Npc}")

Any code block that is within an async context (inside the body of an async function) may have any mix of immediate and async expressions.

    If any expressions in a code block are async, then the whole code block is considered to be async.
    If all expressions in a code block are immediate, then the whole code block is considered to be immediate.

All the expressions in the example below are async expressions, so the overall code block is async:

Sleep(2.0)  # waits 2 seconds
Boss.TauntEmote() # waits until TauntEmote() completes
Player.MoveToNearestNPC() # waits until MoveToNearestNPC() completes

All the expressions in the example below are immediate expressions, so the overall code block is immediate:

Print("Reset after explosion")
Platform.Show()
set SecondsUntilExplosion = 12.0

The expressions in the example below are a mix of async and immediate expressions, so the overall code block is async:

Print("Started")
var Seconds := 1.0
Sleep(Seconds)

Print("Waited {Second} seconds")
set Second += 1.0
Sleep(Seconds)

Print("Waited {Second} seconds")
set Second += 1.0
Sleep(Seconds)

Print("Waited {Second} seconds")

Immediate expressions stick together on their own. All adjacent immediate (non-async) expressions are considered to be atomic ‚Äî their code is guaranteed to run without interruption within the same update, and without preemption or context switching. It is as though such code had an automatic mutual-exclusion primitive wrapped around them.

So from the code example above, these immediate expressions are treated atomically:

# These two expressions are always kept together
Print("Started")
var Seconds := 1.0

Sleep(Seconds)

# These two expressions are always kept together
Print("Waited {Second} seconds")
set Second += 1.0

Sleep(Seconds)

# These two expressions are always kept together
Print("Waited {Second} seconds")
set Second += 1.0

Sleep(Seconds)

Print("Waited {Second} seconds")

Like any other code block, the last expression in an async code block is used as a result.
Concurrency Expressions

Verse uses concurrency expressions to determine whether expressions execute concurrently (at the same time), or in sequence, one after another. An async expression is executed or invoked over time, so these concurrency expressions can be especially useful when you‚Äôre using async expressions.
Structured Concurrency

An async expression will block other expressions from executing if it takes a long time to execute. For example, using Sleep(90.0) will cause the program to wait 90 seconds, blocking the next expression until Sleep(90.0) is fully executed.

Structured concurrency expressions are used to specify async logical time flow, and to modify the blocking nature of async expressions with a lifespan that is logically constrained to a specific async context scope (such as an async function body).

This is similar to structured flow control such as block, if, for, and loop that constrain to their associated scope.

Verse async expressions do not use the yield and await primitives used by async implementations in other languages. The same mechanisms are accomplished by using Verse concurrency expressions and internal mechanisms.

For more on structured concurrency, see Sync, Race, Rush, and Branch.
Unstructured Concurrency

There is only one unstructured concurrency expression ‚Äî spawn. This expression has a lifespan that is not logically constrained to a specific async context scope, but that potentially can extend beyond the scope where it was executed.

Unstructured concurrency is like an emergency escape hatch ‚Äî you shouldn't use it on a regular basis although sometimes it is your best and only option.

Structured concurrency expressions (sync, race, rush and branch) should be used before unstructured concurrency (spawn) expressions whenever possible.

For more on unstructured concurrency, see Spawn.
Tasks for Tracking Currently Executing Async Expressions

An async expression has a task associated with it.

A task is an object that represents an async function that has started to execute, but has suspended to allow another task to complete.

The task can be used to check the status of an async expression and to cancel the async expression, if desired.

For more on tasks, see Task.

    verse
    language
    concurrency
  Sync

Run two or more async expressions concurrently using a sync expression.
UEFN
Sync

You can use the sync expression to run two or more async expressions at the same time. For example:

# All three async functions effectively start at the same time
Results = sync:
    AsyncFunction1()  # task 1
    AsyncFunction2()  # task 2
    AsyncFunction3()  # task 3
# Called after all three tasks complete (regardless of order)
MyLog.Print("Done with list of results: {Results}")

The following code shows the syntax for the sync expression with an accompanying diagram that shows the execution flow of the expressions.

expression0
sync:
    slow-expression
    mid-expression
    fast-expression
expression1

Diagram showing the execution flow of the sync expression
Sync Expression Use
Where you can use a sync expression 	Async contexts
Invocation time of the sync expression 	Async
Requirements for sync code block 	The body of the sync expression must have at least two expressions that are async; otherwise, you have no need to run the expressions simultaneously.
What the sync expression does 	Executes all expressions in its code block concurrently and waits for them all to finish before executing the next expression after the sync.
When the sync expression completes 	When all the expressions in the sync code block have completed.
When the next expression after sync starts 	When all the expressions in the sync code block have completed.
Result of the sync expression 	Its result is a tuple of results from each expression in the order that the top-level expressions were specified. The result types of the expressions can be of any type, and each tuple element will have the type of its corresponding expression.

At least two top-level expressions must be async.

sync:
    AsyncFunction1()
    MyLog.Print("Second top level expression")
    AsyncFunction2()
    MyLog.Print("Third top level expression")

sync:
    AsyncFunction1()
    # Error: expected at least two top-level expressions

Top-level expressions can be compound expressions, such as nested code blocks:

# sync may also have compound expressions
# with each top-level expression its own task
sync:
    block: # task 1
        # Evaluated in serial order
        AsyncFunction1a()
        AsyncFunction1b()
    block: # task 2
        AsyncFunction2a()
        AsyncFunction2b()
        AsyncFunction2c()
    AsyncFunction3() # task 3

# AsyncFunction1a(), AsyncFunction2a() and AsyncFunction3() all start essentially at the same time

Since tuples can be used as self-splatting arguments, sync expressions can be used directly as arguments since they have a tuple result. This allows async arguments to evaluate simultaneously, and the function they are being passed to is called when all the expressions in the sync code block are completed.

# All three coroutine arguments start their evaluation at the same time
DoStuff(sync{AsyncFunctionArg1(); AsyncFunctionArg2(); AsyncFunctionArg3()})

# Not every argument needs to be async - a minimum of two justifies the use of sync
DoOtherStuff(sync{AsyncFunctionArg1(); 42; AsyncFunctionArg2(); AsyncFunctionArg3()})

    verse
    language
    expressions
    concurrency
    sync
  Race

Use a race expression to run two or more async expressions concurrently and cancel whichever expressions don't finish first.
UEFN
Race

The race expression is used to run a block of two or more async expressions concurrently (simultaneously). When the fastest expression completes, it ‚Äúwins the race‚Äù. Any remaining ‚Äúlosing‚Äù expressions are canceled, then any expression that follows the race is evaluated.

set WinnerResult = race:
    # All three async functions start at the same time
    AsyncFunctionLongTime()
    AsyncFunctionShortTime()  # This will win and its result is used
    AsyncFunctionMediumTime()
# Next expression is called after the fastest async function completes
# / when the fastest/shortest async function task (AsyncFunctionShortTime()) completes
# and all other async function tasks (AsyncFunctionLongTime(), AsyncFunctionMediumTime()) are canceled.
NextExpression(WinnerResult)

The following code shows the syntax for the race expression.

expression0
race:
    slow-expression
    mid-expression
    fast-expression
expression1

The diagram below shows the execution flow of the expressions.

Visualization of the order the expressions in the race block finish Diagram showing the execution flow of the race expression
Race Expression Use
Where you can use a race expression 	Async contexts
Invocation time of the race expression 	Async
Requirements for race code block 	The body of the race expression must have at least two expressions, and all the expressions must be async.
What the race expression does 	Similar to sync, but cancels all but the ‚Äúwinning‚Äù subexpression. If any other expressions complete at the same simulation time as the earlier expression, the first (earlier) expression ‚Äúwins‚Äù and breaks any tie. Any ‚Äúlosing‚Äù expression tasks are canceled.
When the race expression completes 	The race is completed when the ‚Äúwinning‚Äù expression in the code block has completed. This refers to the fastest, shortest length, first completed, or least amount of time to complete.
When the next expression after race starts 	Any expression that follows the race expression is started once the first expression finishes.
Result of the race expression 	The result of a race is the result of the first completed expression. The result type is the most common compatible type of all expressions in the code block.

This might seem simple, but race is one of the most useful and powerful expressions in the Verse arsenal. It is key to stopping other arbitrarily complex async code in a structured fashion ‚Äî a form of early exit. It does this in a very clean way by keeping whatever tests are needed to determine when to stop separated from the code that is to be stopped.

    Any async expression can be canceled.
    Some async expressions, such as an endless loop or Sleep(Inf) will never complete. The only way they can be stopped is to cancel them. This can be a strong strategy when paired with one or more race expressions.
    Async expressions will not have a result if they are canceled, so any variable or other expression that depends on a canceled async expression would not be bound.

Need to stop some complex behavior after some amount of time or after some complex sequence of events trigger? Without race, you would normally need to sprinkle tests, such as polling all throughout your complex behavior. With race, you only need to add all stop conditions as sibling subexpressions to the complex behavior.

race:
    ComplexBehavior() # Could be simple or as complex as a whole game
    Sleep(60.0)       # Timeout after one minute
    EventTrigger()    # Some other arbitrary test that can be used to stop

A race result can be used to determine which subexpression finished first, or won the race.

# Adding a unique result to subexpressions so it can
# be used to determine which subexpression won
Winner := race:
    block:        # task 1
        AsyncFunction1()
        1
    block:        # task 2
        AsyncFunction2a()
        AsyncFunction2b()
        AsyncFunction2c()
        2
    loop:         # task 3
        # endless loop which could never win
        AsyncFunction3()
        3

MyLog.Print("The winning subexpression was: {Winner}")

    verse
    language
    expressions
    concurrency
    race
      Rush

Use a rush expression to run two or more async expressions without canceling the slower expressions.
UEFN
Rush

The rush expression is used to run a block of two or more async expressions concurrently (simultaneously).

When the fastest subexpression completes, any expression that follows the rush is evaluated, and any remaining subexpressions continue to evaluate.

set WinnerResult = rush:
    # All three async functions start at the same time
    AsyncFunctionLongTime()
    AsyncFunctionShortTime()  # This will win and its result is used
    AsyncFunctionMediumTime()
# Next expression is called after the fastest async function (AsyncFunctionShortTime()) completes.
# All other subexpression tasks (AsyncFunctionLongTime(), AsyncFunctionMediumTime()) continue.    
NextExpression(WinnerResult)
AsyncFunction4()
# If any rush subexpression tasks are still running when AsyncFunction4 completes
# then they are now canceled.

The following code shows the syntax for the rush expression.

expression0
rush:
    slow-expression
    mid-expression
    fast-expression
expression1

The diagram below shows the execution flow for the expressions.

Visualization of the order the expressions in the rush block finish Diagram showing the execution flow of the rush expression
Rush Expression Use
Where you can use a rush expression 	Async contexts
Invocation time of the rush expression 	Async
Requirements for rush code block 	The body of the rush expression must have at least two expressions, and all of the expressions must be async.
What the rush expression does 	Is similar to race, but expressions that complete after first completion continue. If any expressions effectively complete at the same simulation update, then the earlier encountered expression that completes breaks any tie. Any incomplete expressions continue to evaluate until they complete, or until the enclosing async context completes, at which point, any remaining losing expressions are canceled ‚Äî whichever occurs first.
When the rush expression completes 	The rush expression completes when the first expression in the code block has completed. This could be the fastest, shortest length, first completed, or least amount of time to complete.
When the next expression after rush starts 	Any next expression that follows the rush expression is started when the completed expression finishes.
Result of the rush expression 	The result of a rush expression is the result of the first completed expression. The result type is the most common compatible type of all expressions in the code block.

A rush expression cannot currently be used in the body of an iteration expression like loop or for. If it must be used, then wrap it in an async function and have the iteration expression call that function.

    verse
    language
    expressions
    concurrency
    rush
  Branch

Use a branch expression to start one or more async expressions, then immediately execute following expressions.
UEFN
Branch

A branch expression starts a block of one or more async subexpressions, and any expression that follows after is executed immediately, without waiting for the branch expressions to complete.

You can use branch essentially to treat any async block of code as though it were fire-and-forget immediate, but it still must be called within an async context.

branch:
    # This block continues until completed
    AsyncFunction1()    # Starts effectively the same time as AsyncFunction3()
    Method1()  # Block can be mixed with immediate expressions
    AsyncFunction2()
AsyncFunction3()  # Starts effectively the same time as AsyncFunction1()
# If branch block task is still running when AsyncFunction3 completes
# then any remaining branch task is canceled

The following code shows the syntax for the branch expression.

expression0
branch:
    slow-expression
    mid-expression
    fast-expression
expression1

The diagram below shows the execution flow of the expressions.
Diagram showing the execution flow of the branch expression

It is similar to the unstructured concurrency spawn expression, but branch allows for any arbitrary block of code, and is only permissible within, and bounded by, an enclosing async context. Because of this, branch is preferred over spawn whenever possible.
Branch Expression Use
Where you can use a branch expression 	Async contexts
Invocation time of the branch expression 	Immediate
Requirements for branch code block 	The branch expression must have at least one async expression.
What the branch expression does 	The body of the branch expression is started as soon as it is encountered. The body of the branch expression continues to evaluate until the code block completes or the enclosing async context completes ‚Äî whichever occurs first ‚Äî at which point the branch code block task is canceled.
When the branch expression completes 	The branch expression completes immediately.
When the next expression after branch starts 	Any expression that follows the branch expression is started immediately.
Result of the branch expression 	A branch expression has no result, so its result type is void.

A branch expression may not currently be used in the body of an iteration expression such as loop or for. If it must be used then wrap it in an async function and have the iteration expression call that function.
Spawn

Use a spawn expression to start one async expression in any context, then immediately execute the following expressions.
UEFN
Spawn

The spawn expression starts one async function invocation, and any expression that follows the spawn is executed immediately while the started async function task continues independently until it completes.

# Continues until completed without blocking
spawn{AsyncFunction1()}  # Started at same time as expression0
expression0         # Started at same time as AsyncFunction1()

The following code shows the syntax for the spawn expression.

expression0
spawn{ expression1 }
expression2

The diagram below shows the execution flow of the expressions.
Diagram showing the execution flow of the spawn expression

While similar to branch, the spawn body is limited to a single async function call. It is also allowed outside of an async context, so it can be called within both non-async and async functions.

A spawn expression should be treated like an emergency escape hatch, while branch should be used in place of spawn whenever possible.
Spawn Expression Use
Where you can use a spawn expression 	Any context.
Invocation time of the spawn expression 	Immediate.
Requirements for spawn code block 	The body of the spawn expression is started as soon as it is encountered. It must have at least one async expression.
What the spawn expression does 	The body of a spawn creates an async context like the body of an async function. However, only a single async function call is allowed within the spawn body. The async function of the spawn is started as soon as it is encountered, and evaluates as much as possible until it encounters something suspending or blocking. The spawned async function continues to evaluate until it completes without any further connection to the location where it was spawned.
When the spawn expression completes 	The spawn expression completes immediately.
When the next expression after spawn starts 	Any next expression that follows the spawn expression is started immediately.
Result of the spawn expression 	A spawn has a task result.

    verse
    language
    expressions
    concurrency
    spawn
  Task

A task is an object that represents the state of a currently-executing async function.
UEFN
Task

A task is an object used to represent the state of a currently-executing async function. Task objects are used to identify where an async function is suspended, and the values of local variables at that suspend point.

Tasks execute concurrently in a cooperatively multitasked environment.

A task can be durational, based on a lifespan of one or more updates before it completes.

Tasks can be sequential, overlapped, staggered, and so on, in any logical order.

The sequence and overlapping flow of tasks is specified through the use of structured or unstructured concurrency expressions.

Each task can be concurrently arranged sequentially, overlapped, staggered, and so on, in any logical order of time. Internally, a task could have a caller (or even several callers), and zero or more dependent sub-tasks that form a call graph (as opposed to a call stack).

A task is similar to a thread, but has the advantage over threads in that context switching between tasks does not involve any system calls, expensive context-state saving, or processor-blocking calls, and a processor can be 100% utilized). You don‚Äôt need synchronization such as mutexes or semaphores to guard critical sections, and there is no need for support from the operating system.

The task(t:type) class allows direct programmatic querying and manipulation of tasks in an unstructured manner, though it is generally recommended that tasks be manipulated through structured concurrency expressions for greater clarity, power and efficiency.

Currently, the only exposed function for task is Await(), which waits until the current task has completed. This essentially anchors a task and adds a caller for it to return to at the call point.

spawn{AsyncFunction3()}

# Get task to query / give commands to
# starts and continues independently
Task2 := spawn{Player.MoveTo(Target1)}

Sleep(1.5) # Wait 1.5 Seconds
MyLog.Print("1.5 Seconds into Move_to()")

Task2.Await() # wait until MoveTo() completed
Wait(0.5)     # Wait 0.5 Seconds
# Explicit start and wait until completed
# Task1 could still be running
Target1.MoveTo(Target2)

Similar to the example above, the one below uses structured concurrency expressions:

sync:
    AsyncFunction3()  # Task 1
    block:
        Player.MoveTo(Target1)  # Task 2
        Sleep(0.5)  # Wait 0.5 Seconds
        Target1.MoveTo(Target2)
    block:  # Task 3
        Sleep(1.5)  # Wait 1.5 Seconds
        MyLog.Print("1.5 Seconds into Move_to()")

    verse
    language
    concurrency
    task

Option

The option type can contain one value or can be empty.
UEFN
Option

The option type can contain one value or can be empty.

In the following example, MaybeANumber is an optional integer ?int that contains no value. A new value for MaybeANumber is then set to 42.

var MaybeANumber : ?int = false # unset optional value
set MaybeANumber := option{42} # assigned the value 42

Creating an option variable in Verse

MaybeANumber : ?int = option{42} # initialized as 42

MaybeAnotherNumber : ?int = false # unset optional value

	

Creating an option: You can initialize an option with one of the following:

    No value: Assign false to the option to mark it as unset.
    Initial value: Use the keyword option followed by {}, and an expression between the {}. If the expression fails, the option will be unset and have the value false.

Specify the type by adding ? before the type of value expected to be stored in the option. For example ?int.

if (Number := MaybeANumber?):
    Number # if MaybeANumber is not empty, then its value is stored in Number for you to use.

	Accessing an element in an option: Use the query operator ? with the option, such as MaybeANumber?. Accessing the value stored in an option is a failable expression because there might not be a value in the option, and so must be used in a failure context.

The following is an example of using an option type to save a reference to a spawned player and, when a player is spawned, to have the trigger device react:

my_device := class<concrete>(creative_device):
    var SavedPlayer : ?player = false # unset optional value
 
    @editable
    PlayerSpawn : player_spawner_device = player_spawner_device{}
 
    @editable
    Trigger : trigger_device = trigger_device{}
 
    OnBegin<override>() : void =
        PlayerSpawn.PlayerSpawnedEvent.Subscribe(OnPlayerSpawned)
 
    OnPlayerSpawned(Player : player) : void =
        set SavedPlayer = option{Player}
        if (TriggerPlayer := SavedPlayer?): 
            Trigger.Trigger(TriggerPlayer)

Range

The range expression contains all the numbers in a specified range, and can only be used in specific expressions.
UEFN
Range

The range type represents a series of integers, for example 0..3, and Min..Max.

The start of the range is the first value in the expression, for example 0, and the end of the range is the value following .. in the expression, for example 3. The range contains all the integers between, and including, the start and end values. For example, the range expression 0..3 contains the numbers 0, 1, 2, and 3.
Range diagram

Range expressions only support int values, and can only be used in for, sync, race, and rush expressions.

For example:

for (Index := 0..5):
    Print("{Index}")

    verse
    range
    integers

Array

An array is a container where you can store elements of the same type, and access the elements by their position in the array.
UEFN
Array

When you have variables of the same type, you can collect them into an array. An array is a container type where you specify the type of the elements with []type, such as []float. An array is useful because it scales to however many elements you store in it without changing your code for accessing the elements.

For example, if you have multiple players in your game, you can create an array and initialize it with all the players.

Players : []player = array{Player1, Player2}

An array containing 2 players

Verse has the pattern where definition mirrors use. Defining an array and using it follows that pattern.
Array Length

You can get the number of elements in an array by accessing the member Length on the array. For example, array{10, 20, 30}.Length returns 3.
Accessing Elements in an Array

Elements in an array are ordered in the same position in the array as you inserted them, and you can access the element at that position, called its index, in the array. For example, to get the first player, you‚Äôd access the Players array with Players[0].

The first element in an array has an index of 0 and each subsequent element‚Äôs index increases in number. For example, array{10, 20, 30}[0] is 10 and array{10, 20, 30}[1] is 20.
Index 	0 	1 	2
Element 	10 	20 	30

The last index in an array is one less than the length of the array. For example, array{10, 20, 30}.Length is 3 and the index for 30 in array{10, 20, 30} is 2.

Accessing an element in an array is a failable expression and can only be used in a failure context, such as an if expression. For example:

ExampleArray : []int = array{10, 20, 30, 40, 50}
for (Index := 0..ExampleArray.Length - 1):
    if (Element := ExampleArray[Index]):
        Print("{Element} in ExampleArray at index {Index}")

This code will print:

    10 in ExampleArray at index 0
    20 in ExampleArray at index 1
    30 in ExampleArray at index 2
    40 in ExampleArray at index 3
    50 in ExampleArray at index 4

Changing an Array and its Elements

Arrays, like all other values in Verse, are immutable. If you define an array variable, that allows you to assign a new array to the variable, or mutate individual elements.

For example:

# Array1 is an array of integers
Array1 : []int = array{10, 11, 12}

# Array2 is an array variable of integers
var Array2 : []int = array{20, 21, 22}

# we concatenate Array1, Array2, and a new array of integers
# and assign that to the Array2 variable
set Array2 = Array1 + Array2 + array{30, 31}

# we assign the integer 77 to index 1 of Array2
if (set Array2[1] = 77) {}

for (Index := 0..Array2.Length - 1):
    if (Element := Array2[Index]):
        Print("{Element} at index {Index}")

This code will print:

    10 at index 0
    77 at index 1
    12 at index 2
    20 at index 3
    21 at index 4
    22 at index 5
    30 at index 6
    31 at index 7

Multi-Dimensional Arrays

The arrays in the previous examples were all one-dimensional, but you can also create multi-dimensional arrays. Multi-dimensional arrays have another array, or arrays, stored at each index, similar to columns and rows in a table.

For example, the following code produces a two-dimensional (2D) array, visualized in the following table:

var Counter : int = 0
Example : [][]int =
    for (Row := 0..3):
        for(Column := 0..2):
            set Counter += 1

  	Column 0 	Column 1 	Column 2
Row 0 	1 	2 	3
Row 1 	4 	5 	6
Row 2 	7 	8 	9
Row 3 	10 	11 	12

To access elements in a 2D array, you must use two indices. For example, Example[0][0] is 1, Example[0][1] is 2, and Example[1][0] is 4.

The following code shows how to use a for expression to iterate through the Example 2D array.

if (NumberOfColumns : int = Example[0].Length):
    for(Row := 0..Example.Length-1, Column := 0..NumberOfColumns):
         if (Element := Example[Row][Column]):
             Print("{Element} at index [{Row}][{Column}]")

This code will print:

    1 at index [0][0]
    2 at index [0][1]
    3 at index [0][2]
    4 at index [1][0]
    5 at index [1][1]
    6 at index [1][2]
    7 at index [2][0]
    8 at index [2][1]
    9 at index [2][2]
    10 at index [3][0]
    11 at index [3][1]
    12 at index [3][2]

The number of columns in each row is not required to be constant.

For example, the following code produces a two-dimensional (2D) array, visualized in the following table, where the number of columns in each row is greater than the previous row:

Example : [][]int =
    for (Row := 0..3):
        for(Column := 0..Row):
            Row * Column

  	Column 0 	Column 1 	Column 2 	Column 3
Row 0 	0 	  	  	 
Row 1 	0 	1 	  	 
Row 2 	0 	2 	4 	 
Row 3 	0 	3 	6 	9

    verse
    arrays
          Map

A map is a container where you can store values associated with other values, called key-value pairs, and access the elements by their unique keys.
UEFN
Map

A map is a container type that holds key-value pairs, which are mappings from one value to another value. Elements in a map are ordered based on the order of key-value pairs when you create the map, and you access elements in the map using the unique keys you define.

For example, if you want to keep a count of how many times you encounter a word, you can create a map using the word as the key and its count as the value.

WordCount : [string]int = map{"apple" => 11, "pear" => 7}

Click image to enlarge.

If you use the same key multiple times when initializing a map, the map will only keep the last value provided for that key. In the following example, WordCount will only have the "apple" => 2 key-value pair. The "apple" => 0 and "apple" => 1 pairs are discarded.

WordCount : [string]int = map{"apple" => 0, "apple" => 1, "apple" => 2}

Supported Key Types

Key-value pairs can be of any type as long as the key type is comparable, because there needs to be a way to check if a key already exists for a map.

The following types can be used as keys:

    logic
    int
    float
    char
    string
    enum
    A class, if it‚Äôs comparable
    An option, if the element type is comparable
    An array, if the element type is comparable
    A map if both the key and the value types are comparable
    A tuple if all elements in the tuple are comparable

Map Length

You can get the number of key-value pairs in a map by accessing the field Length on the map. For example, map{"a" => "apple", "b" => "bear", "c" => "candy"}.Length returns 3.
Accessing Elements in a Map

You can access an element in a map by using a key, for example WordCount["apple"].

Accessing an element in a map is a failable expression and can only be used in a failure context, such as an if expression. For example:

ExampleMap : [string]string = map{"a" => "apple", "b" => "bear", "c" => "candy"}
for (Key->Value : ExampleMap):
    Print("{Value} in ExampleMap at key {Key}")

Key 	"a" 	"b" 	"c"
Value 	"apple" 	"bear" 	"candy"
Adding and Modifying Elements in a Map

You can add elements to a map variable by setting the key in a map to a specific value. For example set ExampleMap["d"] = 4. Existing key-value pairs can be updated by similarly assigning a value to a key that already exists in the map. Adding an element to a map is a failable expression and can only be used in a failure context, such as an if expression. For example:

var ExampleMap : [string]int = map{"a" => 1, "b" => 2, "c" => 3}
# Modifying an existing element
if (set ExampleMap["b"] = 3, ValueOfB := ExampleMap["b"]):
    Print("Updated key b in ExampleMap to {ValueOfB}")
# Adding a new element
if (set ExampleMap["d"] = 4, ValueOfD := ExampleMap["d"]):
    Print("Added a new key-value pair to ExampleMap with value {ValueOfD}")

Removing Elements from a Map

Elements can be removed from a map variable by creating a new map that excludes the key you want to remove. An example of a function that provides removal from [string]int maps is provided below.

# Removes an element from the given map and returns a new map without that element
RemoveKeyFromMap(ExampleMap:[string]int, ElementToRemove:string):[string]int=
    var NewMap:[string]int = map{}
    # Concatenate Keys from ExampleMap into NewMap, excluding ElementToRemove
    for (Key -> Value : ExampleMap, Key <> ElementToRemove):
        set NewMap = ConcatenateMaps(NewMap, map{Key => Value})
    return NewMap

Weak Map

The type weak_map is a supertype of the map type. You would use a weak_map in a similar way to how you‚Äôd use the map type in most cases, but with the following exceptions:

    You cannot query how many elements a weak_map contains because weak_map does not have a Length member.
    You cannot iterate through the elements of a weak_map.
    You cannot use ConcatenateMaps() on a weak_map.

Another difference is that the type definition for a weak_map requires you to define the key-value pair types using the weak_map function, such as MyWeakMap:weak_map(string, int) = map{}, which defines a weak map named MyWeakMap that will have a string key paired with an integer value. Since weak_map is a supertype of map, you can initialize it with a standard map{}.

The following shows an example of creating a weak_map variable, and accessing an element in the weak map:

ExampleFunction():void=
    var MyWeakMap:weak_map(int, int) = map{} # Supertype of the standard map, so it can be assigned from the standard map
    if: 
        set MyWeakMap[0] = 1 # Same means of mutation of a particular element as the standard map
    then:
        if (Value := MyWeakMap[0]):
            Print("Value of map at key 0 is {Value}")
    set MyWeakMap = map{0 => 2} # Same means of mutation of the entire map as the standard map

    verse
    map

Tuple

A tuple is a container where you can group two or more expressions of mixed types and access the elements in the tuple by their position.
UEFN
Tuple

A tuple is a grouping of two or more expressions that is treated as a single expression.

A tuple literal has multiple expressions between (), with the elements separated by commas:

(1, 2, 3)

The order of the elements in a tuple is important. The following tuple is different than the previous tuple example:

(3, 2, 1)

The same expression can also be in multiple positions in a tuple:

("Help me Rhonda", "Help", "Help me Rhonda")

Tuple expressions can be of any type, and can contain mixed types (unlike arrays which can only have elements of one type):

(1, 2.0, "three")

Tuples can even contain other tuples:

(1, (10, 20.0, "thirty"), "three")

If you are familiar with these terms, a tuple is like:

    An unnamed data structure with unnamed ordered elements
    A fixed-size array where each element can be a different type

Tuples are especially useful for:

    Returning multiple values from a function.
    A simple in-place grouping that is more concise than the overhead of making a fully-described, reusable data structure (such as a struct or class).

Specifying a Variable with a Tuple Type

To specify the type of variable as a tuple, the tuple prefix is used before comma-separated types enclosed in ():

MyTupleInts : tuple(int, int, int) = (1, 2, 3)
MyTupleMixed : tuple(int, float, string) = (1, 2.0, "three")
MyTupleNested : tuple(int, tuple(int, float, string), string) = (1, (10, 20.0, "thirty"), "three")

Tuple types can also be inferred:

MyTupleInts   := (1, 2, 3)
MyTupleMixed  := (1, 2.0, "three")
MyTupleNested := (1, (10, 20.0, "thirty"), "three")

Tuple type specifiers can be used in data members and function type signatures for parameters or a return type:

ExampleFunction(Param1 : tuple(string, int), Param2 : tuple(int, string)) : tuple(string, int) =
    # Using parameter as result
    Param1

Tuple Element Access

The elements of a tuple can be accessed with a non-failing, zero-based index operator that takes an integer. The index operator cannot fail (unlike an array index operator [index] which can fail) because the compiler always knows the number of elements of any tuples and so any out-of-bounds index will be a compile-time error:

MyTuple := (1, 2.0, "three")

MyNestedTuple := (1, (10, 20.0, "thirty"), "three")

var MyInt: int = MyTuple(0)
var MyFloat: float = MyTuple(1)
var MyString: string = MyTuple(2)

Print("My variables: {MyInt}, {MyFloat}, {MyString}")

Print("My nested tuple element: {MyNestedTuple(1)(2)}")

Tuple Array Coercion

Tuples can be passed wherever an array is expected, provided that the type of the tuple elements are all of the same type as the array. Arrays cannot be passed where a tuple is expected.
Tuple Expansion

A tuple passed as a single element to a function will be as though that function were called with each of that tuple's elements separately. This is called tuple expansion or splatting.

F(Arg1 : int, Arg2 : string) : void =
    DoStuff(Arg1, Arg2)

G() : void =
    MyTuple := (1, "two")
    F(MyTuple(0), MyTuple(1))  # Accessing elements
    F(MyTuple)                 # Tuple expansion

The sync structured concurrency expression has a tuple result that allows several arguments that evaluate over time to be evaluated simultaneously. For more information, see Concurrency.
Class

A class is a template for creating objects with similar behaviors and properties (fields and methods).
UEFN
Class

In Verse, a class is a template for creating objects with similar behaviors and properties. It is a composite type, which means that it‚Äôs bundled data of other types and functions that can operate on that data.

For example, let‚Äôs say you want to have multiple cats in your game. A cat has a name and an age, and they can meow. Your cat class could look like this:

cat := class:
    Name : string
    var Age : int = 0
    Sound : string

    Meow() : void = DisplayMessage(Sound)

Definitions of variables that are nested inside the class define fields of the class. Functions defined inside a class may also be called methods. Functions and methods are referred to as class members. In the above example, Sound is a field, and Meow is a method of cat.

Fields of a class may or may not have a default value, or may only define a type that limits the values that the field may have. In the above example, Name does not have a default value, while Age does. The value may be specified using an expression that has the effects. The default value expression may not use the identifier Self, which you'll learn about below.

For instance, lets say you want your cats to be able to tilt their heads. You can initialize an initial rotation HeadTilt in the following code using the IdentityRotation() method because it has the <converges> specifier and is guaranteed to complete with no side effects.

cat := class:
    ...
    # A valid expression
    HeadTilt:rotation = IdentityRotation()

Constructing a Class

With a class that defines what a cat is and what the cat can do, you can construct an instance of the class from an archetype. An archetype defines the values of the class fields. For example, let‚Äôs make an old cat named Percy from the cat class:

OldCat := cat{Name := ‚ÄùPercy‚Äù, Age := 20, Sound:= ‚ÄùRrrr‚Äù}

In this example, the archetype is the part between { and }. It doesn't need to define values for all fields of the class, but must at least define values for all fields that don't have a default value. If any field is omitted, then the instance constructed will have the default value for that field.

In this case, the cat class Age field has a default value assigned to it of (0). Since the field has a default value, you‚Äôre not required to provide a value for it when constructing an instance of the class. The field is a variable, which means that though you might provide a value at construction time, the value of that variable can be changed after construction.

By contrast, the Name field of cat is not a mutable variable, and so is immutable by default. This means that you can provide a default value for it at construction time, but after construction, it cannot change: it is immutable.

Since a class in Verse is a template, you can make as many instances as you want from the cat class. Let‚Äôs make a kitten named Flash:

Kitten := cat{Name := ‚ÄùFlash‚Äù, Age := 1, Sound := ‚ÄùMew‚Äù}

Accessing Fields

Now that you have some instances of cat, you can access each cat‚Äôs Name field with OldCat.Name or Kitten.Name, and call each cat's Meow method with OldCat.Meow() or Kitten.Meow().

Both cats have the same named fields, but those fields have different values. For example, OldCat.Meow() and Kitten.Meow() behave differently because their Sound fields have different values.
Self

Self is a special identifier in Verse that can be used in a class method to refer to the instance of the class that the method was called on. You can refer to other fields of the instance the method was called on without using Self, but if you want to refer to the instance as a whole, you must use Self.

For example, if DisplayMessage required an argument for which pet to associate a message with:

DisplayMessage(Pet:pet, Message:string) : void = ‚Ä¶
cat := class:
    ‚Ä¶
    Meow() : void = DisplayMessage(Self, Sound)

If you wanted to initialize a louder version of your cats meow, you might think you could build off Sound variable you already set up. This will not work in the following code however, because LoudSound cannot reference the instance member Sound, since default value expressions cant use the identifier Self.

cat := class:
    ...
    Sound : string
    Meow() : void = DisplayMessage(Self, Sound)
    # The following will fail since default class values
    # can't reference Self
    LoudSound : string = "Loud " + Self.Sound 
    LoudMeow() : void = DisplayMessage(Self, LoudSound)

Subclasses and Inheritance

Classes can inherit from a superclass, which includes all fields of the superclass in the inheriting class. Such classes are said to be a subclass of the superclass. For example:

pet := class:
    Name : string
    var Age : int = 0

cat := class(pet):
    Sound : string
    Meow() : void = DisplayMessage(Self, Sound)

dog := class(pet):
    Trick : string
    DoTrick() : void = DisplayMessage(Self, Trick)

Here, the use of class(pet) when defining cat and dog declares that they inherit from the pet class. In other words, they are subclasses of pet.

This has several advantages:

    Since both cats and dogs have names and ages, those fields only have to be defined once, in the pet class. Both the cat and the dog field will inherit those fields.
    The pet class can be used as a type to refer to instance of any subclass of pet. For example, if you want to write a function that just needs the name of a pet, you can write the function once for both cats and dogs, and any other pet subclasses you might introduce in the future:

    IncreaseAge(Pet : pet) : void=
     set Pet.Age += 1

For more information, see the Subclass page.
Overrides

When you define a subclass, you can override fields defined in the superclass to make their type more specific, or change their default value. To do so, you must write the definition of the field in your subclass again, but with the <override> specifier on its name. For example, you can add a Lives field to pet with a default value of 1, and override the default value for cats to be 9:

pet := class:
    ‚Ä¶
    Lives : int = 1

cat := class(pet):
    ‚Ä¶
    Lives<override> : int = 9

Method Calls

When you access a field of a class instance, you access that instance's value for the field. For methods, the field is a function, and overriding it replaces the field's value with a new function. Calling a method calls the value of the field. This means that the method called is determined by the instance. Consider the follow example:

pet := class:
    ‚Ä¶
    OnHearName() : void = {}

cat := class(pet):
    ‚Ä¶
    OnHearName<override>() : void = Meow()

dog := class(pet):
    ‚Ä¶
    OnHearName<override>() : void = DoTrick()

CallFor(Pet:pet):void=
    DisplayMessage("Yoo hoo {Pet.Name}!")
    Pet.OnHearName()

If you write CallFor(Percy), it will call the OnHearName method as defined by cat. If you write CallFor(Fido) where Fido is an instance of the dog class, then it will call the OnHearName method as defined by dog.
Visibility Specifiers

You can add visibility specifiers to class fields and methods to control who has access to them. For example, you can add the private specifier to the Sound field so only the owning class can access that private field.

cat := class:
    ‚Ä¶
    Sound<private> : string

MrSnuffles := cat{Sound := "Purr"}
MrSnuffles.Sound # Error: cannot access a private field

The following are all the visibility specifiers you can use with classes:

    public: Unrestricted access.
    internal: Access limited to current module. This is the default visibility.
    protected: Access limited to current class and any subclasses.
    private: Access limited to current class.

Access Specifiers

You can add access specifiers to a class to control who can construct them. This is useful, for example, if you want to make sure an instance of a class can only be constructed at a certain scope.

pets := module:
    cat<public> := class<internal>:
        Sound<public> : string = "Meow"

GetCatSound(InCat:pets.cat):string =
    return InCat.Sound # Valid: References the cat class but does not call its constructor

MakeCat():void =
    MyNewCat := pets.cat{} # Error: Invalid access of internal class constructor

Calling the constructor for the cat class outside of its module pets wil fail because the class keyword is marked as internal. This is true even though the class identifier itself is marked as public, which means cat can be referenced by code outside the pets module.

The following are all the access specifiers you can use with the class keyword:

    public: Unrestricted access. This is the default access.
    internal: Access limited to the current module.

Concrete Specifier

When a class has the concrete specifier, it is possible to construct it with an empty archetype, such as cat{}. This means that every field of the class must have a default value. Furthermore, every subclass of a concrete class must itself be concrete.

For example:

class1 := class<concrete>:
    Property : int = 0

# Error: Property isn't initialized
class2 := class<concrete>:
    Property : int

# Error: class3 must also have the <concrete> specifier since it inherits from class1
class3 := class(class1):
    Property : int = 0

A concrete class can only inherit directly from an abstract class if both classes are defined in the same module. However, it does not hold transitively ‚Äî a concrete class can inherit directly from a second concrete class in another module where that second concrete class inherits directly from an abstract class in its module.
Unique Specifier

The unique specifier can be applied to a class to make it a unique class. To construct an instance of a unique class, Verse allocates a unique identity for the resulting instance. This allows instances of unique classes to be compared for equality by comparing their identities. Classes without the unique specifier don't have any such identity, and so can only be compared for equality based on the values of their fields.

This means that unique classes can be compared with the = and <> operators, and are subtypes of the comparable type.

For example:

unique_class := class<unique>:
    Field : int

Main()<decides> : void =
    X := unique_class{Field := 1}
    X = X # X is equal to itself
    Y := unique_class{Field := 1}
    X <> Y # X and Y are unique and therefore not equal

Final Specifier

You can only use the final specifier on classes and fields of classes.

When a class has the final specifier, you cannot create a subclass of the class. In the following example, you cannot use the pet class as a superclass, because the class has the final specifier.

pet := class<final>():
    ‚Ä¶

cat := class(pet): # Error: cannot subclass a ‚Äúfinal‚Äù class
    ‚Ä¶

When a field has the final specifier, you cannot override the field in a subclass. In the following example, the cat class can‚Äôt override the Owner field, because the field has the final specifier.

pet := class():
    Owner<final> : string = ‚ÄúAndy‚Äù

cat := class(pet):
    Owner<override> : string = ‚ÄúSid‚Äù # Error: cannot override ‚Äúfinal‚Äù field

When a method has the final specifier, you cannot override the method in a subclass. In the following example, the cat class can‚Äôt override the GetName() method, because the method has the final specifier.

pet := class():
    Name : string

    GetName<final>() : string = Name

cat := class(pet):
    ‚Ä¶
    GetName<override>() : string =  # Error: cannot override ‚Äúfinal‚Äù method
        ‚Ä¶

Block Expressions in a Class Body

You can use block expressions in a class body. When you create an instance of the class, the block expressions are executed in the order they are defined. Functions called in block expressions in the class body cannot have the NoRollback effect.

As an example, let‚Äôs add two block expressions to the cat class body and add the transacts effect specifier to the Meow() method because the default effect for methods has the NoRollback effect.

cat := class():
    Name : string
    Age : int
    Sound : string

    Meow()<transacts> : void =
        DisplayOnScreen(Sound)

    block:
	    Self.Meow()

    block:
        Log(Self.Name)

OldCat := cat{Name := "Garfield", Age := 20, Sound := "Rrrr"}

When the instance of the cat class, OldCat, is created, the two block expressions are executed: the cat will first say ‚ÄúRrrr‚Äù; then ‚ÄúGarfield‚Äù will print to the output log.
Interfaces
  Enum

An enum is a type used to store named sets of things.
UEFN
Enum

Enum is short for enumeration, which means to name or list a series of things, called enumerators. This is a type in Verse that can be used for things like days of the week or compass directions.

Click image to enlarge.

direction := enum{Up, Down, Left, Right}

	Creating an enum: Use the keyword enum followed by {}. If you want to specify initial elements in the enum, add the enumerators between the {}, separated by ,.

direction.Up

	Accessing an enumerator: Use . on the enum, followed by the enumerator you want to use. For example direction.Up.

    verse
    enum

Interfaces are a limited form of classes that can only contain methods that don't have a value. Classes can only inherit from a single other class, but can inherit from any number of interfaces.

    verse
    class

      Struct

A struct is a way to group several related variables together.
UEFN
Struct

Struct is short for structure, and is a way to group several related variables together. Any variables can be grouped, including variables of different types.

[Creating a new struct in Verse

Click image to enlarge.

coordinates := struct:
    X : float = 0.0
    Y : float = 0.0

	Creating a struct: Use the keyword struct followed by a code block. Definitions in the struct‚Äôs code block define the fields of the struct.

Position := coordinates{X := 1.0, Y := 1.0}

	Instantiating a struct: You can construct an instance of a struct from an archetype. An archetype defines the values of a struct‚Äôs fields.

Position.X

	Accessing fields on a struct: You can access a struct‚Äôs fields to get their value by adding . between the struct instance and the field name.

    verse
    structs

Subclass

A subclass is a class that extends the definition of another class by adding or modifying the fields and methods of the other class.
UEFN
Subclass

In Verse, you can create a class that extends the definition of another class by adding or modifying the fields and methods of the other class. This is often called subclassing or inheritance, because one class inherits definitions from the other class.

Let‚Äôs look at the Class Designer device as an example of subclassing. With the Class Designer device, you can create character classes for player characters that let you define the attributes and inventories specific to a character class, such as a tank or DPS (damage per second) character.
DPS character class created with the Class Designer device 	Tank character class created with the Class Designer device

In Verse, you could create a tank class and a dps class like this:

tank := class():
    StartingShields : int
    MaxShields : int
    AllowOvershield : logic
    DamageReduction : int

dps := class():
    StartingShields : int
    MaxShields : int
    AllowOvershield : logic
    MovementMultiplier : float

Because some of the fields in the two classes are the same, you can reduce duplication with a superclass that holds the shared properties and behaviors of the classes. Let‚Äôs call this superclass player_character, and make tank and dps subclasses of player_character:

player_character := class():
    StartingShields : int
    MaxShields : int
    AllowOvershield : logic

dps := class(player_character):
    MovementMultiplier : float

tank := class(player_character):
    DamageReduction : int

Since the tank and dps classes are subclasses of player_character, they automatically inherit the fields and methods of the player_character class, so you only need to specify what‚Äôs different in this class from the superclass.

For example, the dps class only adds the Movement Multiplier field, and the tank class only adds the DamageReduction field. This setup is useful if you change the shared behaviors of the two classes later because you‚Äôll only need to change it in the superclass.
Diagram showing inheritance relationship between the superclass player_character and the subclasses dps and tank

With Verse, you can add more changes to differentiate the tank and dps classes by adding methods to the subclasses.

A useful effect of subclassing is that you can use the relationship between a superclass and its subclasses. Because of inheritance, an instance of tank is a specialized player_character, and an instance of dps is a specialized player_character, which is referred to as an is-a relationship. Since tank and dps are both subclasses of the same superclass and diverge from their shared superclass, tank does not have a relationship with dps.
Override Specifier

To create instances of classes with initial values, a common practice is to have a function that generates the instances. For example:

CreateDPSPlayerCharacter() : dps =
    return dps{StartingShields := 0, MaxShields := 0, AllowOvershield := false, MovementMultiplier := 1.9}

CreateTankPlayerCharacter() : tank =
    return tank{StartingShields := 100, MaxShields := 200, AllowOvershield := true, DamageReduction := 50}

The CreateTankPlayerCharacter() and CreateDPSPlayerCharacter() functions create the instances with the appropriate initial values. Alternatively, you can override the fields from the superclass and assign initial values, so you don‚Äôt need to provide so many initial values when creating an instance.

For example, the tank class from the previous section could look like this with overrides on the fields:

tank := class(player_character):
    StartingShields<override> : int = 100
    MaxShields<override> : int = 200
    AllowOvershield<override> : logic = true
    DamageReduction : int = 50

CreateTankPlayerCharacter() : tank =
    return tank{}

Diagram showing overrides in the inheritance relationship between the superclass player_character and the subclasses dps and tank

You can also override methods in the subclass, which means you can use the overriding method everywhere the overriden method can be used. This means:

    The method must accept at least any argument accepted by the overriden method, so the parameter type must be a supertype of the overriden function's parameter type.
    The method must not return a value that the overriden method couldn't have, so the return type must be a subtype of the overriden method's return type.
    The method must not have more effects than the overriden method, so the effect specifier must be a subtype of the overriden method's effect specifier.

Super

Similar to Self, you can use (super:) to access the superclass implementations of fields and methods. To be able to use (super:), the field or method must be implemented in the superclass definition.

pet := class():
    Sound : string

    Speak() : void =
        Log(Sound)

cat := class(pet):
    Sound<override> : string = "Meow"

    Speak<override>() : void =
        (super:)Speak() # "Meow" appears in the Output Log
        Log("Purr") # "Purr" appears in the Output Log

Block Expressions in a Subclass Body

Any block expressions that are in a subclass body will be executed after the block expressions specified in the superclass body. For example, in the following code, when the instance of the cat class named MrSnuffles is created, Speak() is executed first, then Purr().

pet := class():
    Speak() : void =
    ...

    block:
        Speak()

cat := class(pet):
    Purr() : void =
    ...

    block:
        Purr()

MrSnuffles := cat{}

Abstract Specifier

When a class or a class method has the abstract specifier, you cannot create an instance of the class. Abstract classes are intended to be used as a superclass with partial implementation, or as a common interface. This is useful for when it doesn‚Äôt make sense to have instances of a superclass but you don‚Äôt want to duplicate properties and behaviors across similar classes.

In the following example, because pet is an abstract concept, an instance of the pet class isn‚Äôt specific enough, but a pet cat or pet dog does make sense, so those subclasses aren‚Äôt marked as abstract.

pet := class<abstract>():
    Speak() : void

cat := class(pet):
    Speak() : void = 
    ...

dog := class(pet):
    Speak() : void =
    ...

    verse
    class
    subclass
      Interface

An interface provides a contract for how to interact with any class that implements the interface.
UEFN
Interface

The interface type provides a contract for how to interact with any class that implements the interface. An interface cannot be instantiated, but a class can inherit from the interface and implement its methods. An interface is similar to an abstract class, except that it does not allow partial implementation or fields as part of the definition.

For example, let‚Äôs create an interface for anything that you can ride on, such as a bicycle or a horse:

rideable := interface():
    Mount()<decides> : void
    Dismount()<decides> : void

Any classes that inherit the interface must implement the interface‚Äôs functions and add the override specifier:

bicycle := class(rideable):
    ...
    Mount<override>()<decides> : void =
        ...
    Dismount<override>()<decides> : void =
        ...

horse := class(rideable):
    ...
    Mount<override>()<decides> : void =
        ...
    Dismount<override>()<decides> : void =
        ...

An interface can extend another interface. For example, you can specify that anything that you can ride should also be able to move.

moveable := interface():
    MoveForward() : void

rideable := interface(moveable):
    Mount()<decides> : void
    Dismount()<decides> : void

A class can inherit from an interface and another class. For example, you can define a horse, and differentiate it from one that has a saddle you can ride on:

horse := class(moveable):
    ...
    MoveForward()<decides> : void =
        ...

saddle_horse := class(horse, rideable):
    ...
    Mount<override>()<decides> : void =
        ...
    Dismount<override>()<decides> : void =
        ...

A class can inherit from multiple interfaces.

lockable := interface():
    Lock() : void =
        ...
    Unlock() : void =
        ...

bicycle := class(rideable, lockable):
    ‚Ä¶
    Mount<override>()<decides> : void =
        ...
    Dismount<override>()<decides> : void =
        ...
    Lock<override>() : void =
        ...
    Unlock<override>() : void =
        ...
    MoveForward<override>() : void =
        ...

    verse
    expressions
    class
      Constructor

A constructor is a special function that creates an instance of the class that it's associated with.
UEFN
Constructor

A constructor is a special function that creates an instance of the class that it‚Äôs associated with. It can be used to set initial values for the new object.

class1 := class:
    Property1 : int
 
MakeClass1<constructor>(Arg1:int) := class1:
    Property1 := Arg
 
Main():void =
    X := MakeClass1(1)
    F := MakeClass1()
    Z := F(2)

	Defining a constructor for a class: You can add a constructor for a class by adding the <constructor> specifier on the function name. Instead of specifying a return type on the function, the function is assigned the class name followed by any initialization of fields. A class can have more than one constructor.

MakeOtherClass1<constructor>(Arg1 : int) := class1:
    let:
        OnePlusArg1 := Arg1 + 1

    block:
        DoSomething(OnePlusArg1)

    Property1 := OnePlusArg1

    block:
        DoOtherStuff()

	Adding variables and executing code in the constructor: You can execute expressions within a constructor with the block expression, and introduce new variables with the keyword let.

MakeClass1Plus1<constructor>(Arg1 : int) := class1:
    MakeClass1<constructor>(Arg1 + 1) # Note use of <constructor> on invocation

# The base type constructor can be invoked in any order with respect to properties,
# but the properties "win"
MakeOtherClass2<constructor>(Arg1 : int, Arg2 : int) := class2:
    Property2 := Arg2
    MakeClass1<constructor>(Arg1)
    # Note that effects are still ordered as they appear in the code

	Calling other constructors in a constructor: You can call other constructors from a constructor. You can also call constructors for the superclass of the class from a constructor of the class as long as all fields are initialized. When a constructor calls another constructor and both constructors initialize fields, only the values provided to the first constructor are used for the fields. The order of evaluation for expressions between the two constructors will be in the order the expressions are written (as far as side effects are concerned), but only the values provided to the first constructor are used.

    verse
    constructor
      Type Casting and Conversion

Use type casting to convert from one data type to another.
UEFN
Type Casting and Conversion

When working with data, it is often necessary to convert variables from one data type to another. For example, displaying the result of a calculation requires converting from a float to a string.

All type conversion within Verse is explicit, which means that you must use a function like ToString() or use an operator like multiply (*) to convert an object to a different data type. Explicit conversion of one type to another is also called type casting.
Converting Float to Int

Converting from a float to an int requires a function that explicitly specifies how it will convert from a floating point number to an integer. The following functions all handle the conversion, but they all work differently. It's up to you to decide which one works best in a given situation.

    Round[]
    Floor[]
    Ceil[]
    Int[]

In this example, different functions convert four float literal values into int values. Next, set assigns the values to variables of type int. The if expression creates the failure context for these failable functions.

var WoodCollected:int = 0
var StoneCollected:int = 0
var GoldCollected:int = 0
var FoodCollected:int = 0

if:
    # WoodCollected is now 2
    set WoodCollected = Round[1.5]

    # StoneCollected is now 1
    set StoneCollected = Floor[1.9]

    # GoldCollected is now 2
    set GoldCollected = Ceil[1.2]

    # FoodCollected is now 1
    set FoodCollected = Int[1.56]

Print("WoodCollected: {WoodCollected}")
Print("StoneCollected: {StoneCollected}")
Print("GoldCollected: {GoldCollected}")
Print("FoodCollected: {FoodCollected}")

Converting Int to Float

The way to convert from an int to a float data type is to multiply the integer by 1.0. The multiply operator (*) converts the integer to a floating point number before performing the multiplication.

This code converts the int variable StartingPositionX into a float through multiplication so it can be used in the declaration of a vector3 variable. The data type vector3 requires float type values for its X, Y, and Z fields.

var StartingPositionX:int = 960

# CurrentX = 960.0
var CurrentX:float = StartingPositionX * 1.0
var CurrentPosition:vector3 = vector3{X := CurrentX, Y := 0.0, Z := 0.0}
Print("CurrentX: {CurrentX}")

Converting to a String

You can convert multiple data types to a string using either a ToString() function or string interpolation, which calls a ToString() function. Currently, the following types have built-in ToString() functions in Verse.

    float
    int
    []char
    char
    vector2
    vector3
    rotation

In this example, you can see variables being converted to a string through string interpolation and ToString() functions. Both methods have the same result because string interpolation calls ToString().

var WoodCollected:int = 100
# Convert using string interpolation
Print("WoodCollected: { WoodCollected }")
# or ToString() function
Print("WoodCollected: " + ToString(WoodCollected))

var InitialDistance:float = 3.625
# Convert using string interpolation
Print("InitialDistance: { InitialDistance }")
# or ToString() function
Print("InitialDistance: " + ToString(InitialDistance))

var CurrentPosition : vector3 = vector3{X:= 960.0, Y:= 540.0, Z := 20.0}
# Convert using string interpolation
Print("CurrentPosition: { CurrentPosition }")
# or ToString() function
Print("CurrentPosition: " + ToString(CurrentPosition))

Converting a Custom Data Type to a String

Custom data types can also be converted to strings by implementing a ToString(custom_type) function for the data type. If a ToString(custom_type) function exists, string interpolation will use it to automatically convert data types to strings.

Here is an example of a custom ToString() function for an enum of fruits.

fruit := enum:
    Apple 
    Banana 
    Strawberry

ToString(Fruit: fruit):string =
    case(Fruit):
        fruit.Apple => "Apple"
        fruit.Banana => "Banana"
        fruit.Strawberry => "Strawberry"

PickUpFruit():void =
    # Examples of using string interpolation to convert data to strings
    var FruitItem:fruit = fruit.Banana

    # Picked up: Banana
    Print("Picked up: {FruitItem}")
    
    set FruitItem = fruit.Apple
    # Picked Up: Apple
    Print("Picked up: {FruitItem}")

Here is an example of a custom ToString() function for a custom class. Notice that the ToString() function is declared outside of the waypoint class. In the SetDestination() function, the string interpolation of Destination is calling the custom ToString() function.

# Custom class with constructor and a ToString() function
waypoint := class():
    DisplayName:string
    Position:vector3 = vector3{}

MakeWaypoint<constructor>(Name:string, X:float, Y:float, Z:float) := waypoint:
    DisplayName := Name
    Position := vector3{X := X, Y := Y, Z := Z}

ToString(Waypoint: waypoint):string =
    return "{Waypoint.DisplayName} at {Waypoint.Position}"

SetDestination():void =
    Destination:waypoint = MakeWaypoint("River", 919.0, 452.0, 545.0)
    # River at {x=919.0, y=452.0, z=545.0}
    Print("Destination: {Destination}")

Converting an Object Reference to a Different Type

You can explicitly convert references to objects (or type cast) to different classes or interfaces using the following syntax:

if (NewObjectReference := object_type_to_cast_to[ObjectReference]) {}

The object_type_to_cast_to represents the class or interface that you are attempting to convert the reference to. This is a failable expression because the type conversion will fail if the object can't be converted to the specified type. Attempting to convert an object reference to a class will fail if the class does not match the object's type, the type of a superclass, or an interface that the object's class implements.

This code declares an interface positionable, an abstract class shape that inherits from positionable, and two subclasses of shape: triangle and square. It then creates an object of type square called MyShape and attempts to type cast it to three other types. Here is a breakdown of the results.
square Type Cast To 	Result
square 	succeeds because MyShape is a square
triangle 	fails because triangle is not a superclass of square, and triangle is not an interface that square implements
positionable 	succeeds because square is a subclass of shape, and all subclasses of shape must implement positionable.

# Class and interface definitions
positionable := interface() {}
shape := class<abstract>(positionable) {}
triangle := class(shape) {}
square := class(shape) {}

# Create a square object referenced using the superclass type shape
MyShape:shape = square{}

# This will succeed since MySquare is a square object
if(MySquare := square[MyShape]):
    Print("Successfully cast shape to square")

if(MyTriangle := triangle[MyShape]):
    Print("This will never print.")
else:
    Print("Failed to cast MyShape to triangle. This is expected behavior.")

# This will succeed since the positionable interface must be implemented by subclasses of shape
if(MyDrawable := positionable[MyShape]):
    Print("Successfully cast shape to positionable")

In the last example, type casting will work but is not necessary. This code will have the same result:

MyDrawable:positionable = MyShape

Examples Using Type Conversion

One use case for object type casting in UEFN is finding actors of a certain type and calling functions based on the type. To find out how to do this, see Finding Actors with a Gameplay Tag in Gameplay Tags.

    verse
    int
    float
    string
    type cast
  Type Aliasing

You can use a type alias to give a type a unique name without creating a new type.
UEFN
Type Aliasing

Verse supports giving a type another name that can be used to refer to the same underlying type. This is known as a type alias. The syntax is similar to constant initialization as it is basically the same thing, but using types instead of values.

For example, to give an alias to float the following syntax could be used:

number := float

You can use this to shorten some type signatures. For example, instead of the code below,

RotateInts(X : tuple(int, int, int)) : tuple(int, int, int) =
    ( X(3), X(1), X(2))

an alias could be introduced for tuple, like this:

int_triple := tuple(int, int, int)
RotateInts(X : int_triple) : int_triple =
    (X(3), X(1), X(2))

This is particularly useful in combination with function types. For example,

int_predicate := type{_(:int)<transacts><decides> : void}
Filter(X : []int, F : int_predicate) : []int =
    for (Y : X, F[Y]):
        Y

Note that Verse does not currently support parametric type aliases.

For example,

predicate(t : type) := type{_(:t)<transacts><decides> : void}

is not supported.
Parametric Types

Use parametric types as explicit type arguments to classes or functions, or as implicit type arguments to functions.
UEFN
Parametric Types

Parametric types refer to any type that can take a parameter. You can use parametric types in Verse to define generalized data structures and operations. There are two ways to use parametric types as arguments: either in functions as explicit or implicit type arguments, or in classes as explicit type arguments.

Events are a common example of parametric types and are used extensively throughout devices in UEFN. For instance, the Button device has the InteractedWithEvent, which occurs whenever a player interacts with the button. To see a parametric type in action, check out the CountdownEndedEvent from the Custom Countdown Timer Tutorial.
Explicit Type Arguments

Consider a box that takes two arguments. The first_item initializes an ItemOne, and the second_item initializes an ItemTwo, both of type type. Both first_item and second_item are examples of parametric types that are explicit arguments to a class.

box(first_item:type, second_item:type) := class:
    ItemOne:first_item
    ItemTwo:second_item

Because type is the type argument for first_item and second_item, the box class can be created with any two types. You could have a box of two string values, a box of two int values, a string and an int, or even a box of two boxes!

For another example, consider the MakeOption() function, which takes any type and returns an option of that type.

MakeOption(t:type):?t = false

IntOption := MakeOption(int)
FloatOption := MakeOption(float)
StringOption := MakeOption(string)

You could modify the MakeOption() function to instead return any other container type, such as an array or a map.
Implicit Type Arguments

Implicit type arguments for functions are introduced using the where keyword. For example, given a function ReturnItem(), which simply takes a parameter and returns it:

ReturnItem(Item:t where t:type):t = Item

Here, t is an implicit type parameter of the function ReturnItem(), which takes an argument of type type and immediately returns it. The type of t restricts what type of Item we can pass to this function. In this case since t is of type type, we can call ReturnItem() with any type. The reason to use implicit parametric types with functions is that it allows you to write code that works regardless of the type passed to it.

For example, instead of having to write:

ReturnInt(Item:int):int = Item

ReturnFloat(Item:float):float = Item

The single function could be written instead.

ReturnItem(Item:t where t:type):t = Item

This comes with the guarantee that ReturnItem() doesn't need to know what particular type the t is ‚Äî whatever operation it performs, it will work regardless of the type of t.

The actual type to be used for t depends on how ReturnItem() is used. For example, if ReturnItem() is called with argument 0.0, then t is a float.

ReturnItem("t") # t is a string
ReturnItem(0.0) # t is a float

Here "hello" and 0.0 are the explicit arguments (the Item) passed to ReturnItem(). Both of these will work because the implicit type of Item is t, which can be any type.

For another example of a parametric type as an implicit argument to a function, consider the following MakeBox() function which operates on the box class.

box(first_item:type, second_item:type) := class:
    ItemOne:first_item
    ItemTwo:second_item

MakeBox(ItemOneVal:ValOne, SecondItemVal:ValTwo where ValOne:type, ValTwo:type):box(ValOne, ValTwo) =
    box(ValOne, ValTwo){ItemOne := ItemOneVal, ItemTwo := SecondItemVal}

Main():void =
    MakeBox("A", "B")
    MakeBox(1, "B")
    MakeBox("A", 2) 
    MakeBox(1, 2)

Here the MakeBox() function takes two arguments, FirstItemVal and SecondItemVal, both of type type, and returns a box of type (type, type). Using type here means we‚Äôre telling MakeBox that the returned box could be made up of any two objects; it could be an array, a string, a function, etc. The MakeBox() function passes both arguments to Box, uses them to create a box, and returns it. Note that both box and MakeBox() use the same syntax as a function call.

A built-in example of this is the function for the Map container type, given below.

Map(F(:t) : u, X : []t) : []u =
    for (Y : X):
        F(Y)

Type Constraints

You can specify a constraint on the type of an expression. The only currently supported constraint is subtype, and only for implicit type parameters. For example:

int_box := class:
    Item:int

MakeSubclassOfIntBox(NewBox:subtype_box where subtype_box:(subtype(int_box))) : tuple(subtype_box, int) = (NewBox, NewBox.Item)

In this example, MakeSubclassOfIntBox() will only compile when passed a class that subclasses from IntBox, since SubtypeBox has the type (subtype(IntBox)). Note that type can be seen as shorthand for subtype(any). In other words, this function accepts any subtype of any, which is every type.
Covariance and Contravariance

Covariance and Contravariance refer to the relationship of two types when the types are used in composite types or functions. Two types that are related in some way, such as when one subclasses from the other, are either covariant or contravariant to each other depending on how they are used in a particular piece of code.

Covariant: Using a more specific type when the code expects something more generic.

Contravariant: Using a more general type when the code expects something more specific.

For instance, if we we could use an int in a situation where any comparable would be accepted (such as a float), our int would be acting covariantly, since we‚Äôre using a more specific type when a more generic one is expected. On the reverse, if we could use any comparable when normally an int would be used, our comparable would be acting contravariantly, since we‚Äôre using a more generic type when a more specific one is expected.

An example of covariance and contravariance in a parametric type might look like the following:

MyFunction(Input:t where t:type):logic = true

Here t is used contravariantly as the input to the function, and logic is used covariantly as the output to the function.

It is important to keep in mind that the two types are not inherently covariant or contravariant to each other, rather whether they‚Äôre acting as covariant or contravariant depends on how they‚Äôre used in the code.
Covariant

Covariance means to use something more specific when you expect something generic. Usually this is for output from a function. All type uses that aren‚Äôt inputs to functions are covariant uses. A generic parametric type example below has payload acting covariantly.

DoSomething():int =
    payload:int = 0

For instance, suppose we have a class animal, and a class cat that subclasses animal. We also have a class pet_sanctuary that adopts out pets with the function AdoptPet(). Since we don‚Äôt know what kind of pet we‚Äôre going to get, AdoptPet() returns a generic animal.

animal := class:
cat := class(animal):
pet_sanctuary := class:
    AdoptPet():animal = animal{}

Suppose we have another pet sanctuary that only deals with cats. This class, cat_sanctuary, is a subclass of pet_sanctuary. Since this is a cat sanctuary, we override AdoptPet() to only return a cat instead of an animal.

cat_sanctuary := class(pet_sanctuary):
    AdoptPet<override>():cat = cat{}

In this case, the return type cat of AdoptPet() is covariant to animal. We‚Äôre using a more specific type when the original used a more general one.

This can also apply to composite types. Given an array of cat, we can initialize an array of animal using the cat array. The opposite does not work since animal cannot be converted to its subclass cat. The array of cat is covariant to the array of animal, because we‚Äôre treating a narrower type as a more generic type.

CatArray:[]cat = array{}
AnimalArray:[]animal = CatArray

Inputs to functions cannot be used covariantly. The following code will fail because the assignment of AnimalExample(), to CatExample(), is of type cat, which is too specific to be the return type of AnimalExample(). Reversing this order by assigning CatExample() to AnimalExample would work due to cat subtyping from animal.

CatExample:type{CatFunction(MyCat:cat):void} = ‚Ä¶
AnimalExample:type{AnimalFunction(MyAnimal:animal):void} = CatExample

An additional example follows where the variable t is only used covariantly.

# The line below will fail because t is used only covariantly.
MyFunction(:logic where t:type):?t = false

Contravariant

Contravariance is the opposite of covariant, and means to use something more generic when you expect something specific. This is usually input to a function. A generic parametric type example below has payload acting contravariantly.

DoSomething(Payload:payload where payload:type):void

Say our pet sanctuary has a specific procedure for handling new cats. We add a new method to pet_sanctuary called RegisterCat().

pet_sanctuary := class:
    AdoptPet():animal = animal{}
    RegisterCat(NewAnimal:cat):void = {}

For our cat_sanctuary, we‚Äôre going to override this method to accept an animal as a type parameter because we already know that every cat is an animal.

cat_sanctuary := class(pet_sanctuary):
    AdoptPet<override>():cat = cat{}
    RegisterCat<override>(NewAnimal:animal):void = {}

Here animal is contravariant to cat, since we‚Äôre using something more generic when something more specific would work.

Using an implicit type introduced by a where clause covariantly produces an error. For example, payload here is used contravariantly, but errors out due to not being defined as an argument.

DoSomething(:logic where payload:type) : ?payload = false

To fix this, this could be rewritten to exclude a type parameter:

DoSomething(:logic) : ?false = false

Contravariant-only uses do not result in an error, but can be rewritten using any instead of false. For example:

ReturnFirst(First:first_item, :second_item where first_item:type, second_item:type) : first_item = First

Since second_item was of type type and was not returned, we can replace it with any in the second example and avoid doing type checking on it.

ReturnFirst(First:first_item, :any where first_item:type) : first_item = First

Replacing the type first_item with either any or false loses precision. For example, the following code will fail to compile:

ReturnFirst(First:any, :any) :any = First

Main() : void =
    FirstInt:int = ReturnFirst(1, "ignored")

Known Limitations
Explicit type parameters for data types may only be used with classes, and not interfaces or structs. Inheritance related to parametric types is also disallowed. 	

OriginalBox(item:type) := class:
    Item:type = item
# InheritingBox cannot inherit from OriginalBox
# because Parametric types cannot inherit
InheritingBox(item : type) := class(OriginalBox):
    Item:type = item

Parametric types can reference themselves recursively as long as the recursion is direct. Parametric types cannot recursively reference other parametric types. 	

# Will compile
box_with_a_box(FirstItem : type) := class:
    ItemOne : FirstItem
    SecondThing : box_with_a_box(FirstItem)

# Will not compile
box_with_a_box(FirstItem : type) := class:
    ItemOne : FirstItem
    SecondThing : ListOfBoxes(FirstItem)

ListOfBoxes(FirstItem:type) := box_with_a_box(FirstItem)

Currently, classes only support immutable parametric type data. For example, this code would not compile because ItemOne is a variable. 	

box(first_item:type, second_item:type) := class:
    var ItemOne:first_item
    ItemTwo:second_item

Explicit type parameters can be freely combined with a class, just as implicit type parameters can be combined with a function. 	

OptionBox(FirstItem : type) := class:
    Item:?FirstItem

Flatten(Box1:?OptionBox(item) where item:type)<decides><transacts>:?item =
    Box1?.Item

Main() : void =
    Box1 := OptionBox(int){Item := option{1}}
    if(Flatten[option{Box1}] = Box1.Item):
        Print("Retrieved the item from Box1")

    verse
    effects

Type Macro

The type macro allows you to get the type of an expression. It can be used anywhere a type can be used.
UEFN
Type Macro

Verse has a special construct that can be used to get the type of an arbitrary expression (similar to decltype in modern C++): type. It can be used anywhere a type can be used. For example,

Foo() : int = 0
Bar(X : type{Foo()}) : type{Foo()} = X

It is particularly useful to describe the types of functions, and it is required to give the result type of a function as another function with non-default effects. For example,

comparison := enum:
    LT
    EQ
    GT

Less(X : int, Y : int)<decides> : int =
    X < Y

Equal(X : t, Y:comparable where t:subtype(comparable))<decides> : t =
    X = Y

Greater(X : int, Y : int)<decides> : int =
    X > Y

Comparison(Arg : comparison) : type{_(:int, :int)<decides> : int} =
    case (Arg):
        comparison.LT => Less
        comparison.EQ => Equal
        comparison.GT => Greater

Here, the comparison expression converts a comparison enumeration to the comparison operation each particular enumeration value corresponds to. This example also makes use of the special _ identifier, which can be used in type in places where an identifier is expected without having to actually provide a name that is otherwise unused.

    verse
    types
    macro
      Modules and Paths

A Verse module is an atomic unit of code that can be redistributed and depended upon, and that you can import into your Verse file to use code definitions from other Verse files.
UEFN
Modules and Paths

A Verse module is an atomic unit of code that can be redistributed and depended upon, and can evolve over time without breaking dependencies. You can import a module into your Verse file to use code definitions from other Verse files.

A Verse module is specified by the folder in the file hierarchy of the project, and the module's name is the name of the folder. All .verse files in the same folder as the file are part of that Verse module, and can access definitions from the other Verse files in the module without explicitly importing the module.

A module is identified by its path; for example, /Verse.org/Verse. Verse paths provide a global namespace for identifying things, and borrow from the idea of web domains. These paths are persistent and unique, and discoverable by any Verse programmer.

For a list of existing Verse modules, see the Verse API Reference.
Module Members

You can create modules within a .verse file using the following syntax:

module1 := module:
    ...

# Similar to classes and function, bracket syntax is also supported
module2 := module
{
    ...
}

A module defined in the Verse file can contain anything that is contained at the top level of a .verse file. This includes functions, constants, various types, as well as other module definitions. For example:

module := module:
    submodule<public> := module:
        submodule_class<public> := class {}
    module_class<public> := class{}

The contents of a submodule can be referred to using the name of the module qualified with the name of the base module. For example, class1 can be referred to outside of module1 as module1.module2.class1.
Importing Definitions from Other Verse Files

To use the contents of a Verse module, you must import the module by its path. For example, the following code imports the Random module, identified by the path /Verse.org/Random:

using { /Verse.org/Random }

When the Random module is imported into your Verse file, you can use its code definitions, such as the function GetRandomInt().

Other common module examples include the Devices, Simulation, and Diagnostics modules, all of which are imported by default when you create a new Verse file through UEFN.

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }

To import modules from other Verse files, you can use either a local path such as using { /YourVerseFolder/your_module }, or if the file is in the same directory, just using { your_module }.

You can import nested modules either by importing base modules before submodule modules, or by using dotted notation. For instance, given the modules:

base_module<public> := module:
    submodule<public> := module:
        submodule_class := class:
            ...

If you want to access members in submodule, you can either import it by importing base_module before submodule, or by importing base_module.submodule. Note that importing submodule before base_module will produce an error.

# Works and imports both base and submodules
using { base_module }
using { submodule }

# Works and imports only the submodule
using { base_module.submodule }

# Does not work
using { submodule }
using { base_module }

When you create a subfolder in a Verse project, a module is automatically created for that folder. For example, if base_module was defined in a folder module_folder, then module_folder would have its own module that contains base_module.

Another way to view this is that the file structure module_folder/base_module is the same as the following:

module_folder := module:
    base_module := module:
        submodule := module:
            submodule_class := class:
                ...

Note that the module for module_folder would need to be imported before base_module.

# Imports the folder containing base_module and its submodule
using { module_folder }
using { base_module }
using { submodule }

Access of Definitions in a Module

The access of a module and its contents from other Verse files are set using access specifiers, such as public and internal.

By default, the access for definitions are internal, which means they're only discoverable within their own module. This is also true for modules introduced by folders in a project.

Because the default access specifier is internal, you can't access module members outside of the module without making them public. For instance:

# This module and its members are not accesible from other Verse Files.
private_module := module:
    SecretInt:int = 1
    ...

# But this module, its submodule, and its members are.
public_module<public> := module:
    public_submodule<public> := module:
        PublicInt<public>:int = 1
        ...

Note both the module and its members need to be public to access them in a different scope.

    verse
    module
    path
