Use this document as a quick reference for all the features of the Verse programming language and its syntax. Follow the links to learn more.

Expressions
An expression is the smallest unit of code that produces a value when evaluated. An example is an if ... else expression, which in Verse evaluates to a value that depends on the content of the expression blocks.

The following code evaluates to a string value that contains either "Big!" or "Small!", depending on whether MyNumber was greater than 5:

if (MyNumber > 5):
    "Big!"
else:
    "Small!"
Code Comments
A code comment explains something about the code, or the programmer's reason for why something is programmed the way it is. When the program runs, code comments are ignored.

1+2 # Hello
single-line comment: Anything that appears between # and the end of line is part of the code comment.
1<# inline comment #>+2
inline block comment: Anything that appears between <# and #> is part of the code comment. Inline block comments can be between expressions on a single line and don‚Äôt change the expressions.
DoThis()
<# And they
can run multiple
long lines #>
DoThat()
multi-line block comment: Anything that appears between <# and #> is part of the code comment. Multi-line block comments can span multiple lines.
<# Block comments nest <# like this #> #>
nested block comment: Anything that appears between <# and #> is part of the code comment, and they can nest. This can be useful if you want to comment out some expressions in a line for testing and debugging without changing an existing code comment.
<#>
    Here is a long
    description spanning
    multiple lines.
DoThis() # This expression is not part of the indented comment
indented comment: Anything that appears on new lines after <#> and is indented four spaces over is part of the code comment. The first line that isn‚Äôt indented four spaces over is not part of the code comment and ends the code comment.
Constants and Variables
Constants and variables can store information, or values, that your program uses, and associate these values with a name. The name is the identifier.

To create your own variable or constant, you need to tell Verse about it. This is called a declaration. Specifying an initial value, called initialization, is optional for variables (though recommended), but required for constants.

You can change the value of a variable at any time. This is formally called assignment, because you are assigning a value to the variable, but is also sometimes called setting the variable.

name : type = value
Creating a constant: A constant‚Äôs value cannot be changed while the program is running. You create a constant by specifying its name, type, and value.	

Click image to enlarge.

var name : type = value
Creating a variable: A variable‚Äôs value can be changed while the program is running. You create a variable by adding the keyword var before the name, and you must specify its name, type, and (optionally) its initial value.	

Click image to enlarge.

set name = value
Changing a variable‚Äôs value: You can change a variable‚Äôs value while the program is running by using the keyword set =.	

Click image to enlarge.

Types
Verse is a statically-typed programming language, which means a type is assigned to every identifier.

There are instances where the type is not explicitly required, such as when creating a constant in a function. In the example MyConstant := 0, the type for MyConstant is inferred because the value 0 is assigned to it.

Common Types
Verse has built-in types that support the fundamental operations most programs need to perform. You can create your own types by combining these into larger structures, but these common types are important to understand as the foundation for using variables and constants in Verse.

TargetLocked : logic = false
logic: A logic in Verse is the type for Boolean values, which means logic can only be two possible values: true and false. To learn more about the logic type, see Logic.
AnswerToTheQuestion : int = 42
int: An int in Verse can contain a positive number, a negative number, or zero, and has no fractional component. Integer values can be between the following values, inclusive:

Min: -9,223,372,036,854,775,808
Max: 9,223,372,036,854,775,807 To learn more about the int type, see Int.
MyScore : float = 100.0
float: A float in Verse can contain a positive or negative number that has a decimal point, zero, or the value NaN (Not a Number). Floating-point values can be between the following values, inclusive:

Min: -2^1023 * (1 + (1 - 2^(-52)))
Max: -2^1023 * (1 + (1 - 2^(-52))) To learn more about the float type, see Float.
# The winning player's name:
WinningPlayerName : string = "Player One"

# Build a message announcing the winner.
Announcement : string = "...And the winner is: {WinningPlayerName}!"
string: A string in Verse can contain letters, numbers, punctuation, spaces, and emojis üêà. A string containing no characters "" is called an empty string.

You can inject the result of an expression into a string using {} within the "". This is called string interpolation.

To learn more about the string type, see String.

# The winning player's name:
PlayerName<localizes> : message = "Player One"

# Build a message announcing the winner.
Announcement<localizes>(WinningPlayerName : string) : message = "...And the winner is: {WinningPlayerName}"

Billboard.SetText(Announcement("Player One"))
message: A message in Verse can contain locale-independent text. When you initialize a message variable with a string value, that string is the default text and language for the message. Constructing a message with the localizes specifier produces a message that is equal to itself and unequal to all other messages, regardless if the default text is the same between two messages.

You can turn the text into a displayable string at runtime by using the Localize() function, which formats the text according to your current locale.

Currently, the only text that can be returned by the Localize() function is the default text you provided when creating the message.

Localize(Announcement("Player One"))
locale: This type represents in what context a message value should be localized. This affects the language of text and how numbers are represented, that are common to the locale.

Currently, the locale type is not fully implemented, so the Localize() function will only return the default text you provided when creating the message.

if (MaxQuiversYouCanBuy : int = Floor(Coins / CoinsPerQuiver)):
    MaxArrowsYouCanBuy : int = MaxQuiversYouCanBuy * ArrowsPerQuiver
rational: The rational type is the result of integer division, and can only be used as an argument to the following functions:

Floor(): Rounds the rational value down to the closest integer.
Ceil(): Rounds the rational value up to the closest integer. To learn more about the rational type, see Rational.
var MyScore : int = 100

IncreaseScore() : void =
    Points : int = 10

    set MyScore = MyScore + Points

    Print("After you scored, MyScore is {MyScore}.")
void: The void type is useful in the following scenarios:

As a return type of a function, indicating that the result of the function is not useful.
As the type for constants or function parameters, indicating that the value is not useful. For example, use void for constants or function parameters when overriding a function definition.
To learn more about the void type, see Void.

FunctionTakingAnything(Argument : any):void = {}

Main() : void =
    FunctionTakingAnything(1)
    FunctionTakingAnything("2")
    FunctionTakingAnything(array{3.0})
    FunctionTakingAnything(FunctionTakingAnything)
any: The any type is the supertype of all types. To learn more about the any type, see Any.
Filter(Array : []t, Element : comparable where t : subtype(comparable)) : []t =
    for (OtherElement : Array; OtherElement = Element):
        OtherElement
comparable: The comparable type has the requirement that any value of this type can be compared for equality to any other value of this type. The comparable type is the supertype of all types that can be compared for equality. To learn more about the comparable type, see Comparable.
To learn more about common types in Verse, see Common Types.

Container Types
You can store multiple values together by using a container type. Verse has a number of container types to store values in. To learn more about container types in Verse, see Container Types.

Option
The option type can contain one value or can be empty.

In the following example, MaybeANumber is an optional integer ?int that contains no value. A new value for MaybeANumber is then set to 42.

var MaybeANumber : ?int = false # unset optional value
set MaybeANumber := option{42} # assigned the value 42

Click image to enlarge.

MaybeANumber : ?int = option{42} # initialized as 42

MaybeAnotherNumber : ?int = false # unset optional value
Creating an option: You can initialize an option with one of the following:

No value: Assign false to the option to mark it as unset.
Initial value: Use the keyword option followed by {}, and an expression between the {}. If the expression fails, the option will be unset and have the value false.
Specify the type by adding ? before the type of value expected to be stored in the option. For example ?int.

if (Number := MaybeANumber?):
    Number # if MaybeANumber is not empty, then its value is stored in Number for you to use.
Accessing an element in an option: Use the query operator ? with the option, such as MaybeANumber?. Accessing the value stored in an option is a failable expression because there might not be a value in the option, and so must be used in a failure context.
The following is an example of using an option type to save a reference to a spawned player and, when a player is spawned, to have the trigger device react:

my_device := class<concrete>(creative_device):
    var SavedPlayer : ?player = false # unset optional value
 
    @editable
    PlayerSpawn : player_spawner_device = player_spawner_device{}
 
    @editable
    Trigger : trigger_device = trigger_device{}
 
    OnBegin<override>() : void =
        PlayerSpawn.PlayerSpawnedEvent.Subscribe(OnPlayerSpawned)
 
    OnPlayerSpawned(Player : player) : void =
        set SavedPlayer = option{Player}
        if (TriggerPlayer := SavedPlayer?): 
            Trigger.Trigger(TriggerPlayer)
Range
The range expression contains all the numbers in a specified range, and can only be used in specific expressions, such as the for expression. Range values can only be integers.


Click image to enlarge.

0..5
Creating a range: The start of the range is the first value in the expression, and the end of the range is the value following .. in the expression. The range contains all the integers between the start and end values, inclusive.
for (Number := 0..5):
   Number
Iterating over a range: You can use the for expression to iterate through the sequence of numbers. For more, see for.
For more info, see Range.

Array
An array is a container where you can store elements of the same type, and access the elements by their position, called their index, in the array. The first index in the array is 0, and the last index is one less than the number of elements in the array.

Players : []player = array{Player1, Player2}

Click image to enlarge.

ExampleArray : []int = array{10, 20, 30, 40, 50}
Creating an array: Use the keyword array followed by {}. If you want to specify initial elements in the array, add the expressions between the {}, separated by ,. Specify the type by adding [] before the type of value expected to be stored in the array, for example []int.
if (Element := ExampleArray[0]):
    Element
Accessing an element in an array: Use [] with the index of the element you want to access, such as ExampleArray[0]. Accessing the value stored in an array is a failable expression because there might not be an element at that index, and so it must be used in a failure context.
var ExampleArray : []int = array{20, 21, 22}
if (set ExampleArray[1] = 77) {}
Changing an element in an array: You can change the value stored in an array variable at an index by using the keyword set =.
for (Item : ExampleArray):
   Item

for (Index -> Item : ExampleArray):
    Print("{Item} in ExampleArray at index {Index}")
Iterating over an array: You can access every element in an array, in order, from first to last, using the for expression. With the for expression, you can get the element with the syntax (Item : ExampleArray), or the element and its index with the syntax (Index -> Item : ExampleArray).
ExampleArray.Length
Getting the number of elements in an array: Use .Length on the array, and its result will be the number of elements in the array.
# Array1 is an array of integers
Array1 : []int = array{10, 11, 12}

# Array2 is an array variable of integers
var Array2 : []int = array{20, 21, 22}

# After Array2 is updated in the next line, its elements are [10, 11, 12, 20, 21, 22, 5, 31]
set Array2 = Array1 + Array2 + array{5, 31}
Concatenating arrays: You can merge arrays together by using the + operator.
For more info, see Array.

Tuple
A tuple is a grouping of two or more expressions treated as a single expression. The order of the elements in the expression is important. The same expression can be in multiple locations in a tuple. Tuple expressions can be of any type, and can have mixed types (unlike arrays which can only have elements of one type).

Tuples are especially useful when:

Returning multiple values from a function.
Passing multiple values to a function.
In-place grouping is more concise than the overhead of making a reusable data structure (such as a struct or class).
ExampleTuple : tuple(int, float, string) = (1, 2.0, "three")

Click image to enlarge.

ExampleTuple : tuple(int, float, string) = (1, 2.0, "three")
Creating a tuple: Use () and specify two or more elements, separated by ,. Specify the type by using the keyword tuple followed by (), with each element‚Äôs type explicitly specified between the (). For example, tuple(int, float, string).
ExampleTuple(0)
Accessing an element in a tuple: Use () with the index of the element you want to access, such as ExampleTuple(0). Accessing the value stored in a tuple is not a failable expression.
ExampleFunction(ExampleParameter1 : int, ExampleParameter2 : string) : void =
    DoStuff(ExampleParameter1, ExampleParameter2)

ExampleTuple := (1, "two")
ExampleFunction(ExampleTuple) # Tuple expansion
Tuple expansion: When you use a tuple as an argument to a function instead of specifying each individual argument, the function will be called with each element in the tuple used as an argument in the order they‚Äôre specified in the tuple.
ExampleFunction(ArrayParameter:[]int):void = {}

ExampleTuple:tuple(int, int, int) = (1, 2, 3)
ExampleFunction(ExampleTuple)
Tuple array coercion: Tuples can be passed wherever an array is expected, provided that the types of the tuple elements are all of the same type as the array. Arrays cannot be passed where a tuple is expected.
For more info, see Tuple.

Map
A map is a container where you can store values associated with another value, called key-value pairs, and access the elements by their unique keys.

WordCount : [string]int = map {"apple" => 11, "pear" => 7}

Click image to enlarge.

ExampleMap : [string]string = map{"a" => "apple", "b" => "bear", "c" => "candy"}
Creating a map: Use the keyword map followed by {}. If you want to specify initial elements in the map, add the key-value pairs between the {}, separated by ,. Specify the type by adding [key-type], where key-type is the type used for the keys before the type of value expected to be stored in the map. For example, [string]int.
ExampleMap["b"]
Accessing an element in a map: Use [] with the key of the element you want to access, such as ExampleMap[Key].
for (Value : ExampleMap):
    Value

for (Key -> Value : ExampleMap):
    Print("{Value} in ExampleMap at key {Key}")
Iterating over a map: You can access every element in a map, in order, from first element inserted to last, using the for expression. With the for expression, you can get the element with the syntax (Value : ExampleMap), or the element and its key with the syntax (Key -> Value: ExampleMap).
ExampleMap.Length
Getting the number of key-value pairs in a map: Use .Length on the map and its result will be the number of elements in the map.
For more info, see Map.

Composite Types
A composite type is any type that can be made up of fields and elements (usually named) of primitive or other types. Composite types usually have a fixed number of fields or elements for its lifespan. For more info, see Composite Types.

Enum
Enum is short for enumeration, which means to name or list a series of things, called enumerators. This is a type in Verse that can be used for things like days of the week or compass directions.


Click image to enlarge.

direction := enum{Up, Down, Left, Right}
Creating an enum: Use the keyword enum followed by {}. If you want to specify initial elements in the enum, add the enumerators between the {}, separated by ,.
direction.Up
Accessing an enumerator: Use . on the enum, followed by the enumerator you want to use. For example direction.Up.
Struct
Struct is short for structure, and is a way to group several related variables together. The variables can be of any type.


Click image to enlarge.


Click image to enlarge.

coordinates := struct:
    X : float = 0.0
    Y : float = 0.0
Creating a struct: Use the keyword struct followed by a code block. Definitions in the struct‚Äôs code block define the fields of the struct.
Position := coordinates{X := 1.0, Y := 1.0}
Instantiating a struct: You can construct an instance of a struct from an archetype. An archetype defines the values of a struct‚Äôs fields.
Position.X
Accessing fields on a struct: You can access a struct‚Äôs fields to get their value by adding . between the struct instance and the field name.
Class
A class is a template for creating objects with similar behaviors and properties (variables and methods), and must be instantiated to create an object with real values. Classes are hierarchical, which means that a class can inherit information from its parent (superclass) and share its information with its children (subclasses). A class can be a custom type defined by the user.


Click image to enlarge.


Click image to enlarge.

cat := class:
    Name : string
    var Age : int = 0
    Sound : string

    Meow() : void  =
        DisplayMessage(Sound)
Creating a class: Definitions that are nested inside a class define fields of the class. Functions defined as fields of a class are also called methods.
OldCat := cat{Name := "Percy", Age := 20, Sound:= "Rrrr"}
Instantiating a class: You can construct an instance of the class using the class name followed by {} (the archetype). An archetype defines the values of a class's fields.
OldCat.Name
Accessing fields on a class: You can access a class‚Äôs fields to get their value by adding . between the class instance and the field name.
OldCat.Meow()
Accessing methods on a class: You can access a class‚Äôs methods to call them by adding . between the class instance and the method name.
DisplayMessage(Cat : cat, Message : string) : void = {}

cat := class:
    Meow() : void =
        DisplayMessage(Self, Sound)
Self: You can use Self in a class method to refer to the instance of the class that the method was called on. You can refer to other fields of the instance the method was called on without using Self, but if you need to refer to the instance as a whole, you must use Self.
There are also specifiers that are unique to classes and that change their behavior. See Class Specifiers for details.

To learn more about classes, see Class.

Subclass
A subclass is a class that extends the definition of another class by adding or modifying the fields and methods of the other class (called the superclass).


Click image to enlarge.

player_character := class():
    StartingShields : int
    MaxShields : int
    AllowOvershield : logic

tank := class(player_character):
    DamageReduction : int
Creating a subclass: Specify a class as a subclass of another class by adding the other class between the () in class().
tank := class(player_character):
    StartingShields<override> : int = 100
    MaxShields<override> : int = 200
    AllowOvershield<override> : logic = true
    DamageReduction : int = 50
Overriding fields on the superclass: You can change the values of a field that‚Äôs defined in the superclass for the subclass only by adding the <override> specifier to the field name.
pet := class():
    Speak() : void = {}

cat := class(pet):
    Speak<override>() : void = {}
Overriding methods on the superclass:
You can change the implementation of a method that‚Äôs defined in the superclass for the subclass by adding the <override> specifier to the method name. You can use the overriding method everywhere the overriden method can be used. This means:

The method must accept at least any argument accepted by the overriden method, so the parameter type must be a supertype of the overriden function's parameter type.
The method must not return a value that the overriden method couldn't return, so the return type must be a subtype of the overriden method's return type.
The method must not have more effects than the overriden method, so the effect specifier must be a subtype of the overriden method's effect specifier.
cat := class(pet):
    Speak<override>() : void =
        (super:)Speak()
Super: Similar to Self, you can use (super:) to access the superclass's implementations of fields and methods. To be able to use (super:), the field or method must be implemented in the superclass definition.
For more info, see Subclass.

Constructor
A constructor is a special function that creates an instance of the class that it‚Äôs associated with. It can be used to set initial values for the new object.

class1 := class:
    Property1 : int
 
MakeClass1<constructor>(Arg1:int) := class1:
    Property1 := Arg
 
Main():void =
    X := MakeClass1(1)
    F := MakeClass1()
    Z := F(2)
Defining a constructor for a class: You can add a constructor for a class by adding the <constructor> specifier on the function name. Instead of specifying a return type on the function, the function is assigned the class name followed by any initialization of fields. A class can have more than one constructor.
MakeOtherClass1<constructor>(Arg1 : int) := class1:
    let:
        OnePlusArg1 := Arg1 + 1

    block:
        DoSomething(OnePlusArg1)

    Property1 := OnePlusArg1

    block:
        DoOtherStuff()
Adding variables and executing code in the constructor: You can execute expressions within a constructor with the block expression, and introduce new variables with the keyword let.
MakeClass1Plus1<constructor>(Arg1 : int) := class1:
    MakeClass1<constructor>(Arg1 + 1) # Note use of <constructor> on invocation

# The base type constructor can be invoked in any order with respect to properties,
# but the properties "win"
MakeOtherClass2<constructor>(Arg1 : int, Arg2 : int) := class2:
    Property2 := Arg2
    MakeClass1<constructor>(Arg1)
    # Note that effects are still ordered as they appear in the code
Calling other constructors in a constructor: You can call other constructors from a constructor. You can also call constructors for the superclass of the class from a constructor of the class as long as all fields are initialized. When a constructor calls another constructor and both constructors initialize fields, only the values provided to the first constructor are used for the fields. The order of evaluation for expressions between the two constructors will be in the order the expressions are written (as far as side effects are concerned), but only the values provided to the first constructor are used.
Interface
The interface type provides a contract for how to interact with any class that implements the interface. An interface cannot be instantiated, but a class can inherit from the interface and implement its methods. An interface is similar to an abstract class, except it does not allow partial implementation or fields as part of the definition.


Click image to enlarge.


Click image to enlarge.

rideable := interface():
    Mount()<decides><transacts> : void
    Dismount()<decides><transacts> : void
Creating an interface: You define an interface similarly to a class, except with the interface keyword. In the definition, you can specify the methods associated with the interface.
moveable := interface():
    MoveForward() : void

rideable := interface(moveable):
    Mount()<decides><transacts> : void
    Dismount()<decides><transacts> : void
Extending an interface: An interface can extend the definition of another interface by specifying the interface to extend between the () in interface().
bicycle := class(rideable): {}
    NumberOfGears : int = 0
    Mount<override>()<decides><transacts> : void = {}
    Dismount<override>()<decides><transacts> : void = {}
Implementing an interface: You can implement an interface with a class by specifying the interface between the () in class(). The class must override and implement each method defined in the interface.
lockable := interface():
    Lock() : void
    Unlock() : void

bicycle := class(rideable, lockable):
    Mount<override>()<decides><transacts> : void = {}
    Dismount<override>()<decides><transacts> : void = {}
    Lock<override>() : void = {}
    Unlock<override>() : void = {}
    MoveForward<override>() : void = {}
Implementing multiple interfaces: A class can implement multiple interfaces. The interfaces are separated by , between the () in class().
horse := class(moveable):
    MoveForward()<decides><transacts> : void = {}

saddle_horse := class(horse, rideable):
    Mount<override>()<decides><transacts> : void = {}
    Dismount<override>()<decides><transacts> : void = {}
*Inheriting from an interface and another class: A class can implement an interface and be a subclass of another class. The interface and superclass are separated by , between the () in class().
For more info, see Interface.

Working with Types
Verse provides a few ways to make working with types easier.

int_triple := tuple(int, int, int)

RotateInts(X : int_triple) : int_triple =
    (X(3), X(1), X(2))
Type aliasing: You can give a type a different name in your code and reference the type by that new name. The syntax is similar to constant initialization. You can also give a type alias to a function type. For more information, see Type Aliasing.
class1(t : type) := class:
   Property : t

F1(t : type) : void = {} 

Main() : void =
    X := class1(int){Property := 0}
    F1(int)
Parametric type as explicit type arguments: Verse supports parametric types (types expected as arguments). This only works with classes and functions. For more information, see Parametric Types.
F2(X : t where t : type) : t = X
Parametric type as implicit type arguments to functions: The reason to use implicit parametric types with functions is that it allows you to write code that is invariant of a particular type once, rather than for each type the function is used with. For more information, see Parametric Types.
type{IntToInt(Argument : int)<computes> : int}
Type macro: Verse has a special construct that can be used to get the type of an arbitrary expression. It can be used anywhere a type can be used. For more information, see Type Macro.
Filter(Array : []t, Element : comparable where t : subtype(comparable)) : []t =
    for (OtherElement : Array; OtherElement = Element):
        OtherElement
subtype: You can use subtype to give a constraint on a type variable. It requires that the type that may replace a type variable that is a subtype of the argument to subtype. Anything that may replace t in a call to Filter must be a subtype of comparable.
For more information, see Working with Verse Types.

Operators
Operators are special functions defined in the Verse programming language that perform actions, such as math operations, on their operands.

When multiple operators are used in the same expression, they are evaluated in the order of highest to lowest precedence. If there are operators with the same precedence in the same expression, they are evaluated left to right.

The table below lists all built-in operators in Verse, in order from highest to lowest precedence.

Operator	Description	Operator Format	Operator Precedence	Example
Query ?	The ? operator checks if a logic value is true. See Query for more details.	Postfix	9	TargetLocked?
Not not	The not operator negates the success or failure of an expression. See Not for more details.	Prefix	8	not TargetLocked?
Positive +	You can use the + operator as a prefix to a number to help align your code visually, but it won't change the value of the number. See Math for more details.	Prefix	8	+1
Negative -	You can use the operator - as a prefix to a number to negate the number value. See Math for more details.	Prefix	8	-1
Multiplication *	The * multiplies two number values together. See Math for more details.	Infix	7	2 * 3
Division /	The / operator divides the first number operand by the second number operand. Integer division is failable. See Math for more details.	Infix	7	6 / 3
Addition +	The + operator adds two number values together. When used with strings and arrays, the two values are concatenated. See Math for more details.	Infix	6	2 + 3
Subtraction -	The - operator subtracts the second number operand from the first operand. See Math for more details.	Infix	6	2 - 3
Addition assignment +=	With this operator, you can combine addition and assignment in the same operation to update a variable's value. See Math for more details.	Infix	5	set VariableName += 1
Subtraction assignment -=	With this operator, you can combine subtraction and assignment in the same operation to update a variable's value. See Math for more details.	Infix	5	set VariableName -= 1
Multiplication assignment *=	With this operator, you can combine multiplication and assignment in the same operation to update a variable's value. See Math for more details.	Infix	5	set VariableName *= 1
Division assignment /=	With this operator, you can combine division and assignment in the same operation to update a variable's value, unless the variable is an integer. See Math for more details.	Infix	5	set VariableName /= 2
Equal to =	The = operator succeeds when the left operand is equal to the right operand. Fails otherwise. See Comparison for more details.	Infix	4	MyScore = HighScore
Not equal to <>	The <> operator succeeds when the left operand is not equal to the right operand. Fails otherwise. See Comparison for more details.	Infix	4	MyScore <> HighScore
Less than <	The < operator succeeds when the left operand is less than the right operand. Fails otherwise. See Comparison for more details.	Infix	4	MyScore < HighScore
Less than or equal to <=	The <= operator succeeds when the left operand is less than or equal to the right operand. Fails otherwise. See Comparison for more details.	Infix	4	Score <= HighScore
Greater than >	The > operator succeeds when the left operand is greater than the right operand. Fails otherwise. See Comparison for more details.	Infix	4	MyScore > HighScore
Greater than or equal to >=	The >= operator succeeds when the left operand is greater than or equal to the right operand. Fails otherwise. See Comparison for more details.	Infix	4	MyScore >= HighScore
And and	The and operator succeeds only when all the operands succeed. See And / Or Operators for more details.	Infix	3	Value1 and Value2
Or or	The or operator succeeds if at least one of the operands succeeds. See And / Or Operators for more details.	Infix	2	Value1 or Value2
Variable and constant initialization : =	With this operator, you can store values in a constant or variable. See Constants and Variables for more details.	Infix	1	ConstantName := 5
Variable assignment set =	With this operator, you can update the values stored in a variable. See Constants and Variables for more details.	Infix	1	set VariableName = 5
For more, see Operators.

Grouping
You can change the order in which operators are evaluated by grouping expressions with (). For example, (1+2)*3 and 1+(2*3) don't evaluate to the same value because the expressions grouped in () would be evaluated first.

The following example shows how to use grouping to calculate an in-game explosion that scales its damage based on the distance from the player, but where the player's armor can reduce the total damage:

BaseDamage : float = 100.0
Armor : float = 15.0
DistanceScaling : float = Max(1.0, Pow(PlayerDistance, 2.0))
ExplosionDamage : float = Max(0.0, (BaseDamage / DistanceScaling) - Armor)
See Grouping for more details.

Code blocks
A code block is a group of zero or more expressions, and introduces a new scoped body. A code block must follow an identifier. This could be a function identifier, or a control flow identifier like if and for, for example.

if (conditions):
    expression1
    expression2
Spaced: Begins with :, and each new line in the code block is uniformly indented four spaces.
if (conditions)
{
    expression1
    expression2
}
Multi-line braced: Enclosed by {}, with each expression on a new line.
if (conditions) {expression1; expression2}
Single-line braced: Enclosed by {}, with each expression separated by ;.
It's also possible to use ; to put more than one expression on a line. In a format that has each expression on a new line, the {} characters don't have to be on their own lines.

The last expression in a code block is the result of the code block. In the following example, the if expression code block results in either false, if IsLightOn? succeeds, or true, if IsLightOn? fails. The logic result is then stored in NewLightState.

NewLightState :=
    if (IsLightOn?):
        Light.TurnOff()
        false
    else:
        Light.TurnOn()
        true
For more information, see Code Blocks.

Scope
Scope refers to the code within a Verse program where the association of an identifier (name) to a value is valid, and where that identifier can be used to refer to the value.

For example, any constants or variables that you create within a code block exist only in the context of that code block. This means that the lifetime of objects is limited to the scope they're created in, and they cannot be used outside of that code block.

The following example shows how to calculate the maximum number of arrows that can be bought using the number of coins the player has. The constant MaxArrowsYouCanBuy is created within the if block, so the scope is limited to the if block. When the constant MaxArrowsYouCanBuy is used in the print string, it produces an error because the name MaxArrowsYouCanBuy doesn't exist in the scope outside of that if expression.

CoinsPerQuiver : int = 100
ArrowsPerQuiver : int = 15
var Coins : int = 225

if (MaxQuiversYouCanBuy : int = Floor(Coins / CoinsPerQuiver)):
    MaxArrowsYouCanBuy : int = MaxQuiversYouCanBuy * ArrowsPerQuiver

Print("You can buy at most {MaxArrowsYouCanBuy} arrows with your coins.") # Error: Unknown identifier MaxArrowsYouCanBuy

Click image to enlarge.

Verse doesn't support reusing an identifier even if it's declared in a different scope, unless you qualify the identifier by adding (qualifying_scope:) before the identifier, where qualifying_scope is the name of an identifier's module, class, or interface. Whenever you define and use the identifier, you must also add the qualifier to the identifier.

Functions
A function is a named sequence of expressions that you can reuse. A function provides instructions for performing an action or creating an output based on input.

Function Definitions
To define your own function, you must provide three key parts: a unique name (identifier), the type of information you can expect as its result, and what the function will do when you call it. The following is the basic syntax for a function:

name() : type =
    codeblock
The name() and type separated by a colon: This is the function signature, which is how you must call and use the function, and the value that must be returned by the function is of the type you provide. This format is similar to how you create constants except for the () after the name, which mimics how you call the function in your code.
The function code block: You define what the function will do when it's called by providing =codeblock, where codeblock is any sequence of one or more expressions. Whenever you call the function, the expressions in the code block are executed.

Click image to enlarge.

Function Results
When your function has a return type specified, the function body must produce a result of that type or the code won't compile.

var MyScore : int = 100

IncreaseScore() : int =
    Points : int = 10

    set MyScore = MyScore + Points
Last expression returned with a value: By default, the last expression in the function‚Äôs code block is the result of the function and whose value must match the return type of the function.
var MyScore : int = 100

IncreaseScore() : int =
    Points : int = 10

    set MyScore = MyScore + Points

    Print("After you scored, MyScore is {MyScore}.")

    return MyScore
Explicit return with a value: You can also explicitly define what the function will return using return followed by a value, such as return HighScore. The return expression exits the function immediately, even if there are more expressions after it in the code block.
When you create a function that doesn't need to produce a result, you can set the function's return type to void, which means the function is not expected to produce a useful result and so the last expression in the function‚Äôs code block can be of any type.

You can exit a function whose return type is void by using the return expression by itself. This expression exits the function immediately, even if there are more expressions after it in the code block.

Function Parameters
Input to a function is defined using parameters. A parameter is a constant that's declared in the function signature between the parentheses that you can then use in the body of the function.

The following is the syntax for a function with two parameters:

name(parameter1name : type, parameter2name : type) : type =
    codeblock

Click image to enlarge.

In the following example, the function IncreaseScore() has one integer parameter named Points, which the function uses to increase the value of MyScore:

var MyScore : int = 100

IncreaseScore(Points : int) : void =
    # Increase MyScore by Points.
    set MyScore = MyScore + Points
Function Calls
When you want to use the named sequence of expressions (the function) in your code, you will call the function by name, like GetRandomInt(1, 10), which returns a random integer between 1 and 10, inclusive.

There are two ways to call a function depending on whether the function call is failable:

var MyScore = 100

IncreaseScore(Points : int) : void =
    set MyScore = MyScore + Points

Main() : void =
    IncreaseScore(Points := 10)
Non-failable function call: A function call that can‚Äôt fail has the form FunctionName().
IsPuzzleSolved()<decides><transacts> : void =
    CurrentState = PuzzleSolution # succeeds if CurrentState is equal to PuzzleSolution, and fails if not

Main() : void =
    if (IsPuzzleSolved[]):
        ItemSpawner.Enable()
Failable function call: A failable function call has the form FunctionName[]. A function is marked as failable when its definition has the decides specifier.
Function Arguments
When you call a function that expects parameters, you must assign values to the parameters, just as you need to assign values to constants to be able to use them. The assigned values are called arguments to the function.

The following is the syntax for calling a function with two arguments:

name(parameter1name := value, parameter2name := value)
In the following example, the function IncreaseScore() is called three times, with different arguments each time (10, 5, and 20), to increase the value of MyScore:

# After this call, MyScore is 110
IncreaseScore(Points := 10)

# After this call, MyScore is 115
IncreaseScore(Points := 5)

# After this call, MyScore is 135
IncreaseScore(Points := 20)
Extension Methods
Extension methods are a type of function that act like members of an existing class or type, but do not require the creation of a new type or subclass.

The following shows how to create an extension method for arrays of type int. The method adds all the numbers in the array and returns the total.

    # Sum extension method for type []int
    (Arr : []int).Sum<public>() : int =
        var Total : int = 0
        for (Number : Arr):
            set Total = Total + Number
        return Total
The method can then be called on any array of type int.

    SumTotal := array{4, 3, 7}.Sum()
    Print("The SumTotal is { SumTotal }")

    # "The SumTotal is 14"
Failure
Unlike other programming languages that use the Boolean values true and false to change the flow of a program, Verse uses expressions that can either succeed or fail. These expressions are called failable expressions, and can only be executed in a failure context.

Failable Expressions
A failable expression is an expression that can either succeed and produce a value, or fail and produce no value.

The following list includes all of the failable expressions in Verse:

IsPuzzleSolved()<decides><transacts> : void =
    CurrentState = PuzzleSolution # succeeds if CurrentState is equal to PuzzleSolution, and fails if not

Main() : void =
    if (IsPuzzleSolved[]):
        ItemSpawner.Enable()
Function calls: Only when the function call has the form FunctionName[], and the function definition has the decides specifier.
# Check that the player can afford this purchase.
if (Coins >= CoinsPerQuiver):
    # They can! Proceed with the purchase
    set Coins -= CoinsPerQuiver
    set Arrows += ArrowsPerQuiver
    set TotalPurchases += 1
Comparison: A comparison expression compares two things using one of the comparison operators. For more information, see operators.
if (MaxQuiversYouCanBuy : int = Floor(Coins / CoinsPerQuiver)):
    MaxArrowsYouCanBuy : int = MaxQuiversYouCanBuy * ArrowsPerQuiver
Integer division: For integers, the division operator / is failable, and the result is a rational type if it succeeds. For more information, see operators.
if (PlayerFallHeight < 3.0 and JumpMeter = 100):
    # Perform a double jump.
    ActivateDoubleJump()
    # Reset the player's fall height.
    ZeroPlayerFallHeight()
else:
   # Flap the character's arms to tell the player they
   # cannot double jump right now!
   ActivateFlapArmsAnimation()
Decision: A decision expression uses the operators not, and, or or to give you control over the success and failure decision flow. For more information, see operators.
if (IsLightOn?):
    # Turn light off, if it‚Äôs currently on
    Light.TurnOff()
else:
    # Turn light on, if it‚Äôs currently off
    Light.TurnOn()
Query: A query expression uses the operator ? and checks whether a logic or option value is true. Otherwise, the expression fails. For more information, see operators.
if (Element := ExampleArray[0]):
    Element
Accessing an element in an array: Accessing the value stored in an array is a failable expression because there might not be an element at that index, and so must be used in a failure context. For more details, see array.
Failure Contexts
A failure context is a context where it is allowable to execute failable expressions. The context defines what happens if the expression fails. Any failure within a failure context will cause the entire context to fail.

A failure context allows nested expressions to be failure expressions, such as function arguments or expressions in a block expression.

The following list includes all of the failure contexts in Verse:

if (conditions) { ‚Ä¶ }
The condition in if expressions.
for (Item : Collection, conditions) { ‚Ä¶ }
The iteration expressions and filter expressions in for expressions.
IsPuzzleSolved()<decides><transacts> : void =
    CurrentState = PuzzleSolution # succeeds if CurrentState is equal to PuzzleSolution, and fails if not
The body of a function that has the decides effect specifier.
not expression
The operand for the not operator.
expression1 or expression2
The left operand for the or operator.
option{expression}
Initializing a variable that has the option type.
Speculative Execution
A useful aspect of failure contexts in Verse is that they are a form of speculative execution, meaning that you can try out actions without committing them. When an expression succeeds, the effects of the expression are committed, such as changing the value of a variable. If the expression fails, the effects of the expression are rolled back, as though the expression never happened.

This way, you can execute a series of actions that accumulate changes, but those actions will be undone if they fail anywhere in the failure context.

To make this work, all functions called in the failure context must have the transacts effect specifier.

Specifiers
Specifiers in Verse describe behavior related to semantics, and can be added to identifiers and certain keywords. Specifier syntax uses < and >, with the keyword in between, such as IsPuzzleSolved()<decides><transacts> : void.

The following sections describe all of the specifiers in Verse and when you can use them.

Effect Specifiers
Effects in Verse indicate categories of behavior that a function is allowed to exhibit. You can add effect specifiers to:

The () after the name in a function definition: name()<specifier> : type = codeblock.
The class keyword: name := class<specifier>():.
Effect specifiers are divided into two categories:

Exclusive: You can have only one or none of the exclusive effect specifiers added to a function or the class keyword. If no exclusive effect specifier is added, the default effect is no_rollback.
Additive: You can add all, some, or none of the additive effect specifiers to a function or the class keyword.
Example	Effect
name() : type = codeblock
no_rollback: This is the default effect when no exclusive effect is specified. The no_rollback effect indicates that any actions performed by the function cannot be undone and so the function cannot be used in a failure context. This effect cannot be manually specified.
Exclusive Effects	 
name()<transacts> : type = codeblock
transacts: This effect indicates that any actions performed by the function can be rolled back. The transacts effect is required any time a mutable variable (var) is written. You‚Äôll be notified when you compile your code if the transacts effect was added to a function that can‚Äôt be rolled back. Note that this check is not done for functions with the native specifier.
name()<varies> : type = codeblock
varies: This effect indicates that the same input to the function may not always produce the same output. The varies effect also indicates that the behavior of the function is not guaranteed to stay the same with new versions of its containing package.
name()<computes> : type = codeblock
computes: This effect requires that the function has no side effects, and is not guaranteed to complete. There‚Äôs an unchecked requirement that the function, when provided with the same arguments, produces the same result. Any function that doesn‚Äôt have the native specifier that would otherwise have the converges effect is a good example of using the computes effect.
name()<converges> : type = codeblock
converges: This effect guarantees that not only is there no side effect from the execution of the related function, but that the function definitely completes (does not infinitely recurse). This effect can only appear in functions that have the native specifer, but this isn‚Äôt checked by the compiler. Code that is used to provide default values of class or values for global variables are required to have this effect. The functions sin(), cos(), and tan() are examples of functions that have the converges effect.
Additive Effects	 
name()<transacts><decides> : type = codeblock
decides: Indicates that the function can fail, and that calling this function is a failable expression. Function definitions with the decides effect must also have the transacts effect, which means the actions performed by this function can be rolled back (as if the actions were never performed), if there‚Äôs a failure anywhere in the function.
name()<suspends> : type = codeblock
suspends: Indicates that the function is async. Creates an async context for the body of the function.
In all cases, calling a function that has a specific effect will require the caller to have that effect as well.

Access Specifiers
Access specifiers define what can interact with a member and how. Access specifiers can be applied to the following:

The identifier for a member: name<specifier> : type = value
The keyword var for a member: var<specifier> name : type = value
name<public> : type = value
Public: The identifier is universally accessible. You can use this specifier on:

module
class
interface
struct
enum
method
data
name<protected> : type = value
Protected: The identifier can only be accessed by the current class and any subtypes. You can use this specifier on:

class
interface
struct
enum
non-module method
data
name<private> : type = value
Private: The dentifier can only be accessed in the current, immediately enclosing, scope (be it a module, class, struct, etc.). You can use this specifier on:

class
interface
struct
enum
non-module method
data
name<internal> : type = value
Internal: The identifier can only be accessed in the current immediately enclosing, module. This is the default access level. You can use this specifier on:

module
class
interface
struct
enum
method
data
Class Specifiers
Class specifiers define certain characteristics of classes or their members, such as whether you can create a subclass of a class.

pet := class<abstract>():
    Speak() : void

cat := class(pet):
    Speak() : void = {}
abstract: When a class or a class method has the abstract specifier, you cannot create an instance of the class. Abstract classes are intended to be used as a superclass with partial implementation or as a common interface. This is useful when it doesn't make sense to have instances of a superclass but you don't want to duplicate properties and behaviors across similar classes.
cat := class<concrete>():
     # field must be initialized because the class is concrete
    Name : string = "Cat"
concrete: When a class has the concrete specifier, it must be possible to construct it with an empty archetype, which means that every field of the class must have a default value. Every subclass of a concrete class is implicitly concrete. A concrete class can only inherit directly from an abstract class if both classes are defined in the same module.
cat := class<unique>:
    Name : string

Main()<decides> : void =
    Mittens1 := cat{Name := "Mittens"}
    Mittens1 = Mittens1 # Mittens1 is equal to itself
    Mittens2 := cat{Name := "Mittens"}
    Mittens1 <> Mittens2 # Mittens1 and Mittens2 are unique and therefore not equal
unique: The unique specifier can be applied to a class to make it a unique class. To construct an instance of a unique class, Verse allocates a unique identity for the resulting instance. This allows instances of unique classes to be compared for equality by comparing their identities. Classes without the unique specifier don't have any such identity, and so can only be compared for equality based on the values of their fields. This means that unique classes can be compared with the = and <> operators, and are subtypes of the comparable type.
cat := class<final>():
final: You can only use the final specifier on classes and members of classes:

When a class has the final specifier, you cannot create a subclass of the class.
When a field has the final specifier, you cannot override the field in a subclass.
When a method has the final specifier, you cannot override the method in a subclass.
Implementation Specifiers
It‚Äôs not possible to use implementation specifiers when writing code, but you will see them when looking at the UEFN APIs.

GetCreativeObjectsWithTag<native><public>(Tag:tag)<varies><transacts><no_rollback>:[]creative_object_interface
native: Indicates that the definition details of the element are implemented in C++. Verse definitions with the native specifier auto-generate C++ definitions that a developer can then fill out its implementation. You can see this specifier used on:

class
interface
enum
method
data
creative_device<native><public> := class<concrete>:
    OnBegin<public>()<suspends>:void = external {}

    OnEnd<native_callable><public>()<varies><transacts><no_rollback>:void = external {}
native_callable: Indicates that an instance method is both native (implemented in C++) and may be called by other C++ code. You can see this specifier used on an instance method. This specifier doesn‚Äôt propagate to subclasses and so you don‚Äôt need to add it to a definition when overriding a method that has this specifier.
Localization Specifier
You must use the localizes specifier when you're defining a new message. Specifically, this is when the variable has the message type and you're initializing the variable with a string value.

# The winning player's name:
PlayerName<localizes> : message = "Player One"
# Build a message announcing the winner.
Announcement<localizes>(WinningPlayerName : string) : message = "...And the winner is: {WinningPlayerName}"

Billboard.SetText(Announcement("Player One"))
You don't need to use the localizes specifier when initializing a member value with an already-created message because the localizes specifier is only for defining new messages.

PlayerOne<localizes> : message = "Player One"

# The winning player's name:
PlayerName : message = PlayerOne
Attributes
Attributes in Verse describe behavior that is used outside of the Verse language (unlike specifiers, which describe Verse semantics). Attributes can be added on the line of code before definitions.

Attribute syntax uses @ followed by the keyword.

@editable
Platform : color_changing_tiles_device = color_changing_tiles_device{}
editable: Indicates this field is an exposed property that can be changed directly from UEFN so you don't need to modify the Verse code to change its value. For more details, see Customize Your Device Properties in the Editor.

 
@doc("Given a distance along the length of this spline, return the associated data values at that point")
QueryAtDistanceAlongSpline<native><public>(DistanceAlongSpline : float, bIsWorldSpace : logic)<transacts><decides> : spline_query_result
doc: A generic note field that you'll find on classes and functions (but not function parameters). It should contain helpful information about what the element it describes does or how to use it, and is used to populate that element's page in the Verse API Reference.

 
Control Flow
Control flow is the order in which a computer executes instructions. Verse has different expressions you can use to control the flow of your program.

Block
Since Verse requires an identifier before a code block, block expressions are how you nest code blocks. A nested code block behaves similarly to a code block. As with code blocks, a block expression introduces a new nested scope body.

block
expression0
block:
    expression1
    expression2
expression3

Click image to enlarge.

Result: Last expression in the block code block. In this example, the result of the block expression is the result of expression2.
For more info, see Block.

If
With the if expression, you can make decisions that change the flow of the program. As with other programming languages, the Verse if expression supports conditional execution, but in Verse, the conditions use success and failure to drive the decision.

if	if ... then
expression0
if (conditions):
    expression1
expression2
expression0
if:
    conditions
then:
    expression1
expression2

Click image to enlarge.


Click image to enlarge.

Result: Last expression in the if code block. In this example, the result of the if expression is the result of expression1.	Result: Last expression in the if code block. In this example, the result of the if expression is the result of expression1.
if ... else	if ... else if ... else
expression0
if (conditions):
    expression1
else:
    expression2
expression3
expression0
if (conditions0):
    expression1
else if (conditions1):
    expression2
else:
    expression3
expression4

Click image to enlarge.


Click image to enlarge.

Result: Last expression in the if code block. In this example, the result of the if expression is either:

The result of expression1 if conditions succeeds
The result of expression2, if conditions fails.
Result: Last expression in the if code block. In this example, the result of the if expression is:

The result of expression1 if conditions0 succeeds
The result of expression2, if conditions0 fails and conditions1 succeeds
The result of expression3 if both conditions0 and conditions1 fail.
In the following example, the if expression code block results in either false, if IsLightOn? succeeds, or true, if IsLightOn? fails. The logic result is then stored in NewLightState.

NewLightState :=
    if (IsLightOn?):
        Light.TurnOff()
        false
    else:
        Light.TurnOn()
        true
A useful case for the if expression in Verse is that you can try out failable expressions and if they fail, the actions roll back as if they never happened. For more details on this feature, see Speculative Execution.

For more info, see If.

Case
With case expressions, you can control the flow of a program from a list of choices. The case statement in Verse allows testing one value against multiple possible values (as though you‚Äôre using =), and running code based on which one matches.

case
expression0
case (conditions):
    label1 =>
        expression1
    label2 =>
        expression2
    _ =>
        expression3 for the default case
expression4

Click image to enlarge.

Result: Last expression in the case code block. In this example, the result of the case expression is one of the following:

The result of expression1 if the result of conditions is label1
The result of expression2, if the result of conditions is label2
The result of expression3, if the result of conditions is neither label1 or label2.
For more info, see Case.

Loop
With the loop expression, the expressions in the loop block are repeated for every iteration of the loop.

loop
expression0
loop:
    expression1
    expression2
expression3

Click image to enlarge.

Result: The result of a loop expression is void, which means it doesn‚Äôt produce a useful result.
In the following example, a platform appears and disappears every ToggleDelay seconds for as long as the game runs.

loop:
    Sleep(ToggleDelay) # Sleep(ToggleDelay) waits for ToggleDelay seconds before proceeding to the next instruction.
    Platform.Hide()
    Sleep(ToggleDelay)
    Platform.Show() # The loop restarts immediately, calling Sleep(ToggleDelay) again.
For more info, see Loop.

Stopping Loops
A loop block will repeat forever, so to stop the loop, you can either exit the loop with break, or with a function‚Äôs return expression.

loop and break	loop and return
expression0
loop:
    expression1
    if (conditions):
        break
expression2
expression0
loop:
    expression1
    if (conditions):
        return
expression2

Click image to enlarge.


Click image to enlarge.

Result: The result of a loop expression is void, which means it doesn‚Äôt produce a useful result.	Result: The result of a loop expression is void, which means it doesn‚Äôt produce a useful result.
nested loop and break
expression0
# outer loop
loop:
    expression1
    # inner loop
    loop:
        expression2
        if (conditions0):
            # exit inner loop
                break
    expression3
    if (conditions1):
        # exit outer loop
        break
expression4

Click image to enlarge.

Result: The result of a loop expression is void, which means it doesn‚Äôt produce a useful result.
For more info, see Loop and Break.

For
A for expression, sometimes called a for loop, is the same as a loop expression, except that for expressions use a generator to produce a sequence of values one at a time and give each value a name.

For example, the expression for(Value : 1..3) produces the sequence 1, 2, 3, and each number in the sequence is given the name Value for each iteration, so the for loop runs three times.

The for expression contains two parts:

Iteration specification: The expressions within the parentheses. The first expression must be a generator, but the other expressions can be a constant initialization or a filter.
Body: The expressions in the code block after the parentheses.
for	for with a filter
expression0
for (Item : Collection):
    expression1
expression2
expression0
for (Item : Collection, conditions):
    expression1
expression2

Click image to enlarge.


Click image to enlarge.

Result: The result of a for expression is an array containing the result of each iteration‚Äôs code block.	Result: The result of a for expression is an array containing the result of each iteration‚Äôs code block.
for with multiple generators	nested for blocks
expression0
for (Item : Collection, Item2 : Collection2):
    expression1
expression2
expression0
for (Item : Collection):
    for (Item2 : Collection2):
        expression1
expression2

Click image to enlarge.


Click image to enlarge.

Result: The result of a for expression is an array containing the result of each iteration‚Äôs code block.	Result: The result of a for expression that has a nested for expression is an array containing the array of results of each iteration from the inner loop‚Äôs code block.
For more info, see For.

Defer
A defer expression executes just before transferring program control outside of the scope that the defer expression appears in, including any result expression, such as in a return. It doesn‚Äôt matter how the program control is transferred.

defer	defer before an exit
expression0
defer:
    expression1
    expression2
expression3
name() : type =
    expression0
    defer:
        expression1
        expression2
    return expression3

Click image to enlarge.


Click image to enlarge.

Result: The defer expression has no result.	Result: The defer expression has no result.
A defer expression will not execute if an early exit occurs before the defer is encountered.

defer with early return	defer with a canceled concurrent task
expression0
if (conditions):
    return
defer:
    expression1
expression2
expression0
race:
    block: # canceled during slow-async-expression
        slow-async-expression
        defer:
            expression1
        expression2
     block: # finishes first
         fast-async-expression
         defer:
             expression3
         expression4
expression5

Click image to enlarge.


Click image to enlarge.

Result: The defer expression has no result.	Result: The defer expression has no result.
Multiple defer expressions appearing in the same scope accumulate. The order they are executed is the reverse order they are encountered ‚Äî first-in-last-out (FILO) order. Since the last encountered defer in a given scope is executed first, expressions inside that last encountered defer can refer to context that will be cleaned up by other earlier encountered and later executed defer expressions.

Multiple defer expressions in a code block	Multiple defer expressions in different code blocks
expression0
defer:
    expression1
expression2
defer:
    expression3
expression4
expression0
if (conditions):
    expression1
    defer:
        expression2
    expression3
expression4
defer:
    expression5
expression6

Click image to enlarge.


Click image to enlarge.

Result: The defer expression has no result.	Result: The defer expression has no result.
Time Flow and Concurrency
Time-flow control is at the heart of the Verse programming language, and this is accomplished with concurrent expressions. To learn more about what concurrency is, see Concurrency Overview.

Structured Concurrency
Structured concurrency expressions are used to specify asynchronous time flow, and to modify the blocking nature of async expressions with a lifespan that is constrained to a specific async context scope (such as an async function body).

This is similar to structured control flow such as block, if, for, and loop that constrain to their associated scopes.

sync	branch
Executes all expressions in its code block concurrently and waits for them all to finish before executing the next expression after the sync.	The body of the branch expression is started as soon as it is encountered. The body of the branch expression continues to evaluate until the code block completes or the enclosing async context completes ‚Äî whichever occurs first ‚Äî at which point the branch code block task is canceled.
expression0
sync:
    slow-expression
    mid-expression
    fast-expression
expression1
expression0
branch:
    slow-expression
    mid-expression
    fast-expression
expression1

Click image to enlarge.


Click image to enlarge.

Result: The result of a sync expression is a tuple of results from each expression in the order that the top-level expressions were specified. The result types of the expressions can be of any type, and each tuple element will have the type of its corresponding expression.	Result: A branch expression has no result, so its result type is void.
race	rush
Similar to sync, but cancels all but the "winning" subexpression. If any other expressions complete at the same simulation time as the earlier expression, the first (earlier) expression "wins" and breaks any tie. Any "losing" expression tasks are canceled.	Similar to race, but expressions that complete after the first expression finishes continue to execute. If any expressions effectively complete at the same simulation update, then the earlier encountered expression that completes breaks any tie. Any incomplete expressions continue to evaluate until they complete, or until the enclosing async context completes, at which point, any remaining losing expressions are canceled ‚Äî whichever occurs first.
expression0
race:
    slow-expression
    mid-expression
    fast-expression
expression1
expression0
rush:
    slow-expression
    mid-expression
    fast-expression
expression1

Click image to enlarge.


Click image to enlarge.


Click image to enlarge.


Click image to enlarge.

Result: The result of a race expression is the result of the first completed expression. The result type is the most common compatible type of all expressions in the code block.	Result: The result of a rush expression is the result of the first completed expression. The result type is the most common compatible type of all expressions in the code block.
Unstructured Concurrency
Unstructured concurrency expressions ‚Äî of which spawn is the only one ‚Äî has a lifespan not constrained to a specific async context scope ‚Äî potentially extending beyond the scope where it was executed.

spawn
The body of a spawn creates an async context like the body of an async function. However, only a single async function call is allowed within the spawn body. The async function of the spawn is started as soon as it is encountered, and evaluates as much as possible until it encounters something suspending or blocking. The spawned async function continues to evaluate until it completes without any further connection to the location where it was spawned.
expression0
spawn{expression1}
expression2

Click image to enlarge.

Result: A spawn has a task result (task(type)).
Task
A task is an object used to represent the state of a currently-executing async function. Task objects are used to identify where an async function is suspended, and the values of local variables at that suspend point.

# Get task to query / give commands to
# starts and continues independently
Task2 := spawn{Player.MoveTo(Target1)}
Task2.Await() # wait until MoveTo() completed
Modules and Paths
A Verse module is an atomic unit of code that can be redistributed and depended upon, and can evolve over time without breaking dependencies. You can import a module into your Verse file to use code definitions from other Verse files.

using { /Verse.org/Random }
using: To be able to use the contents of a Verse module, you must specify the module by its path.
module1 := module:
    module2<public> := module:
        class1<public> := class {}
    class2<public> := class{}
module: Outside of modules introduced by folders in a project, modules can be introduced within a .verse file using the module keyword.

This guide provides a set of recommended standards for writing consistent code that's easy to maintain. By adhering to these guidelines, developers can improve code readability, reduce errors, and facilitate collaboration. A standardized code style is necessary to ensure code is easy to understand and maintain by both current and future developers working on a project.

This guide provides recommendations, but ultimately the choice is up to your team.

1. Common Naming Patterns
Naming is crucial for readable and maintainable code. Try to be consistent in the naming style throughout your code.

1.1 Do
IsX: Often used for naming logic variables to ask a question (for example, IsEmpty).

OnX: An overloadable function called by the framework.

SubscribeX: Subscribe to framework event named X, often passing an OnX function to it.

MakeC: Make an instance of class c without overloading the c constructor.

CreateC: Create an instance of class c, beginning its logical lifetime.

DestroyC: End the logic lifetime.

C:c: If you‚Äôre working with a single instance of class c, it‚Äôs fine to call it C.

1.2 Don‚Äôt
Decorate type names. Just call it thing, not thing_type or thing_class.

Decorate enumeration values. Not color := enum{COLOR_Red, COLOR_Green}, use color := enum{Red, Green}.

2. Names
2.1 Types use lower_snake_case
Type names should always be lower_snake_case. This includes all types: structs, classes, typedefs, traits/interfaces, enums, etc.

my_new_type := class
2.2 Interfaces are adjectives
Interfaces should be adjectives where possible, such as printable, enumerable. Where adjectives don‚Äôt seem right, append _interface to the name instead.

my_new_thing_interface := interface
2.3 PascalCase everything else
All other names should be PascalCase. Modules, member variables, parameters, methods, and so on.

MyNewVariable:my_new_type = ‚Ä¶
2.4 Parametric Types
Name parametric types t or thing, where thing explains what the type is supposed to represent. For example: Send(Payload:payload where payload:type) You‚Äôre sending some parameterized data, Payload, of any payload type.

If there‚Äôs more than one parametric type, avoid using single letters, such as t, u, g

Never use _t suffix.

3. Formatting
It is important to stay consistent with formatting throughout your codebase. This makes the code easier to read and understand for yourself and other developers. Choose a formatting style that works for the project.

As an example of staying consistent, you could choose one of the following spacing formats and use it throughout the codebase:

MyVariable : int = 5
MyVariable:int = 5
3.1 Indentation
Use four spaces for indentation, never tabs.

Code blocks should use indented blocks (spaced) rather than curly brackets (braced):

  my_class := class:
      Foo():void =
          Print("Hello World")
Except when writing single line expressions like option{a}, my_class{A := b}, etc.
3.2 Spaces
Use spaces around operators, unless it makes sense to keep the code compact for its context. Add braces to explicitly define the order of operations.
  MyNumber := 4 + (2 * (a + b))
Don‚Äôt add spaces at the beginnings and ends of brackets. Multiple expressions inside brackets should be separated by a single space.

  enum{Red, Blue, Green}
      MyObject:my_class = my_class{X := 1, Y := 2}
      Vector := vector3{X := 1000.0, Y := -1000.0, Z := 0.0}
      Foo(Num:int, Str:[]char)
Keep identifier and type together; add a space around the assignment = operator. Add a space around type definitions and constant initialization operators (:=).
  MyVariable:int = 5
  MyVariable := 5
  my_type := class
Follow the same recommendations for brackets, identifiers, and types spacing for function signatures.
  Foo(X:t where t:subtype(class3)):tuple(t, int) = (X, X.Property)
  Foo(G(:t):void where t:type):void
  Const(X:t, :u where t:type, u:type):t = X
3.3 Line Breaks
Use a spaced, multiline form to insert a line break.

Do	
MyTransform := transform:
    Translation := vector3:
        X := 100.0
        Y := 200.0
        Z := 300.0

    Rotation := rotation:
        Pitch := 0.0
        Yaw := 0.0
        Roll := 0.0
More readable and easier to edit.
Don't	
MyTransform := transform{Translation := vector3{X := 100.0, Y := 200.0, Z := 300.0}, Rotation := rotation{...}}
Hard to read on a single line.
Define enums in spaced, multiline form if they need per-enumeration comments or if you need to insert a line break.
  enum:
      Red, # Desc1
      Blue, # Desc2
3.4 Brackets
Don‚Äôt use brackets for non-inheriting class definitions.

Do	
my_base_type := class:
Don't	
my_base_type := class():
3.5 Avoid Dot-Space Notation
Avoid using dot-space ". " notation in place of braces. This makes it visually harder to parse whitespace and is a potential source of confusion.

Don't	
spawn { F() } -> spawn. F()
Don't	
using { Foo } -> using. Foo
4. Functions
4.1 Implicit return by default
Functions return their last expression value. Use that as an implicit return.

Sqr(X:int):int =
    X * X # Implicit return
If using any explicit returns, all returns in the function should be explicit.

4.2 GetX functions should be <decides><transacts>
Getters or functions with similar semantics that may fail to return valid values should be marked <decides><transacts> and return a non-option type. The caller should handle potential failure.

GetX()<decides><transacts>:x
An exception is functions that need to unconditionally write to a var. Failure would roll the mutation back, so they need to use logic or option for their return type.

4.3 Prefer Extension Methods to Single Parameter Functions
Use extension methods instead of a function with a single typed parameter.

Doing this helps Intellisense. By typing MyVector.Normalize() instead of Normalize(MyVector) it can suggest names with each character of the method name you type.

Do	
(Vector:vector3).Normalize<public>():vector3
Don't	
Normalize<public>(Vector:vector3):vector3
5. Failure Checks
5.1 Limit single line Failable Expressions count to three
Limit conditional checks/failable expressions on a single line to a maximum of three.

  if (Damage > 10, Player := FindRandomPlayer[], Player.GetFortCharacter[].IsAlive[]):
      EliminatePlayer(Player)
Use the form of if with parentheses () when the number of conditions is less than three.

Do	
if (Damage > 10, Player := FindRandomPlayer[]):
    EliminatePlayer(Player)
Keeps code concise but readable.
Don't	
if:
    Damage > 10
    Player := FindRandomPlayer[]
then:
    EliminatePlayer(Player)
Unnecessarily splits code over multiple lines with no readability improvements.
If using more than two words for each expression, a maximum of two expressions on a single line is often more readable.

  if (Player := FindAlivePlayer[GetPlayspace().GetPlayers()], Team := FindEmptyTeam[GetPlayspace().GetTeamCollection().GetTeams()]):
      AddPlayerToTeam(Player, Team)
You can also apply the rule as in a failure context on a single line, don't use more than nine words. When over the limit, use the spaced, multiline form.

Do	
if:
    Player := FindAlivePlayer[GetPlayspace().GetPlayers()]
    Team := FindEmptyTeam[GetPlayspace().GetTeamCollection().GetTeams()]
    Character := Player.GetFortCharacter[]
    Character.GetHealth() < 50
then:
    AddPlayerToTeam(Player, Team)
    Character.SetHealth(100)
The text reads better and the context is understandable over multiple lines.
Don't	
if (Player := FindAlivePlayer[GetPlayspace().GetPlayers()], Team := FindEmptyTeam[GetPlayspace().GetTeamCollection().GetTeams()], Character := Player.GetFortCharacter[], Character.GetHealth() < 50):
    AddPlayerToTeam(Player, Team)
    Character.SetHealth(100)
The text is hard to parse.
Evaluate whether grouping multiple failable conditions into a single <decides> function would make the code easier to read and reuse. Note that if the code is only ever used in one place, a "section" comment without an ad hoc function can suffice.

  if:
      Player := FindRandomPlayer[]
      IsAlive[Player]
      not IsInvulnerable[Player]
      Character := Player.GetFortCharacter[]
      Character.GetHealth < 10
  then:
      EliminatePlayer(Player)
Can be rewritten as:

  GetRandomPlayerToEliminate()<decides><transacts>:player=
      Player := FindRandomPlayer[]
      IsAlive[Player]
      not IsInvulnerable[Player]
      Character := Player.GetFortCharacter[]
      Character.GetHealth < 10
      Player
  if (Player := GetRandomPlayerToEliminate[]):
      Eliminate(Player)
The same guideline applies to expressions in for loops. For example:

  set Lights = for (ActorIndex -> TaggedActor : TaggedActors, LightDevice := customizable_light_device[TaggedActor], ShouldLightBeOn := LightsState[ActorIndex]):
      Logger.Print("Adding Light at index {ActorIndex} with State:{if (ShouldLightBeOn?) then "On" else "Off"}")
      if (ShouldLightBeOn?) then LightDevice.TurnOn() else LightDevice.TurnOff()
      LightDevice
Better as:

 set Lights = for:
     ActorIndex -> TaggedActor : TaggedActors
     LightDevice := customizable_light_device[TaggedActor]
     ShouldLightBeOn := LightsState[ActorIndex]
 do:
     if (ShouldLightBeOn?) then LightDevice.TurnOn() else LightDevice.TurnOff()
     LightDevice
5.2 Group Dependent Failure Expressions together
When a condition in a failure context depends on a previous failure context succeeding, keep the two conditions together in the same failure context when possible, and follow guideline 5.1.

This improves code locality, which simplifies logical understanding and debugging.

Do	
EliminatingCharacter := EliminationResult.EliminatingCharacter
if (FortCharacter := EliminatingCharacter?, EliminatingAgent := FortCharacter.GetAgent[]):
    GrantNextWeapon(EliminatingAgent)
Dependent or related conditions are grouped.
Do	
if:
    FortCharacter := Player.GetFortCharacter[]
    set AgentMap[Player] = 1
    FirstItemGranter:item_granter_device = ItemGranters[0]
then:
    FortCharacter.EliminatedEvent().Subscribe(OnPlayerEliminated)
    FirstItemGranter.GrantItem(Player)
Dependent or related conditions are grouped.
Don't	
EliminatingCharacter := Result.EliminatingCharacter
if:
    FortCharacter := EliminatingCharacter?
then:
    if:
        EliminatingAgent := FortCharacter.GetAgent[]
    then:
        GrantNextWeapon(EliminatingAgent)
Unnecessary indentation can make the flow harder to follow.
Don't	
if:
    FortCharacter := Player.GetFortCharacter[]
then:
    FortCharacter.EliminatedEvent().Subscribe(OnPlayerEliminated)
if:
    set AgentMap[Player] = 1
if:
    FirstItemGranter:item_granter_device = ItemGranters[0]
then:
    FirstItemGranter.GrantItem(Player)
Unnecessary indentation can make the flow harder to follow.
It‚Äôs acceptable to split failure contexts if you handle each potential failure (or failure groups) separately.

if (Player := FindPlayer[]):
    if (Player.IsVulnerable[]?):
        EliminatePlayer(Player)
    else:
        Print("Player is invulnerable, can‚Äôt eliminate.")
else:
    Print("Can‚Äôt find player. This is a setup error.")
6. Encapsulation
6.1 Prefer Interfaces to Classes
Use interfaces instead of classes where reasonable. This helps reduce implementation dependencies and allows users to provide implementations that can be used by the framework.

6.2 Prefer Private Access and Restrict Scope
Class members should be 'private' in most cases.

Class and module methods should be scoped as restrictively as possible - <internal> or <private> where appropriate.

7. Events
7.1 Postfix Events with Event and Prefix Handlers with On
Subscribable events or delegate list names should be postfixed with 'Event', and event handler names should be prefixed with 'On'.

MyDevice.JumpEvent.Subscribe(OnJump)
8. Concurrency
8.1 Don‚Äôt Decorate <suspends> Functions with Async
Avoid decorating <suspends> functions with Async or similar terms.

Do	
DoWork()<suspends>:void
Don't	
DoWorkAsync()<suspends>:void
It‚Äôs acceptable to add the Await prefix to a <suspends> function that internally waits on something to happen. This can clarify how an API is supposed to be used.

AwaitGameEnd()<suspends>:void=
    # Setup other things before awaiting game end‚Ä¶
    GameEndEvent.Await()

OnBegin()<suspends>:void =
    race:
        RunGameLoop()
        AwaitGameEnd()
9. Attributes
9.1 Separate Attributes
Put attributes on a separate line. It‚Äôs more readable, especially if multiple attributes are added to the same identifier.

Do	
@editable
MyField:int = 42
Don't	
@editable MyField:int = 42
10. Import Expressions
10.1 Sort Import Expressions Alphabetically
For example:

using { /EpicGames.com/Temporary/Diagnostics }
using { /EpicGames.com/Temporary/SpatialMath }
using { /EpicGames.com/Temporary/UI }
using { /Fortnite.com/UI }
using { /Verse.org/Simulation }


Linked lists are a common data structure in Computer Science. You can use a linked list to represent a music playlist, or track history of actions, for example.

Overview
A linked list is a linear data structure where each element stores a reference to the next element in the list. Each element in a linked list is called a node. A node is a container that holds some data and a reference to the next node.image alt text

Linking different nodes together in a sequence creates a linked list. The first node in the list is called the head node, and the last node is called the tail node. To traverse through the list, you start at the Head and travel to the next element using the reference in each node.

image alt text
When to use
Linked lists are a good starting point for implementing other data structures such as stacks or queues. Linked lists are a straightforward way of storing data for sequential access, and they support the quick insertion of new elements. Unlike arrays, linked lists are not contiguous (next to each other) in memory. This means that a node could be anywhere in memory, and the reference to the next node tells you the location. To insert or delete nodes from a linked list, all you need to do is change the references to which node comes next.

When not to use
If your program requires random access to elements (such as picking a random player from a list), linked lists lack this functionality. Linked lists are less efficient than arrays if you need to access a particular node in the middle of the list since you'll have to start from the head and traverse to the particular node you need.

Verse Implementation
The Verse API does not have a built-in implementation of linked lists, but you can create one yourself.

Linked lists are comprised of nodes, and you'll need to define a class to represent them. An example of a generic type of node is below:

list_node := class<unique>:
    var Next:?list_node = false
    Data:any = {}
Here the option variable Next stores a reference to the next node in the list, which is of type list_node. Note that Next has to be an option variable, because a node might not always have a next node to point to (such as the tail node of a linked list). If you want to change the linking of your list dynamically, Next needs to be a var. The node also contains some value, which is stored in Data. Since this is a generic type of node, Data is of type any, and the node could contain any data type. It could be a common type, a container, or even another linked list!

Node1 := list_node{ Next := false, Data := 1 } # An int
Node2 := list_node{ Next := false, Data := "String" } # A string
Node3 := list_node{ Next := false, Data := []int} # An array
Node4 := list_node{ Next := false, Data := list_node } # list_node class
Node5 := list_node{ Next := false, Data := Node1 } # The first node
The <unique> specifier lets list_node be comparable. This lets you check if a node is equal to some other node, such as checking if your node is the head or tail of a list.

If you need a more specific implementation, such as a node that only handles numbers or strings, make sure to change the type of Data to match. If Data is of type comparable, you can compare the value in Data to another value to find a specific node.

Singly Linked Lists
The most basic type of linked list is a singly linked list, where each node contains a reference to the next node (a single link). To turn your nodes into a list, link them together using the Next references in each node.

image alt text
# Link each Node to the next Node in the list
set Node1.Next = option{Node2}
set Node2.Next = option{Node3}
set Node3.Next = option{Node4}
set Node4.Next = option{Node5}
Although your nodes are linked, you'll want to define your linked list in a class. This will make it easy to perform functions using your list, rather than referencing your first node each time.

linked_list := class:
    var Head:list_node
A basic linked_list class only contains a reference to the head node. To create an instance of your linked_list class, link your nodes together, then instantiate your list using the head node.

# Create a Linked List with node1 as the head.
BasicList:linked_list = linked_list{Head := Node1}
To traverse the list, you start at the head node and iterate through the list, stopping at the tail. You can do this either in an external function or in a class function inside your linked_list class. An example function that traverses the entire list from head to tail is provided below:

linked_list := class:
    var Head:list_node

    TraverseList():void=
        var CurrentNode:?list_node := option{Head} # The node you're currently on
        var NodeNumber:int = 1 # The number of the current node
        Print("Starting at the Head Node...")
        # If the current node has a next node, set the current node to
        # the next node in the list
        loop:
            if(NextNode := CurrentNode?.Next?):
                set CurrentNode = option{NextNode}
                set NodeNumber += 1
                Print("Traveling to Node {NodeNumber}!")
            else:
                Print("No next node, this is the Tail node!")
                break
Here the TraverseList() function checks if CurrentNode contains a Next reference, and stores it in NextNode. If so, it sets CurrentNode to NextNode repeatedly until reaching the tail node. The tail node does not have a Next reference so the loop stops here.

Doubly Linked Lists
Unlike singly linked lists, nodes in a doubly linked list also contain a reference to the node that came before it called the previous node.

doubly_linked_node := class<unique>:
    var Next:?doubly_linked_node = false
    var Previous:?doubly_linked_node = false
    Data:any = {}
image alt text
This means that you can traverse nodes in a doubly linked list both forward and backward. This can be done either in an external function or in a class function. An example function that traverses the list from head to tail and back is provided below:

doubly_linked_list := class():
    Head:doubly_linked_node

    # Traverse a LinkedList, but both backward and forward!
    TraverseDoublyLinkedList():void=
        var CurrentNode:?doubly_linked_node := option{Head}
        var NodeNumber:int = 1
        Print("Starting at the Head Node, and going forward...")
        loop:
            if(NextNode := CurrentNode?.Next?):
                set CurrentNode = option{NextNode}
                set NodeNumber += 1
                Print("Traveling to Node {NodeNumber}!")
            else:
                Print("No next node, this is the Tail node!")
                break
        Print("Now let's go backward to the Head node...")
        loop:
            if(PreviousNode := CurrentNode?.Previous?):
                set CurrentNode = option{PreviousNode}
                set NodeNumber -= 1
                Print("Traveling to Node {NodeNumber}!")
            else:
                Print("No previous Node, we're back at the Head node!")
                break
Circular Linked Lists
In a circular linked list, the head node is linked to the tail node. This means you can traverse the entire list past the tail node and arrive back at the head. Circular linked list can be either singly or doubly linked, the only requirement is that the head node links to the tail, or vice versa.

image alt text
Iterators
An iterator is an object that allows you to iterate over a container and perform operations along the way. You can think of it like a train car full of passengers. The train travels down a track, stopping at each station along the way. At each station, the train does a task, such as boarding or disembarking passengers. With regard to linked lists, each station is a node in the list. The train (iterator) travels down the list to each node and can perform operations where it stops.

Iterators are useful for linked lists because they allow you to perform operations at specific places, rather than just at the head or tail node.

linked_list_iterator := class:
    List:linked_list
    var CurrentNode:list_node

    # If there is a NextNode for the iterator to travel to, travel to that node
    Next()<transacts><decides>:list_node=
        set CurrentNode = CurrentNode.Next?
Here the iterator contains a reference to the list that it iterates over and a CurrentNode where the iterator is currently stopped. The Next() function checks if the CurrentNode has a node after it, and then jumps to that node. Note that Next() here includes the <transacts> and <decides> specifiers. The function must be <transacts> since it updates the CurrentNode var, and you want to include <decides> since making Next() failable lets you know whether you iterated to the next node or not.

Although it might seem like an iterator should start at the head of a list, it actually needs to start before the head. This is so that the iterator can perform operations on the head node, such as inserting nodes before the head or deleting the head entirely.

To initialize the iterator before the head, you can initialize CurrentNode to a dummy node with the head of the list as the next node. In Verse, you can't access the List when initializing CurrentNode, because class members variable can't be accessed from the same scope, only different scopes such as within a function.

linked_list_iterator := class:
    List:linked_list
    # The below line will fail because you can't access List from this scope
    var CurrentNode:list_node := list_node{Next := option{List.Head}}
Instead, to instantiate an iterator you can use a constructor function. A constructor is a composite type that creates an instance of the class it's associated with. The constructor sets initial values for an object and allows you to access the value of List and assign CurrentNode to its head.

# Construct an Iterator with CurrentNode as a dummy node before the head of the given list.
MakeIterator<constructor>(List:linked_list) := linked_list_iterator:
    List := List
    # You can access List from this scope in a constructor function
    CurrentNode:= list_node{Next := option{List.Head}}

linked_list_iterator := class:
    List:linked_list
    var CurrentNode:list_node
Initializing an iterator for a doubly linked list looks very similar, except that you initialize it using doubly linked nodes.

# Construct an Iterator with CurrentNode as a dummy node before the head of the given list.
MakeDoublyLinkedIterator<constructor>(List:doubly_linked_list) := doubly_linked_list_iterator:
    List := List
    # You can access List from this scope in a constructor function
    CurrentNode:= doubly_linked_node{Next := option{List.Head}}

doubly_linked_list_iterator := class:
    List:doubly_linked_list
    var CurrentNode:doubly_linked_node
Iterating Between Nodes
You can move the iterator forwards or backward depending on the linking of your list. Iterators in a singly linked list can only travel forward, while iterators in a doubly linked list can travel in either direction. This functionality is defined in two functions, Next() and Previous(). Remember that singly linked lists will not have a Previous() function. Circularly linked lists may have either function depending on whether they are singly or doubly linked.

# If there is a NextNode for the iterator to travel to, travel to that node
Next()<transacts><decides>:doubly_linked_node=
    set CurrentNode = CurrentNode.Next?

# If there is a PreviousNode for the iterator to travel to, travel to that node
Previous()<transacts><decides>:doubly_linked_node=
    set CurrentNode = CurrentNode.Previous?
Adding Nodes
You can use iterators to add nodes to specific places in the linked list. When adding a node, choosing where to add the node is important. You could add the node before or after the current node, but this depends on the structure of your list. In a singly linked list, you can only add nodes after other nodes, because you don't have a Previous node reference to refer to. In a doubly linked list, you can add nodes before or after other nodes.

# Adds a new node after CurrentNode
AddNextNode(NewNode:list_node):void=
    if(NextNode := CurrentNode.Next?):
        set NewNode.Next = option{NextNode}
        set CurrentNode.Next = option{NewNode}
        Print("Successfully added a new node!")
    else:
        set CurrentNode.Next = option{NewNode}
        Print("Successfully added a new node to the tail of the list!")
Here the AddNode function adds a node between CurrentNode and the node after it. It does this by:

Setting the Next reference of the CurrentNode to NewNode.

Setting the Next reference of NewNode to the NextNode. If there is no NextNode (such as at the tail of a list), the function only sets NewNode as the next node.

In a doubly linked list, you have the option of adding nodes before or after CurrentNode. You can split this functionality into two functions, AddNodeAfter() and AddNodeBefore(). The implementation is very similar to the one in the singly linked list, except that you have to remember to set the Previous reference for each node as well.

# Adds a new node after CurrentNode
AddNodeAfter(NewNode:doubly_linked_node):void=
    if(NextNode := CurrentNode.Next?):
        set NewNode.Next = option{NextNode}
        set NewNode.Previous = option{CurrentNode}
        set CurrentNode.Next = option{NewNode}
        set NextNode.Previous = option{NewNode}
        Print("Successfully added a new node!")
    else:
        set CurrentNode.Next = option{NewNode}
        Print("Successfully added a new node to the tail of the list!")

# Adds a new node before CurrentNode
AddNodeBefore(NewNode:doubly_linked_node):void=
    if(PreviousNode := CurrentNode.Previous?):
        set NewNode.Next = option{CurrentNode}
        set NewNode.Previous = option{PreviousNode}
        set CurrentNode.Previous = option{NewNode}
        set PreviousNode.Next = option{NewNode}
        Print("Successfully added a new node!")
    else:
        set NewNode.Next = option{CurrentNode}
        set CurrentNode.Previous = option{NewNode}
        Print("Successfully added a new node to the tail of the list!")
Removing Nodes
To remove nodes, you need to delete any references to that node while preserving the order of the list. To do so, if the node you want to remove has any nodes after it, you need to link any nodes before the removed node to the nodes after it. In a singly linked list, because you don't have a Previous reference, you can only remove nodes after the CurrentNode.

# Remove the next node after CurrentNode. If the next node
# has a Next reference, set that node to the next node of CurrentNode
RemoveNextNode():void=
    if(RemovedNode := CurrentNode.Next?):
        if(NodeAfter := RemovedNode.Next?, set RemovedNode.Next = false):
            set CurrentNode.Next = option{NodeAfter}
            Print("Removed the node between CurrentNode and the node after it")
            # If the removed node is the Head node, set the next node as the new Head
            if(RemovedNode = List.Head):
                Print("Removed node was the head node, setting the node after as the new head")
                set List.Head = NodeAfter
        else:
            set CurrentNode.Next = false
            Print("Removed the node before CurrentNode")
    else:
        Print("Couldn't remove the node")
Note that you need a special case when removing from the head node. In this situation, you need to set the node after the head node to the new head, or else your linked list won't have a place to start from.

As with adding nodes, removing nodes in a doubly linked list can be split into removing the node before or after the current node.

# Remove the node after CurrentNode
RemoveNodeAfter():void=
    if(RemovedNode := CurrentNode.Next?):
        if:
            NodeAfter := RemovedNode.Next?
            set RemovedNode.Next = false
            set RemovedNode.Previous = false
            set NodeAfter.Previous = option{CurrentNode}
            set CurrentNode.Next = option{NodeAfter}
        then:
            Print("Removed the node between CurrentNode and the node after it")
            # If the removed node is the Head node, set the next node as the new Head
            if(RemovedNode = List.Head):
                Print("Removed node was the head node, setting the node after as the new head")
                set List.Head = NodeAfter
                # You don't want to be able to traverse back to the dummy node
                # so set the new head's Previous to false
                set NodeAfter.Previous = false       
        else:
            set CurrentNode.Next = false
            Print("Removed the node after CurrentNode")
    else:
        Print("Couldn't remove the node")   

# Remove the node before CurrentNode.
RemoveNodeBefore():void=
    if(RemovedNode := CurrentNode.Previous?):
        if:
            NodeBefore := RemovedNode.Previous?
            set RemovedNode.Previous = false
            set CurrentNode.Previous = option{NodeBefore}
            set NodeBefore.Next = option{CurrentNode}
        then:
            Print("Removed the node between CurrentNode and the node before it")
            # If the removed node is the Head node, set the next node as the new Head
        else:
            set CurrentNode.Previous = false
            if(RemovedNode = List.Head):
                Print("Removed node was the head node, setting the node after as the new head")
                set List.Head = CurrentNode
            Print("Removed the node after CurrentNode")
    else:
        Print("Couldn't remove the node")
On your own
There are multiple ways to enhance linked lists, and you should explore different ways of adding functionality. The following are a couple of ways you could enhance your linked lists:

What if each List also stored a reference to the tail node?

Can you implement a ToString() method to print out the contents of your nodes?

What about reversing a list? Can you implement a Length() functionality?

Can you add more methods to the iterator to do new operations?

To help with debugging your game, you can display certain game data for testing purposes while hiding that information from the player. One way to do this is logging, but you can show some game data in a more visual way with the Debug Draw API.

Using the Debug Draw API, you can draw basic shapes and set their location, size, color, and the length of time they appear on screen. For example, you might want to visualize the visibility range of an NPC or the distance from which audio can be heard from its point of origin. With the box debug shape, you could draw a box with dimensions and a location that match any volume, even if that volume is invisible in your game. This can help with figuring out the placement of volumes with certain effects.


The arrow debug shape drawn from an NPC‚Äôs face to the limit of their visibility range can be used to help design the perfect placement for guards.

Enable Verse Debug Draw
The first step is to make sure you can see the shapes you draw.

Select Island Settings in the UEFN Outliner.

In the Details panel search bar, type debug. This will filter results to the User Options - Debug category.

Click Debug, then Verse Debug Draw to activate Debug features and Verse Debug Draw.


Verse Debug Draw will only be active during a play session of UEFN. It is enabled per user, which means only those who have activated Debug and Verse Debug Draw will see debug shapes. Debug shapes will not appear in the UEFN viewport or on a published island, even if this option is checked in Island Settings.

Draw Your First Debug Shape
To draw your first shape with the Debug Draw API, follow these steps.

Add this import expression to your Verse file.

 using { /UnrealEngine.com/Temporary/Diagnostics }
Create a channel by declaring a subclass that inherits from the debug_draw_channel type. Channels are for grouping related shapes together. They are optional but it is a good practice to use them. There are functions in the Debug Draw API that you can use to show, hide, or clear many shapes all at once, but showing and hiding only works at the channel level.

 my_debug_draw := class(debug_draw_channel) {}
Declare a new constant of type debug_draw. This will be the object you use to call the methods to draw shapes. This example shows the use of the Channel parameter (created in the previous step), but it is optional.

 DebugDraw:debug_draw = debug_draw{Channel := my_debug_draw}
Call the DrawSphere method. This example uses two parameters.

Center:= vector3{Z:= 150.0}: This is a required parameter of type vector3 which determines the location of the sphere‚Äôs center. In this example you will use the constructor of the vector3 type to create a literal value. This will set the center of the sphere at location 0.0, 0.0, 150.0.

?DrawDurationPolicy:= debug_draw_duration_policy.Persistent: This parameter is optional but its default value will make the sphere disappear after a few seconds, so set it to the Persistent policy. This means that the sphere will remain visible on the island until it is hidden or cleared by other code.

  DebugDraw.DrawSphere(Center := vector3{Z:=150.0}, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)

After building your Verse code and launching a session, you should see a sphere appear at the location set by the Center parameter.

Shapes
With the Debug Draw API, you can draw several shapes that appear as simple wireframes in a running UEFN session. Each shape is useful in different scenarios. The following sections explain the methods to draw each shape and the parameters that are unique to each method. A later section explains the parameters that are common to every method. Each code example in this section assumes you have added the code from Draw Your First Debug Shape to your Verse file.

Box
Use the DrawBox() method to draw a cube.


DebugDraw.DrawBox(vector3{Z:=150.0}, rotation{}, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)
Unique Parameter	What It Does
Center:vector3	Sets the center of the box
Rotation:rotation	Sets how the box is rotated
?Extent:vector3	Sets the length, width, and depth of the box
Capsule
Use the DrawCapsule() method to draw a capsule. A capsule is made up of a cylinder with one half of a sphere on either end.


DebugDraw.DrawCapsule(vector3{Z:=200.0}, rotation{}, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)
Unique Parameter	What It Does
Center:vector3	Sets the center of the capsule
Rotation:rotation	Sets how the capsule is rotated
?Height:float	Sets the length of the capsule
?Radius:float	Sets the radius of the capsule at its widest point
Sphere
Use the DrawSphere() method to draw a sphere.


DebugDraw.DrawSphere(vector3{Z:=150.0}, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)
Unique Parameter	What It Does
Center:vector3	Sets the center of the sphere
?Radius:float	Sets the radius of the sphere at its widest point
?NumSegments:int	Sets the number of lines that make up the sphere
Cone
Use the DrawCone() method to draw a cone.


DebugDraw.DrawCone(vector3{Z:=150.0}, vector3{Z:=-1.0}, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)
Unique Parameter	What It Does
Origin:vector3	Sets the location of the point of the cone
Direction:vector3	Sets the direction in which the cone opens
?Height:float	Sets the length of the cone
?NumSides:int	Sets the number of sides
?AngleWidthRadians:float	Sets the width of the cone in the X direction
?AngleHeightRadians:float	Sets the width of the cone in the Y direction
To make the bottom of your cone a perfect circle, AngleWidthRadians and AngleHeightRadians must be equal.

Cylinder
Use the DrawCylinder() method to draw a cylinder.


DebugDraw.DrawCylinder(vector3{Z:=100.0}, vector3{Z:=200.0}, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)
Unique Parameter	What It Does
Start:vector3	Sets the location of one end of the cylinder
End:vector3	Sets the location of the other end of the cylinder
?NumSegments:int	Sets the number of lines connecting one end of the cylinder to the other
?Radius:float	Sets the radius of the two circles making up each end of the cylinder
Line
Use the DrawLine() method to draw a line.


DebugDraw.DrawLine(vector3{Z:=100.0}, vector3{Z:=200.0}, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)
Unique Parameter	What It Does
Start:vector3	Sets the location of one end of the line
End:vector3	Sets the location of the other end of the line
Arrow
Use the DrawArrow() method to draw an arrow.


DebugDraw.DrawArrow(vector3{Z:=100.0}, vector3{Z:=200.0}, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)
Unique Parameter	What It Does
Start:vector3	Sets the location of the start of the arrow
End:vector3	Sets the location of the head of the arrow
?ArrowSize:float	Sets the length of the two lines that make up the head of the arrow
Point
Use the DrawPoint() method to draw a point.


DebugDraw.DrawPoint(vector3{Z:=200.0}, ?Thickness:= 10.0, ?DrawDurationPolicy := debug_draw_duration_policy.Persistent)
Unique Parameter	What It Does
Position:vector3	Sets the location of the point
The default Thickness of DrawPoint is too small to be visible. Set Thickness to a larger value as shown in the above example to see the point.

Common Parameters
These parameters are common to all the methods that draw shapes. They are also all optional, and do not need to be included as arguments when calling a method. If you do choose to include them, be sure to use the parameters name prepended by a ?. See Calling Functions in Functions for more information on named and optional arguments.

Color
Set the color of shapes using the Color parameter. Values must be of type color. The list of valid colors can be found in the NamedColors module. Be sure to have the import expression for the Colors module at the top of your Verse file. Below is an example of setting a point to a different color.

DebugDraw.DrawPoint(Position := vector3{Z:= 200.0}, ?Thickness := 20.0, ?Color := NamedColors.MediumSeaGreen)
DrawDurationPolicy
The DrawDurationPolicy determines how long a debug shape remains on screen. There are three possible values.

SingleFrame : The shape will remain on screen for the length of a single frame. This policy can be useful when you want to frequently redraw a shape.

FiniteDuration: This policy is used with the Duration parameter to display a shape for a certain number of seconds.

Persistent: With the Persistent policy, the shape will remain on screen until hidden or cleared by other code.

Duration
The Duration parameter is used with the FiniteDuration policy to display a shape for a certain number of seconds. Below is an example of code that draws a sphere that displays for 30 seconds.

DebugDraw.DrawSphere(vector3{}, ?DrawDurationPolicy := debug_draw_duration_policy.FiniteDuration, ?Duration := 30.0)
Thickness
The Thickness parameter sets the thickness of the lines that make up each debug shape. In the case of DrawPoint(), it sets the thickness of the single point.

Channels
You can use channels to group related shapes together, and then hide, show, or clear all the shapes in a channel at once.

To create a channel, use the Channel parameter when declaring an instance of debug_draw.

DebugDraw:debug_draw = debug_draw{Channel := debug_draw_defaults}
Now any shape you draw using the DebugDraw instance can be hidden, shown, or cleared with a single method. For example, if you draw a point, a sphere, and an arrow with the DebugDraw instance, you can then hide them for some time, then show them again, and finally clear them when they are no longer needed.

# Point
DebugDraw.DrawPoint(vector3{Z := 200.0}, ?Thickness:= 50.0, ?DrawDurationPolicy:= debug_draw_duration_policy.Persistent)

# Sphere
DebugDraw.DrawSphere(vector3{Z := 200.0}, ?DrawDurationPolicy:= debug_draw_duration_policy.Persistent)

# Arrow
DebugDraw.DrawArrow(vector3{Z := 200.0}, vector3{Z := 400.0}, ?DrawDurationPolicy:= debug_draw_duration_policy.Persistent)

Sleep(5.0)
DebugDraw.HideChannel()
Sleep(5.0)
DebugDraw.ShowChannel()
Sleep(5.0)
DebugDraw.ClearChannel()
Default Parameter Values
Parameter	Value
?Color:color	NamedColors.Yellow
?DrawDurationPolicy:debug_draw_duration_policy	debug_draw_duration_policy.FiniteDuration
?Duration:float	5.0
?Thickness:float	0.0
?Radius:float	10.0
Examples
Visualize the Range of an Audio Player Device
The Audio Player Device has a setting to visualize its attenuation. But you can only see this visualization during edit mode. Follow these steps to learn how to to recreate the attenuation visuals in a play session.


Drag an Audio Player Device into your level. In the Details panel, make sure that Enable Attenuation Visuals is checked. This will help you verify that you are recreating the visuals correctly with the debug shapes.

In your Verse file, create a new debug_draw instance called DebugDrawAudio. Give it a channel with the name debug_draw_audio.

 DebugDrawAudio:debug_draw = debug_draw{Channel := debug_draw_audio}
Add two @editable constants of type float. Name them DebugAttenuationMinDistance and DebugAttenuationFalloffDistance. These will be the two radii of the spheres drawn to visualize the attenuation of the Audio Player Device.

 @editable
 DebugAttenuationMinDistance:float = 100.0

 @editable
 DebugAttenuationFalloffDistance:float = 100.0
Add another @editable to represent the Audio Player Device. Name it AudioPlayerDevice.

 @editable
 AudioPlayerDevice:audio_player_device = audio_player_device{}
Declare a function called DrawAudioDeviceRange() and give it two parameters of type float: AttenuationMinDistance and AttenuationFalloffDistance.

 DrawAudioDeviceRange(AttenuationMinDistance:float, AttenuationFalloffDistance:float):void =
In the new function, get the Transform object of the Audio Player Device.

 AudioPlayerDeviceTransform:= AudioPlayerDevice.GetTransform()
Using the DrawSphere function from the Debug Draw API, draw two spheres to represent the Attenuation Min Distance and the Attenuation Falloff Distance. The Radius in the second DrawSphere call must be set to the sum of AttenuationMinDistance and AttenuationFalloffDistance because attenuation only starts outside the radius of the Attenuation Min Distance.

 DebugDrawAudio.DrawSphere(
     AudioPlayerDeviceTransform.Translation,
     ?Radius:= AttenuationMinDistance,
     ?DrawDurationPolicy:= debug_draw_duration_policy.Persistent)
 DebugDrawAudio.DrawSphere(
     AudioPlayerDeviceTransform.Translation,
     ?Radius:= AttenuationMinDistance + AttenuationFalloffDistance,
     ?DrawDurationPolicy:= debug_draw_duration_policy.Persistent)
In the OnBegin() function of your Verse file, call the DrawAudioDeviceRange() function.

 OnBegin<override>()<suspends>:void=
 DrawAudioDeviceRange(DebugAttenuationMinDistance, DebugAttenuationFalloffDistance)
Build your Verse code. In the Details panel of your Verse device, make sure you set the values for DebugAttenuationMinDistance and DebugAttenuationFalloffDistance. These values should be equivalent to the Attenuation Min Distance and Attenuation FalloffDistance values for your Audio Player Device multiplied by 100.

The Audio Player Device uses meters for Attenuation Min Distance and Attenuation Falloff Distance. Since the Debug Draw API uses centimeters, you must convert the values.

Complete Script

 using { /Fortnite.com/Devices }
 using { /Fortnite.com/Characters }
 using { /Fortnite.com/Playspaces }
 using { /UnrealEngine.com/Temporary/Diagnostics }
 using { /UnrealEngine.com/Temporary/SpatialMath }

 debug_audio_device := class(creative_device):

     @editable
     AudioPlayerDevice:audio_player_device = audio_player_device{}

     @editable
     DebugAttenuationMinDistance:float = 100.0

     @editable
     DebugAttenuationFalloffDistance:float = 100.0

     DebugDrawAudio:debug_draw = debug_draw{Channel := debug_draw_audio}

     OnBegin<override>()<suspends>:void=

         DrawAudioDeviceRange(DebugAttenuationMinDistance, DebugAttenuationFalloffDistance)

     DrawAudioDeviceRange(AttenuationMinDistance:float, AttenuationFalloffDistance:float):void =
         AudioPlayerDeviceTransform:= AudioPlayerDevice.GetTransform()
         DebugDrawAudio.DrawSphere(
             AudioPlayerDeviceTransform.Translation,
             ?Radius:= AttenuationMinDistance,
             ?DrawDurationPolicy:= debug_draw_duration_policy.Persistent)
         DebugDrawAudio.DrawSphere(
             AudioPlayerDeviceTransform.Translation,
             ?Radius:= AttenuationMinDistance + AttenuationFalloffDistance,
             ?DrawDurationPolicy:= debug_draw_duration_policy.Persistent)

An expression is the smallest unit of code that has a result when evaluated. In Verse everything is an expression, which means everything evaluates to a value.

An example is an if ... else expression, which in Verse evaluates to a value that depends on the content of the expression blocks. The following code evaluates to a string value, containing either ‚ÄúBig!‚Äù or ‚ÄúSmall!‚Äù depending on whether MyNumber was greater than 5:

if (MyNumber > 5):
    ‚ÄúBig!‚Äù
else
    ‚ÄúSmall!‚Äù
This means you can use an if ... else directly as input to functions instead of storing a result and using that result as input.

While this example is simple, there are contexts where this becomes more powerful. For example, loops evaluate to arrays of values, so you can quickly create new arrays based on existing ones.

In the following code, MyArray will contain all the values from NumberArray that are less than 5.

MyArray : []int = for(Number := NumberArray, Number < 5):
    Number
Failable Expressions
A failable expression is an expression that may succeed and produce a value, or fail and return no value. Failable expressions can only be executed in a failure context because that context will define what happens in the event that the expression fails.

Examples of failable expressions include indexing into an array because an invalid index will fail, and using operators such as comparing two values. For more on failable expressions in Verse, see Failure.

List of Expressions in Verse
The following table describes the different kinds of expressions in Verse. Follow the links to learn more about each expression.

Expression	Description	Is the Expression Failable?
Literals	A literal is a fixed value in your code, such as a number or a character. In Verse, there are literals for the following types:
logic
int
float
string
option
enum
 
Function Calls	A function call is an expression, and can have two forms: FunctionName() and FunctionName[]. The result type of the function call expression is defined in the function signature. Refer to Function for more details.	Only when the function call has the form FunctionName[], and the function definition has the <decides> specifier.
Comparison	A comparison expression compares two things using one of the comparison operators:
<
>
<=
>=
<>
=
Refer to Operators for more details.

Yes
Assignment	An assignment expression stores a value at a mutable location, such as when initializing a constant or changing the value of a variable. Refer to Variables and Constants for more details.	 
Math	A math expression performs computations using the operators:
+
-
*
/
All of these operators also have assignment variants that can be used with pointers. Refer to Operators for more details.

Only for integer division.
Decision	A decision expression uses the operators not, and, and or to give you control over the success and failure decision flow. Refer to Operators for more details.	Yes
Query	A query expression uses the operator ? and checks whether a logic or option value is true. Otherwise, the expression fails. Refer to Operators for more details.	Yes
Class and Struct Instantiation	Creating an instance of a class or struct is an expression. Refer to Class and Struct.	 
Control Flow	Control flow is the order in which a computer executes instructions. You can use expressions such as if and loop to change that flow. Some control flow expressions, such as loop, only return void and so may not be useful everywhere you can use an expression. The following are control flow expressions in Verse:
if
case
for
loop
sync
race
rush
branch
spawn
Refer to Control Flow for more details.

 
Array	An array is a container where you can store elements of the same type. The elements of an array are in the order you insert them into the array, and you can access the elements by their position in the array, called their index. For more info, see Array.	Only when indexing into an array.
Tuple	A tuple is a container where you can store elements of one or more types. The elements of a tuple are in the order you insert them into the tuple and you can access the elements by their position in the tuple, called their index.. For more info, see Tuple .	 
Map	A map is a container where you can store values associated with another value, called key-value pairs. Key-value pairs can be any combination of types as long as the key type is comparable. The elements of a map are in the order you insert the key-value pairs into the map, and you can access the elements by their unique keys. For more info, see Map	 
Option	An option is a container that can have one or no value of a type. For more info, see Option.	 
Range	Range expressions contain all the numbers between and including the two specified values with .. between, for example 1..5. Range expressions can only be used in some places, such as in for expressions. See Range for more details.

Constants
A constant is a location where a value is stored, and its value cannot change during the runtime of the program.

To create a constant, you have to specify its identifier and type, known as declaring a constant, and provide a value for the constant, known as initializing a constant.

A constant must be initialized when it is declared, and must be declared before it can be used.

Constant creation has the following syntax:

Copy code

Identifier : type = expression
Constants declared in a function can omit the type:

Copy code

Identifier := expression
If the type is omitted, the constant's type is inferred from the expression used to initialize the constant. Only local constants can omit the type because the type describes how the constant can be used. A constant in a module makes up part of the interface of the module that contains it. Without the type, that interface is nonobvious.

In the following example, a random number is generated in each iteration of the loop and used to initialize the constant RandomNumber. The random number will only break out of the loop it is less than twenty.

Copy code

loop:
    Limit := 20 
    # For local constants, the type can be omitted.
    RandomNumber : int = GetRandomNumber() 
    # Providing the type explicitly can make the code easier to read.
    if (RandomNumber < Limit):
        break
Note that in each loop iteration, a new constant named RandomNumber is introduced and assigned the result of GetRandomNumber() as its value.

Variables
In addition to the constants described above, Verse also has variables.

Variables are similar to constants, but are defined with the keyword var, which means you can change their values at any point.

For example,

Copy code

var MaxHealthUpgrade : int = 10
is an integer variable, and its value may not always be 10.

Variable creation has the following syntax:

Copy code

var Identifier : type = expression
Note that the type must be explicitly specified for variables.

After you create a variable, you can assign a different value to it with the following syntax:

Copy code

set Identifier = expression
Aside from =, a variety of other operators can be used to mutate a variable. For example,

Copy code

var X:int = 0
set X += 1
set X *= 2
Global Variables
A global variable in Verse is a variable that is defined at the module scope ‚Äî for example, not in a function or a class. Currently, the only way to declare a global variable in Verse is to use the weak_map(session, t) type where the key type is the type of the current Fortnite island instance, or session, and the value type is any type t. For details on weak_map, see Map.

Since global variables are defined at the module scope, they are accessible by any code that has access to that module.

The following example shows how to create a global integer variable named GlobalInt that is incremented every time ExampleFunction() is called.

Copy code

using { /Verse.org/Simulation } # For session

var GlobalInt:weak_map(session, int) = map{}

ExampleFunction():void=
    X := if (Y := GlobalInt[GetSession()]) then Y + 1 else 0
    if:
        set GlobalInt[GetSession()] = X
    Print("{X}")
Global variables have the following limitations:

You can only access values for the current session you are in, not any other session.
The global variable weak_map cannot be completely read or written to, so it's not possible to read or override values for all sessions.
You cannot iterate through the values of a weak_map or see how many sessions are currently active, because a weak_map has no length.

Verse uses logic as the type for Boolean values, which means logic only has two possible values: true and false.

Both true and false are logic literals when you use them in Verse code.

The following is an example of how to create a logic variable named TargetLocked, initialized with the logic literal false:

Copy code

var TargetLocked : logic = false
Logic Operations
The logic type supports query operations and comparison operations.

Query
Query expressions use the operator ? (query) and check if a logic value is true. Otherwise, the expression fails if the logic value is false.

Copy code

# Determine whether to show the target-locked icon if a target is locked
if (TargetLocked?):
    ShowTargetLockedIcon()
For more on query operations, see Operators.

Comparison
For comparison operations, you can use the failable operator = to test if two logic values are equal, and the failable operator <> to test for inequality.

For example, the sample code below will make an "unavailable action" icon appear if the player has equipped a weapon but doesn't have a target, or has a target but no weapon. This can be expressed by comparing logic values that represent the two factors.

If both are false, you won't see the icon because the player isn't trying to attack.

If both are true, you won't see the icon because the player is able to attack.

Initialize logic variables for demonstration purposes.
var TargetLocked : logic = false
var WeaponEquipped : logic = true

Determine whether or not the "unavailable action" icon is appropriate.
if (WeaponEquipped <> TargetLocked):
# The icon should show up, because the player appears to be trying to
# attack, but is missing either a weapon or a target.
ShowUnavailableIcon()

For more on comparison operations, see Operators.

Convert Failable Expression to Logic
You can cast a failable expression to a logic type using logic{failable-expression}, where failable-expression is an expression that can fail.

In the following example, the failable expression GetRandomInt(0, MineFrequency) <> 0 is converted to the logic value false if the random integer is 0 and true otherwise.

Copy code

IsMined := logic{GetRandomInt(0, MineFrequency) <> 0}
Standard Library
The standard library provides functions to help with creating and using logic values. Refer to the Verse API Reference for more details on these functions.

Verse uses float as the type for storing and handling floating point numbers, such as 1.0, -50.5, and 3.14159.

A float in Verse is an IEEE 64-bit float, which means it can contain a positive or negative number that has a decimal point in the range [-2^1024 + 1, ‚Ä¶ , 0, ‚Ä¶ , 2^1024 - 1], or has the value NaN (Not a Number).

The implementation for float differs from the IEEE standard in the following ways:

There is only one NaN value.
NaN is equal to itself.
Every number is equal to itself. If two numbers are equal, then no pure Verse code can observe the difference between them.
0 cannot be negative.
You can include predefined float values within your code as float literals. A float literal is a floating point number in your code.

The following is an example of how to create a float variable named MaxHealth, initialized with the float literal 100.0:

Copy code

MaxHealth : float = 100.0
Float Operations
Floats support math operations and comparisons with other floats.

Math
You can do the four basic math operations with floats in Verse: + for addition, - for subtraction, * for multiplication, and / for division.

There are also combined operators for doing the basic math operations (addition, subtraction, multiplication, and division), and updating the dereferenced value of a pointer. These combined operators are the same as assigning the result to the first operand of the math operation.

For example, the following code instantly halves the value of CurrentHealth:

Copy code

# Start with the original health value
var CurrentHealth : float = 75.0
	
# Reduce it to half
set CurrentHealth *= 0.5
	
# CurrentHealth is now 37.5.
Signed Floating Point Numbers
A signed float is a value that can be positive, or negative, or zero. The operator - can be used to negate a float if - appears before the float, for example -3.2. You can also use the operator + before a float to help align your code visually, but it won‚Äôt change the value of the float. In the following code, a "life drain" attack heals the attacker for one eighth of the damage inflicted on the target.

Copy code

# Set up the parameters that describe the situation
DamageInflicted : float = 10.0
LifeDrainMultiplier : float = 0.125
var CurrentAttackerHealth : float = 99.0
	
# Increase current health based on damage inflicted.
set CurrentAttackerHealth += DamageInflicted * HealingMultiplier
	
# CurrentAttackerHealth is now 100.25.
Comparison
You can use the failable operator = to test if two floats are equal, and the failable operator <> to test for inequality.

Since numbers are ordered, you can use the failable operator < to test if one float is less than another float, and the failable operator > to test if one float is greater than another float.

You can use the failable operator <= to test if one float is less than or equal to another float, and the failable operator >= to test if one float is greater than or equal to another float.

NaN is comparable like other floats, and NaN is larger than all other floats and equal to itself.

Copy code

# Set up the parameters that describe the situation
DamageInflicted : float = 10.0
LifeDrainMultiplier : float = 0.125
var CurrentAttackerHealth : float = 99.0
MaxAttackerHealth : float = 100.0
	
# Increase current health based on damage inflicted.
set CurrentAttackerHealth += DamageInflicted * HealingMultiplier
	
# Ensure that the attacker does not heal beyond their maximum health
if (CurrentAttackerHealth > MaxAttackerHealth):
    # Too high! Reduce to the maximum value.
    set CurrentAttackerHealth = MaxAttackerHealth
	
# CurrentAttackerHealth is now 100.0.
Standard Library
The standard library provides functions to help with creating and using floats, and common math structures and functions. Refer to the Verse API Reference for more details on these functions.

Verse uses string as the type for storing and handling text, such as "Hello Verse" and "Epic Games". In Verse, a string can contain letters, numbers, punctuation, spaces, and emojis. A string containing no characters "" is called an empty string.

You can include predefined string values within your code as string literals. A string literal is a sequence of characters in your code surrounded by double quotation marks " ".

The following is an example of how to create a string variable named Hello, and initialized with the string literal "Hello world":

Hello : string = "Hello world"
Character Encoding
Character encoding is the mapping between a text character and data that the computer can understand, called a code point.

Verse uses the UTF-8 Unicode character-encoding scheme, a standard developed by the Unicode Consortium to provide comparable support for characters across languages, platforms, and devices.

For example, the emoji in this string "üêà" can also be represented by the emoji‚Äôs Unicode code point "{0u1f408}". For a full list of characters supported in Unicode and their corresponding code points, refer to the Unicode documentation.

The UTF-8 code unit is 8-bits (one byte), and encodes characters with code points that are one to four bytes long. Code points with a lower value use fewer bytes than code points with higher values. For example, "a" uses one byte "{0o61}", while "√°" uses two bytes "{0oC3}{0oA1}".

String Operations
Strings support concatenation, comparison, indexing, getting the length of the string, and string interpolation.

Concatenation
Concatenation is when one string is appended to another string. You can use the operator + to concatenate strings.

For example, the following code results in the variable Announcement containing the string "...And the winner is: Player One!".

# The winning player's name:
WinningPlayerName : string = "Player One"
# Build a message announcing the winner.
Announcement : string = "...And the winner is: " + WinningPlayerName + "!"
String Interpolation
You can inject a value into a string if it has a valid ToString() function defined in the current scope.

For example, the following code results in the variable Announcement containing the string "...And the winner is: Player One!".

# The winning player's name:
WinningPlayerName : string = "Player One"
# Build a message announcing the winner.
Announcement : string = "...And the winner is: {WinningPlayerName}!"
Comparison
Whether two strings are equal depends on whether they use the same characters.

Comparison of strings in Verse is done by comparing the code points of each character. Comparison of two strings is case sensitive, because uppercase and lowercase characters have different code points.

You can use the failable operator = to test if two strings are equal, and the failable operator <> to test for inequality.

There can be multiple ways to represent the same character in Unicode. For example, "√©" is "{0u0049}", but you can also use two code points: "{0u0065}", which is "e", and "{0u0301}", which is a combining accent. This means that if you compare these strings, which both appear to be the character "√©" but the strings use different code points, the strings will not be equal. "{0u0049}" is not the same as "{0u0065}{0u0301}".

The following example would check to see if the player has used the correct item to make progress in an adventure/puzzle game:

# This is the item the puzzle requires to unlock the next step:
ExpectedItemInternalName : string = "RedPotion"
# This is the item that the player has selected:
SelectedItemInternalName : string = "BluePotion"
	
# Check to see if the player has the right item selected.
if (SelectedItemInternalName = ExpectedItemInternalName):
    # They do! Report that the puzzle can proceed to the next step.
    return true

# They do not. Report that this item does not advance the puzzle.
return false
Length
You can get the number of UTF-8 code units in a string by accessing the member Length on the string. For example, "hey".Length is 3.

The length of a string accounts for the amount of data it takes to represent the string in UTF-8 code units. For example, "h√©y".Length is 4, because it takes an extra UTF-8 code unit to represent the character √©, even though the string appears to have three characters. The following code displays a "seconds" timer with two digits. It will pad the display with a leading zero if needed.

# SecondsRemaining is assumed to be non-negative
SecondsRemaining : int = 30
	
# Automatically convert the int representation to a string:
SecondsString:string = SecondsRemaining

# Set up the timer display string.
var Combined : string = "Time Remaining: "
	
# If the string is too long, replace it the maximum two-digit value, 99.
if (SecondsString.Length > 2):
    # Too much time on the clock! Set the string to a hard-coded max value.
    set Combined += "99"
else if (SecondsString.Length < 2):
    # Pad the display with a leading zero.
    set Combined += "0{SecondsString}"
else:
    # The string is already the exact length, so add it.
    set Combined += SecondsString
Index
You can access the UTF-8 code unit at a specific index of the string. The first UTF-8 code unit in a string has an index of 0, and each subsequent code unit index increases in number.

For example, "cat"[0] is "c" and "cat"[1] is "a".

Index	0	1	2
Character	"c"	"a"	"t"
Code Unit	"{0o63}"	"{0o61}"	"{0o74}"
In cases where a string has characters that are represented by more than one code unit, there will be an index for each code unit. For example, "√°" is represented by two UTF-8 code units "{0oC3}{0oA1}", so "c√°t"[1] is "{0oC3}" and "c√°t"[2] is "{0oA1}".

Index	0	1	2	3
Character	"c"	"√°"	 	"t"
Code Unit	"{0o63}"	"{0oC3}"	"{0oA1}"	"{0o74}"
The last index in a string is one less than the length of the string. For example, "cat".Length is 3 and the index for "t" in "cat" is 2.

Standard Library
The standard library provides functions to help with creating and using strings. Refer to the Verse API Reference for more details on these functions.

Alternate Representations of Characters
Some characters have alternate representations when they‚Äôre used in a string. For example, "{}" can be used for string interpolation or for the code points of characters, but they can also be used as the brace characters {} themselves in text.

To be able to use an alternate representation of a character in a string, you must add the escape character "\" before the character in the string. For example, "\{\}" is rendered as {} in text, and "\n" starts a new line in text.

Implementation Details
The string type is a type alias of []char, an array of UTF-8 code units. Because string is a type alias for an array, string has the same behavior as arrays.

There are two primitive types for characters, depending on their size and code point format ‚Äî char and char32. The only capabilities of char and char32 in Verse are for comparison, and to access their values.

Primitive Type	Description	Supported Formats
char	A primitive type that represents a single UTF-8 code unit (one byte), up to the value 256 (0off).	Code units of the form 0oXX. For example, 0o52.
char32	A primitive type that represents a Unicode code point.	Code points of the form 0uXXXX. For example, 0u0041.
You can also express literals with single quotes. Whether the primitive type of the string in single quotes is char or char32 depends on the UTF-8 code units used for the character. For example, 'e' is char, and '√©' is char32.

Three major numeric types are supported in Verse: int, used for integers, float, used for floating-point numbers, and rational, used for rational numbers.

The operations supported for the rational type are currently limited to these built-in operations:

Copy code

Ceil(:rational):int

Floor(:rational):int
However, rational will likely show up often in error messages. For example:

Copy code

Z:int = X / Y
This will fail the type checker with a message that indicates that rational is not a subtype of int.

See Int for more information on math operations and rational types.

Verse has a special type, any, that is the supertype of all types (all other types are subtypes of any). Because of this, any supports very few operations, as all other types must be able to provide the same functionality that any provides.

For example, if any were to define a comparison operation (which it doesn't), then all other types would also have to define a comparison operation (which they don't).

There is very little that you can do with an any type. but it's good to be aware of this type as it may come up when writing code that produces an error.

But there are ways that you can use any:

Copy code

Letters := enum:
    A
    B
    C

letter := class:
    Value : char

    Main(Arg : int) : void =
        X := if (Arg > 0)
            Letters.A
        else
            letter{Value := 'D'}
In the code example above, X is given the type any, as that is the lowest supertype of both Letters and letter.

More usefully, any can be used as the type for a parameter to a function that is ignored (but might be required as an argument for a method of an implemented interface).

For example:

Copy code

FirstInt(X:int, :any) : int = X
The second argument to FirstInt is ignored, and can be of any type, so it is given the any type. FirstInt can be more generally written using parametric types. For example:

Copy code

First(X:t, :any where t:type) : t = X

The comparable type is used to compare values of this type to other values of the same type.

The = and <> operators make use of this type to define their signatures.

Copy code

operator'='(:t, :comparable where t:subtype(comparable)):t
operator'<>'(:t, :comparable where t:subtype(comparable)):t
Each of these functions is defined as taking a first argument that is an arbitrary subtype of comparable and a second argument that is also an arbitrary subtype, and that returns the same type as the first argument.

The comparable type has many subtypes that you can use. These subtypes can be compared both with other values of the same type type, and other subtypes of comparable. These subtypes include:

int
logic
float
char
char32
array if all contained types are subtypes of comparable
option if all contained types are subtypes of comparable
tuple if all contained types are subtypes of comparable
map if all contained types are subtypes of comparable
Classes can also be made to be subtypes of comparable with the unique specifier. Instances of classes with this specifier are only equal to themselves, even if the contained members are equal. For example:

Copy code

int_ref := class<unique>:
    Contents:int

Main()<decides> : void =
    X := int_ref{Contents := 0}
    Y := int_ref{Contents := 0}
    X = X # Succeeds
    X = Y # Fails
    X <> Y # Succeeds
Currently float, option, and classes (regardless of the presence of unique) cannot be used as keys of maps, meaning map keys are required to be a subtype of comparable that is not given a name (and therefore, map key types cannot be parametric types, as the required subtyping cannot be described in Verse code).

Note that because a value of a subtype of comparable can be compared to any other value of another subtype of comparable, some unexpected results can occur. For example:

Copy code

0 = 0.0

In addition to the standard types in Verse, there are some additional constructs that can be used the way you would use a type, but that technically are not types. void is one such construct.

When used as the result of a function, it indicates that the function can return any value, but when invoked, it will provide no particular result of interest.

For example:

Copy code

Foo() : void = {}
In this example, Foo won't have a result that is useful. Specifically, its result type is true, which has the single inhabiting unit value false. void can also be used as the type for constants or function parameters, similarly indicating that the value can't be used for anything useful. In this way, a void constant or function parameter is similar in purpose to an any function parameter.

For example:

Copy code

FirstInt(X:int, :void) : int = X
Technically, void can be thought of as a function defined as

Copy code

void(:any) : true
When used as a type, you can think of it as being applied to whatever is assigned to the corresponding typed identifier.

Using a function in a type position is only allowed for a void function. Functions used in this way are known as functors.

Grouping expressions is a way to specify order of evaluation, which is useful if you need to work around operator precedence.

You can group expressions by using ().

For example, the expressions (y2 - y1) and (x2 - x1) below are evaluated before dividing the numbers.

Copy code

(y2 - y1) / (x2 - x1)
As an example, take an in-game explosion that scales its damage based on the distance from the player, but where the player's armor can reduce the total damage:

Copy code

BaseDamage : float = 100
Armor : float = 15

# Scale by square distance between the player and the explosion. 1.0 is the minimum
DistanceScaling : float = Max(1.0, Pow(PlayerDistance, 2.0))

# The farther the explosion is, the less damage the player takes
var ExplosionDamage : float = BaseDamage / DistanceScaling

# Reduce the damage by armor
set ExplosionDamage -= Armor 

# Avoid negative damage values so that explosions can't heal very high armor players.
set ExplosionDamage = Max(0.0, ExplosionDamage)
Using grouping, you could rewrite the example above as:

Copy code

BaseDamage : float = 100
Armor : float = 15
DistanceScaling : float = Max(1.0, Pow(PlayerDistance, 2.0))
ExplosionDamage : float = Max(0.0, (BaseDamage / DistanceScaling) - Armor)


A code block, or block, is a group of zero or more expressions that introduces a new scoped body. (A block with zero expressions would be an empty block, and ideally would only be used as a placeholder to be filled in later.)

Code blocks can only appear after identifiers.

Scope refers to the part of the program where the association of an identifier (name) to a value is valid, and where that name can be used to refer to the value. For example, any constants or variables that you create within a code block only exist in the context of the code block. This means that the lifetime of objects is limited to the scope they're created in and they cannot be used outside of that code block.

The following example shows how to calculate the maximum number of arrows that can be bought with the number of coins the player has. The constant MaxArrowsYouCanBuy is created within the if block and therefore its scope is limited to the if block. When the constant MaxArrowsYouCanBuy is used in the print string, it produces an error because the name MaxArrowsYouCanBuy doesn't exist in the scope outside of the if expression.

Copy code

CoinsPerQuiver : int = 100
ArrowsPerQuiver : int = 15
var Coins : int = 225

if (MaxQuiversYouCanBuy : int = Floor(Coins / CoinsPerQuiver)):
    MaxArrowsYouCanBuy : int = MaxQuiversYouCanBuy * ArrowsPerQuiver

Print("You can buy at most {MaxArrowsYouCanBuy} arrows with your coins.") # Error: Unknown identifier MaxArrowsYouCanBuy
Verse doesn't support reusing an identifier even if it's declared in a different scope, unless you can qualify the identifier by adding (qualifying_scope:) before the identifier, where qualifying_scope is the name of an identifier's module, class, or interface. Whenever you define and use the identifier, you must also add a qualifier to the identifier.

For more details, see module, class, and interface.

Code Block Formats
Code blocks have three possible formats in Verse. They are all semantically equivalent, so you can change the style of a code block without changing what it does.

If you nest a code block inside of another code block, you must still use an identifier at the beginning of the nested code block. To nest code, use the block expression.

Spaced Format
With this format, the block begins with :, with each expression that follows on its own line. Each line is uniformly indented four spaces.

Copy code

if (test-arg-block):
    expression1
    expression2
Note that if (test-arg-block) is not part of the block, but the block starts at the end of that line with :.

You can also use ; to separate multiple expressions on a single line.

Multi-Line Braced Format
The block is enclosed by {}, and expressions are on new lines.

Copy code

if (test-arg-block)
{
    expression1
    expression2
}
You can also use ; to separate multiple expressions on a single line.

Single-Line Dot Format
With this format, the block begins with . with each expression on the same line, and each expression is separated by ; instead of being placed on a new line.

Copy code

if (test-arg-block). expression1; expression2
If you use the single-line dot format in an if expression that has an else, then you can only have one expression before the else. For example:

Copy code

if (test-arg-block). expression1 else. expression2

Failure is control flow in Verse.

Unlike other programming languages that use the Boolean values true and false to change the flow of a program, Verse uses expressions that can either succeed or fail. These expressions are called failable expressions, and can only be executed in a failure context.

Using failure for control flow means that work doesn‚Äôt have to be duplicated, and that you can avoid subtle errors.

For example, in other languages, you have to check that an index for an array is valid before accessing the array element at that index, which is a common cause of errors in other languages.

In Verse, validation and access are combined to avoid this.

For example:

Copy code

    if (Element := MyArray[Index]):
        Log(Element)
Failable Expression
A failable expression is an expression that can either succeed and produce a value, or fail and return no value. Examples of failable expressions include indexing into an array because an invalid index will fail, and using operators such as comparing two values.

Code that you write isn‚Äôt failable by default. For example, to write a function that can fail, you must add the effect specifier <decides> to the function definition. Currently it is also necessary to add <transacts> when using <decides>.

For a full list of expressions that are failable, refer to the list of Expressions in Verse.

Failure Context
A failure context is a context where it is allowable to execute failable expressions. The context defines what happens if the expression fails. Any failure within a failure context will cause the entire context to fail.

A failure context allows nested expressions to be failure expressions, such as function arguments or expressions in a block expression.

A useful aspect of failure contexts in Verse is that they are a form of speculative execution, meaning that you can try out actions without committing them. When an expression succeeds, the effects of the expression are committed, such as changing the value of a variable. If the expression fails, the effects of the expression are rolled back, as though the expression never happened.

This way, you can execute a series of actions that accumulate changes, but those actions will be undone if they fail anywhere.

To make this work, all functions called in the failure context must have the effect specifier <transacts>, and the compiler will complain if they don't.

User-defined functions do not have the transacts effect by default. An explicit <transacts> specifier must be added to their definitions. Some native functions also do not have the transacts effect and can't be called in failure contexts.

An example of a native function without transacts could be an audio_component with a BeginSound() method. If the sound is started then even if it is stopped it could have been noticed.

The following list includes all of the failure contexts in Verse:

The condition in if expressions.

Copy code

if (test-arg-block) { ‚Ä¶ }
The iteration expressions and filter expressions in for expressions. Note that for is special in that it creates a failure context for each iteration. If iterations are nested, then the failure contexts will also be nested. When an expression fails, the innermost failure context is aborted, and the enclosing iteration, if any, continues with the next iteration.

Copy code

for (Item : Collection, test-arg-block) { ‚Ä¶ }
The body of a function or method that has the <decides> effect specifier.

Copy code

IsEqual()<decides><transacts> : void = { ‚Ä¶ }
The operand for the not operator.

Copy code

not expression
The left operand for or.

Copy code

expression1 or expression2
Initializing a variable that has the option type.

Copy code

option{expression}


Specifiers in Verse describe behavior related to semantics, and can be added to identifiers and certain keywords. Specifier syntax uses < and >, with the keyword in between, such as IsPuzzleSolved()<decides><transacts> : void.

Attributes in Verse describe behavior that is used outside of the Verse language (unlike specifiers, which describe Verse semantics). Attribute syntax uses @ followed by the keyword, such as @editable.

The following sections describe all of the specifiers and attributes in Verse and when you can use them.

Effect Specifiers
Effects in Verse indicate categories of behavior that a function is allowed to exhibit. You can add effect specifiers to:

The () after the name in a function definition: name()<specifier> : type = codeblock.
The class keyword: name := class<specifier>():.
Effect specifiers are divided into two categories:

Exclusive: You can have only one or none of the exclusive effect specifiers added to a function, or to the class keyword. If no exclusive effect specifier is added, the default effect is no_rollback.
Additive: You can add all, some, or none of the additive effect specifiers to a function or the class keyword.

Click image to enlarge.

Example	Effect
name() : type = codeblock
no_rollback: This is the default effect when no exclusive effect is specified. The no_rollback effect indicates that any actions performed by the function cannot be undone and so the function cannot be used in a failure context. This effect cannot be manually specified.

Exclusive Effects	 
name()<transacts> : type = codeblock
transacts: This effect indicates that any actions performed by the function can be rolled back. The transacts effect is required any time a mutable variable (var) is written. You‚Äôll be notified when you compile your code if the transacts effect was added to a function that can‚Äôt be rolled back. Note that this check is not done for functions with the native specifier.

name()<varies> : type = codeblock
varies: This effect indicates that the same input to the function may not always produce the same output. The varies effect also indicates that the behavior of the function is not guaranteed to stay the same with new versions of its containing package.

name()<computes> : type = codeblock
computes: This effect requires that the function has no side effects, and is not guaranteed to complete. There‚Äôs an unchecked requirement that the function, when provided with the same arguments, produces the same result. Any function that doesn‚Äôt have the native specifier that would otherwise have the converges effect is a good example of using the computes effect.

name()<converges> : type = codeblock
converges: This effect guarantees that not only is there no side effect from the execution of the related function, but that the function definitely completes (does not infinitely recurse). This effect can only appear in functions that have the native specifer, but this isn‚Äôt checked by the compiler. Code that is used to provide default values of class or values for global variables are required to have this effect.

Additive Effects	 
name()<transacts><decides> : type = codeblock
decides: Indicates that the function can fail, and that calling this function is a failable expression. Function definitions with the decides effect must also have the transacts effect, which means the actions performed by this function can be rolled back (as if the actions were never performed), if there‚Äôs a failure anywhere in the function.

name()<suspends> : type = codeblock
suspends: Indicates that the function is async. Creates an async context for the body of the function.

In all cases, calling a function that has a specific effect will require the caller to have that effect as well.

Access Specifiers
Access specifiers define what can interact with a member and how. Access specifiers can be applied to the following:

The identifier for a member: name<specifier> : type = value
The keyword var for a member: var<specifier> name : type = value
name<public> : type = value
Public: The identifier is universally accessible. You can use this specifier on:

module
class
interface
struct
enum
method
data
name<protected> : type = value
Protected: The identifier can only be accessed by the current class and any subtypes. You can use this specifier on:

class
interface
struct
enum
non-module method
data
name<private> : type = value
Private: The identifier can only be accessed in the current, immediately enclosing, scope (be it a module, class, struct, etc.). You can use this specifier on:

class
interface
struct
enum
non-module method
data
name<internal> : type = value
Internal: The identifier can only be accessed in the current immediately enclosing, module. This is the default access level. You can use this specifier on:

module
class
interface
struct
enum
method
data
Class Specifiers
Class specifiers define certain characteristics of classes or their members, such as whether you can create a subclass of a class.

pet := class<abstract>():
    Speak() : void

cat := class(pet):
    Speak() : void = {}
abstract: When a class or a class method has the abstract specifier, you cannot create an instance of the class. Abstract classes are intended to be used as a superclass with partial implementation or as a common interface. This is useful when it doesn't make sense to have instances of a superclass but you don't want to duplicate properties and behaviors across similar classes.

cat := class<concrete>():
     # field must be initialized because the class is concrete
    Name : string = "Cat"
concrete: When a class has the concrete specifier, it must be possible to construct it with an empty archetype, which means that every field of the class must have a default value. Every subclass of a concrete class is implicitly concrete. A concrete class can only inherit directly from an abstract class if both classes are defined in the same module.

unique_class := class<unique>:
    Field : int

Main()<decides> : void =
    X := unique_class{Field := 1}
    X = X # X is equal to itself
    Y := unique_class{Field := 1}
    X <> Y # X and Y are unique and therefore not equal
unique: The unique specifier can be applied to a class to make it a unique class. To construct an instance of a unique class, Verse allocates a unique identity for the resulting instance. This allows instances of unique classes to be compared for equality by comparing their identities. Classes without the unique specifier don't have any such identity, and so can only be compared for equality based on the values of their fields. This means that unique classes can be compared with the = and <> operators, and are subtypes of the comparable type.

cat := class<final>():
final: You can only use the final specifier on classes and members of classes:

When a class has the final specifier, you cannot create a subclass of the class.
When a field has the final specifier, you cannot override the field in a subclass.
When a method has the final specifier, you cannot override the method in a subclass.
pets := module:
    cat<public> := class<public>:
        Sound<public> : string = "Meow"

MakeCat():void =
    # cat is successfully constructed outside of its module
    MyNewCat := pets.cat{}
public: When a class has the public specifier, anyone can construct an instance of that class, even outside of the module where the class was defined.

pets := module:
    cat<public> := class<internal>:
        Sound<public> : string = "Meow"

GetCatSound(InCat:pets.cat):string =
    return InCat.Sound # Valid: References the cat class but does not call its constructor

MakeCat():void =
    MyNewCat := pets.cat{} # Error: Invalid access of internal class constructor
internal: When a class has the internal specifier, you can only call its constructor within the same module or submodules.

Implementation Specifiers
It's not possible to use implementation specifiers when writing code, but you will see them when looking at the UEFN APIs.

GetCreativeObjectsWithTag<native><public>(Tag:tag)<transacts>:[]creative_object_interface
native: Indicates that the definition details of the element are implemented in C++. Verse definitions with the native specifier auto-generate C++ definitions. A Verse developer can then fill out its implementation. You can see this specifier used on:

class
interface
enum
method
data
creative_device<native><public> := class<concrete>:
    OnBegin<public>()<suspends>:void = external {}

    OnEnd<native_callable><public>():void = external {}
native_callable: Indicates that an instance method is both native (implemented in C++) and may be called by other C++ code. You can see this specifier used on an instance method. This specifier doesn‚Äôt propagate to subclasses and so you don‚Äôt need to add it to a definition when overriding a method that has this specifier

Attributes
Attributes in Verse describe behavior that is used outside of the Verse language (unlike specifiers, which describe Verse semantics). Attributes can be added on the line of code before definitions.

Attribute syntax uses @ followed by the keyword.

@editable
Platform : color_changing_tiles_device = color_changing_tiles_device{}
editable: Indicates this field is an exposed property that can be changed directly from UEFN so you don't need to modify the Verse code to change its value. For more details, see Customize Device Properties.

Since Verse requires an identifier before a code block, block expressions are how you nest code blocks, and block expressions behave similarly to code blocks.

As with code blocks, block introduces a new nested scope body, constraining the lifetimes of any variables created in the block in a way that they cannot be used outside of the block.

Copy code

expression0
block:
    expression1
    expression2
expression3
Unless there is an early exit, the block expression uses the last expression executed in the block as its result. For example, if the last expression in the block is Example : int = 6 then the block expression has 6 as a result.

With the if expression, you can make decisions that change the flow of the program. As with other programming languages, the Verse if expression supports conditional execution, but in Verse, the conditions use success and failure to drive the decision.

For example, you can write code that defines the fall height a player can drop before taking damage.

var PlayerFallHeight : float = CalculatePlayerFallHeight()

# Players take damage if they fall more than 3 meters
if (PlayerFallHeight > 3.0):
    DealDamage()

# Reset the player‚Äôs fall height
ZeroPlayerFallHeight()
In this example, if PlayerFallHeight is greater than three meters, then the condition succeeds and DealDamage() is executed before the player‚Äôs fall height is reset. Otherwise, the condition fails so the player doesn‚Äôt take any damage but the player‚Äôs fall height is reset.

if
The player fall height example would use the following syntax:

expression0
if (test-arg-block):
    expression1
expression2
After executing expression0, the Verse program enters the if-block. If the test-arg-block succeeds, then the Verse program executes expression1, which can be one expression or a block of expressions. Otherwise, if the test-arg-block fails, the Verse program skips expression1 and only executes expression2.

Diagram of how if expressions work with the example of fall height
Flow diagram for if-block logic.

if ... else
You can also specify an expression to execute when the if expression fails.

For example, the player should gain a double-jump ability if they fall less than three meters and if their jump meter is at 100 percent. But if they fall more than three meters or their jump meter isn‚Äôt at 100 percent, then the character‚Äôs arms will flap to let the player know they cannot double jump.

    var PlayerFallHeight : float = CalculatePlayerFallHeight()

    if (PlayerFallHeight < 3.0 and JumpMeter = 100):
    # Perform a double jump.
        ActivateDoubleJump()
    # Reset the player‚Äôs fall height.
        ZeroPlayerFallHeight()
    else:
    # Flap the character‚Äôs arms to tell the player they
    # cannot double jump right now!
        ActivateFlapArmsAnimation()

    # Set the double-jump cooldown so rapidly pressing Jump does
    # not cause the "flap arms" animation to play inappropriately.
    SetDoubleJumpCooldown()
In this example, the condition of if evaluates whether PlayerFallHeight is less than three meters and if JumpMeter is equal to 100 percent. If the condition succeeds, ActivateDoubleJump() and ZeroPlayerFallHeight() are executed before SetDoubleJumpCooldown().

If the if condition fails, then the expression ActivateFlapArmsAnimation() following else is executed before SetDoubleJumpCooldown().

Syntactically, the if-else example looks like this:

expression0
if (test-arg-block):
    expression1
else:
    expression2
expression3
Example of how if/else expressions work using logic for jumping and fall heights
Flow diagram for if-else-block logic.

if ... else if ... else
If a player has 100 percent shields when they fall more than three meters, they should take maximal damage but still survive. And let‚Äôs modify the rule that gives players a double-jump ability, such that players will only gain double-jump if they fall less than three meters and if their jump meter is greater than 75 percent.

    var PlayerFallHeight : float = CalculatePlayerFallHeight()

    if (PlayerFallHeight > 3.0 and shields = 100):
        DealMaximalDamage()
        return false
    else if (PlayerFallHeight < 3.0 and JumpMeter > 75):
        ActivateDoubleJump()
        return false
    else:
        return true

    # Reset the player‚Äôs fall height
    ZeroPlayerFallHeight()
Syntactically, the if-else if-else example looks like this:

    expression0

    if (test-arg-block0):
        expression1
    else if (test-arg-block1):
        expression2
    else:
        expression3
    expression4
An example of if/else if/else expression in Verse using shield and jumping variables
Flow diagram for if-else if-else-block logic.

if ... then
You can write any of the if conditions in the previous examples on multiple lines without changing how they work:

expression0
if:
	test-arg-block
then:
    expression1
expression2
The code block test-arg-block can contain one or more lines of conditions but they must all succeed to execute expression1 before expression2, otherwise only expression2 will be executed.

The example from the if ... else section rewritten in this format looks like:

var PlayerFallHeight : float = CalculatePlayerFallHeight()

if:
    PlayerFallHeight < 3.0
    JumpMeter = 100
then:
    # Perform a double jump.
    ActivateDoubleJump()
    # Reset the player‚Äôs fall height.
    ZeroPlayerFallHeight()
else:
    # Flap the character‚Äôs arms to tell the player they
    # cannot double jump right now!
    ActivateFlapArmsAnimation()

# Set the double-jump cooldown so rapidly pressing Jump does
# not cause the "flap arms" animation to play inappropriately.	
SetDoubleJumpCooldown()
Single-Line Expression
You can write an if else as a single-line expression, similar to ternary operators in other programming languages. For example, if you want to assign a maximum or minimum Recharge value based on a player‚Äôs ShieldLevel, you can write the following Verse code:

Recharge : int = if(ShieldLevel < 50) then GetMaxRecharge() else GetMinRecharge()
Predicate Requirements
The predicate of the if, which is the expression between the parentheses (), is unlike other programming languages, in that it is not expected to return a Boolean (called logic in Verse). Instead, the predicate is expected to have the decides effect (note that though subtyping normally allows for a subset of effects in places allowing a set of effects, if requires the overall effect of the predicate to include decides). The effect is removed from the surrounding scope. That is to say, the decides effect from all operations in the if predicate is consumed by the if construct. For example, in the code below, Main does not have the decides effect, though it invokes Foo, which does.

Foo()<transacts><decides> : void = {}

Bar() : void = {}

Main() : void =
    if (Foo[]):
        Bar()
This is because, rather than using a logic input to if to choose which branch is taken, the success of the operations contained in the predicate of the if is used to decide the appropriate branch - the then branch if all operations succeed, the else branch (if present) if any operations fail. Note that this means arbitrary operations can be used in the if predicate, including introducing constants. For example:

Main(X : int) : void =
    Y = array{1, 2, 3}
    if:
        Z0 := Y[X]
        Z1 := Y[X + 1]
    then:
        Use(Z0)
        Use(Z1)
Put another way, the scope of the then branch includes any names introduced in the if predicate.

Transactional Behavior
Another deviation of if with respect to other programming languages is the transactional behavior of the predicate to if. The predicate to if must not have the no_rollback effect (implicitly used by all functions that do not explicitly specify transacts, varies, or computes). This is because in the event the predicate fails, all operations taken during the execution of the predicate (short of any operation impacting resources outside of the runtime, such as file I/O, or writing to console) are undone before execution of the else branch. For example:

int_ref := class:
    var Contents : int

    Incr(X : int_ref)<transacts> : void =
        set X.Contents += 1

Foo(X : int) : int =
    Y := int_ref{Contents := 0}
    if:
        Incr(Y)
        X > 0
    then:
        Y.Contents
    else:
        Y.Contents
The function Foo(-1) will return 0, while Foo(1) will return 1. This is because, though the call to Incr occurs before the test of X > 0, the mutation of Y it causes is undone before execution of the else branch. Note that Incr had to manually specify the transacts effect. By default, transactional behavior is not provided, indicated by the implicit no_rollback effect, but it can be added by specifying the transacts effect manually (overriding the implicit no_rollback effect).


With case expressions, you can control the flow of a program from a list of choices. The case statement in Verse is a way to test one value against multiple possible values (as though you were using =), and running code based on which one matches.

The use of case expressions can be found in all kinds of applications, like in games where there is a non-playable character (NPC).

For example, let's say you use the Guard Spawner device to spawn a guard with its patrol option enabled. After the guard spawns into the game, it has a few possible active states, including Idle, Patrol, Alert, Attack, and Harvest. A high-level state-transition diagram for this could look like:

In-game state transition in Verse
You can observe these state transitions in-game.

Example of Guard states in-game
In this video, the guard has its patrol option enabled as the default behavior.

In the video, the guard transitions from patrolling the science base to harvesting some resources. Then the guard spots the player, which sends the guard into an alert state (indicated by the hovering question mark) before entering its attack state (indicated by the hovering exclamation mark).

Depending on the state the guard is in, it will exhibit certain behaviors, and these behaviors are typically coded as functions that are called when the program chooses to enter a specific state.

As code, this high-level guard-state transition could look like this:

    case(GuardStateVariable):
        idle_state =>
            RunIdleAnimation()
            SearchPlayerCharacter()
        harvest_state =>
            GatherResources()
        alert_state=>
            RunAlertAnimation()
            PlayAlertSound()
            DisplayAlertUIElement()
            TargetPlayerCharacter()
        attack_state =>
            RunAttackAnimation()
            DisplayAttackUIElement()
            TargetPlayerCharacter()
            AttackPlayerCharacter()
        _ =>
            RunPatrolAnimation()
            SearchPlayerCharacter()
            SearchResources()
This case expression passes a label that tells the program which functions to run if the guard enters a specific state.

In this expression, the guard's patrol_state is the default case because a guard with patrol enabled should run its default patrol behavior.

Syntactically, this is the same as:

    expression0
    case (test-arg-block):
    label1 =>
        expression1
    label2 =>
        expression2
    _ =>
        expression3 for the default case
    expression4
Case flow diagram in Verse
Each pattern in the case block, such as label1 and label2, must use the form constant => block, where the constant can be an integer, logic, string, char, or enum constant. So case statements only work with in, logic, string, char, and enums.

Structure
Structurally, the Verse case expression runs code based on input of the GuardStateVariable test argument block, and it functionally works the same as a series of if expressions.

Example of running expression3, the alert_state
In this example, the Verse program runs expression3 if GuardStateVariable resolves to alert_state. If the program passes in patrol_state, Verse structurally jumps to the default case, and runs expression5.

Example of running the default state, expression5
Using Case with Other Control Flow
The blocks in a case statement are allowed to break and continue if the case statement is inside of a loop. Blocks of case statements are also allowed to return from the function they are in.

For example:

    loop:
        case (x):
            42 => break
            _ => {}
This absurd loop will either complete immediately if x = 42 or loop forever.

Another example:

    Foo(x : int) : int =
        case (x):
            100 => return 200
            _ => return 100
This example is equivalent to:

    Foo(x : int) : int =
        case (x):
            100 => 200
            _ => 100
This is because the case statement is the last expression of the function.

Default Case
Case statements that do not have a _=> case (a default case) will fail if none of the cases match. It's fine to use such case statements in failure contexts (such as functions with the decides effect).

Case statements that match all of the cases of an enumeration will be non-failing even if they do not have a _=> case.


With the loop expression, the expressions in the loop block are repeated for every iteration of the loop.

The GIF below of the Fortnite Emote Clean Sweep is an example of how a loop works. The GIF plays to the end, then repeats from the beginning, and the player emoting is like the expressions in a loop block.

Copy code

    # GIF
    loop:
        DoCleanSweepEmote()
Like a GIF, a loop block will repeat forever unless instructed to do otherwise. This is called an infinite loop.

Infinite loops are not very useful in most cases since they will block progress for the program, so Verse provides a way to end and / or suspend.

End: You can end a loop by exiting with either break or return.
Suspend: You can suspend a loop if it's used in an async expression. See Concurrency Overview for more details.
It's also possible to do both in the same loop. In this example, the loop block repeats until the random number that's generated is less than twenty.

Copy code

    loop:
        # generate random number
        RandomNumber : int = GetRandomInt(0, 100)
        # check if random number is less than twenty
        if (RandomNumber < 20):
            # exit loop
            break
Syntactically, this is the same as:

Copy code

    expression0
    loop:
        expression-block
        if (test-arg-block):
            break
        expression-block
    expression2
Unlike some of the other control flow expressions, the loop expression returns void, so it may not be useful in cases where you want an expression to return a result. If the loop is inside a function, then it's possible to return a value with return, but this will exit not only out of the loop but also out of the function.

Nested Loop Expressions
You can nest one loop inside another loop. The first loop is sometimes called the outer loop, and the second loop is called the inner loop. When the break expression is executed in an inner loop, it only breaks out of the inner loop.

In the example below, the outer loop continues to expression3, then the if expression after the inner loop exits and can execute expression1 and the inner loop again.

Copy code

    expression0
    # outer loop
    loop:
        expression1
        # inner loop
        loop:
            expression2
            if (test-arg-block0):
                # exit inner loop
                break
        expression3
        if (test-arg-block1):
            # exit outer loop
            break
    expression4


The for expressions, sometimes called for loops, are the same as loop expressions, except that for expressions iterate over a bounded number of items. This means the number of iterations is known before the for loop is executed, and decisions on when to exit the loop are automated for you.

The Sequencer device is an example of a for loop with bounded iterations when you set the Sequencer device Looping setting to a number. The Sequencer's pulse repeats as many times as specified by the device Looping setting.

Using Verse to program the Sequencer Device in UEFN
In this example, two Trigger devices are in the Sequencer's path. When the Sequencer's pulse reaches a Trigger device, the device sends a signal to display text on one of the Billboard devices, and repeats three times.

As code, this example could look like:

for (X := 0..2):
    TriggerDevice1.Transmit()
    TriggerDevice2.Transmit()
The for expression contains two parts:

Iteration specification: The expressions within the parentheses and the first expression must be a generator. In this example, it is (X := 0..2).
Body: The expressions after the parentheses. In this example, that is the two lines with Transmit().
For flow diagram in Verse
Generator
A generator produces a sequence of values, one at a time, and gives the value a name. In this example, the generator is X := 0..2, so each iteration of the loop, the generator produces the next value and gives the value the name X. When the generator reaches the end of the sequence, the for loop ends. This decision flow of checking if the loop variable has a valid value is built into the for expression. Generators only support ranges, arrays, and maps.

Iterating over a Range
The range type represents a series of integers; for example, 0..3, and Min..Max.

The start of the range is the first value in the expression ‚Äî for example 0 ‚Äî and the end of the range is the value following .. in the expression ‚Äî for example, 3. The range contains all the integers between, and including, the start and end values. For example, the range expression 0..3 contains the numbers 0, 1, 2, and 3. Range expressions only support int values, and can only be used in for, sync, race, and rush expressions.

for (Number := 0 .. 3):
    Log("{Number}")
The result will add four lines to the log containing the numbers 0, 1, 2, and 3.

A for expression can return the results from each iteration in an array. In the following example, Numbers is an immutable array with the int values -1 to -10.

Numbers := for (Number := 1..10):
    -Number
Iterating over an Array or a Map
Iterations over arrays and maps can be just the values, or the key-value pair for maps and the index-value pair for arrays.

In this case, only the values of the array are used, and Values is an immutable array with the int values 2, 3, and 5.

Values := for (X : array{1, 2, 4}):
    X+1
The same can be done with a map, and ¬¥Values is, in this case, an immutable array with the int values 3, 7`.

Values :=  for  (X := map{ 1=>3,  0=>7 }):
    X
The X->Y pattern can be used to deconstruct an index-value or key-value pair. The index (or key) is bound to the left part (X) and the value is bound to to the right part (Y). An example of Index-value pairs from an array, Values is an immutable array with the int values 1, 3, and 6.

Values := for ( X -> Y : array{1, 2, 4}) :
    X + Y
An example of Index-value pairs from a map, Values is an immutable array with the int values 4, and 7.

Values  :=  for ( X->Y := map{ 1=>3,  0=>7 }):
    X + Y
Filter
You can add failable expressions to the for expression to filter out values from the generator. If the filter fails, then there's no result for that iteration, and for skips to the next value produced by the generator.

For example, the filter Num <> 0 is added to the for expression to exclude 0 from the returned results.

NoZero := for (Number := -5..5, Number <> 0):
    Number
Syntactically, this is the same as:

expression0
for (Item : Collection, test-arg-block):
    expression1
expression2
For with Condition diagram in Verse
Definition
You can also add named expressions to the iteration specification, and the name can be used in both the iteration specification and the body.

Values := for ( X := 1..5; Y:=SomeFunction(X); Y < 10):
    Y
Result: an array with at most 5 items where all values are less than 10.

Nested For
You can nest a for loop inside another for loop. There are two ways to do this:

Single For Expression: Specified by multiple generators. The result is a one-dimensional array.

Multiple For Expressions: Separate for blocks. The result is a multidimensional array.

The sections below describe these further.

Single For Expression
You can have multiple loops in a single for expression by adding more generators. The result of a single for expression with multiple generators is a one-dimensional array.

In this example, Values is an immutable array with the int values 13, 14, 23 and 24.

    Values := for(X:=1..2, Y:=3..4):
        X * 10 + Y
Semantically, this is the same as:

expression0
for (Item : Collection, Item2 : Collection2):
    expression1
expression2
Nested For flow diagram in Verse
Multiple For Expressions
You can also nest a for expression in another for-loop body. Since one for expression returns a one-dimensional array, nesting a for expression returns a two-dimensional array.

In this case, Values is an immutable array with two immutable int arrays. The first array contains the values 13, and 14, and the second array contains 23 and 24. (This can be written as array{ array{13, 14}, array{23, 24} }.)

Values := for ( X := 1..2 ):
    for (Y := 3..4):
        X * 10 + Y
Failure
If anything fails inside the iteration specification, then any changes due to that iteration will be rolled back.

for(X := 1..5; S := IncrementSomeVariable(); X < 3):
    X
The result of this for expression is array{1,2}, with only two calls to IncrementSomeVariable after the evaluation of the for loop because the other calls were rolled back when the filter X < 3 failed.


The defer expression delays the execution of code until the current scope exits. You can use the defer expression to handle cleanup tasks like resetting variables. Even when there is an early exit (such as return or break) from the current scope, the expressions in a defer block will run as long as defer is encountered before the exit.

The following code shows how to use defer to reset a variable to zero while still using that same variable as a return value. In this function, RoundScore is returned and the expressions in the defer block run immediately after.

This means you do not need to create a temporary variable to save the value of RoundScore before it gets reset to zero.

OnRoundEnd<public>() : void =
var ScoreThisRound : int = AddRoundScoreToTotalScore()
Print("Points scored this round: {ScoreThisRound}")

<# Adds RoundScore to TotalScore and resets RoundScore to 0.
Returns the RoundScore added. #>
AddRoundScoreToTotalScore<public>() : int = 
	defer:
		set RoundScore = 0
		UpdateUI()
	set TotalScore += RoundScore
	return RoundScore
Defer Expression Use
You can use a defer expression within any sequential code block such as a block, loop, for, if, branch, or even another defer.

Expressions within a defer block must be immediate (and not async) ‚Äî with one exception. Async expressions can still be used within a defer if they are made immediate by using:

spawn
branch (if the defer is within an async block such as in a coroutine)
A defer has no result, and cannot be used as an argument or an assignment value.

defer	defer before an exit
expression0
defer:
    expression1
    expression2
expression3
name() : type =
    expression0
    defer:
        expression1
        expression2
    return expression3

Click image to enlarge.


Click image to enlarge.

A defer expression will only execute if it is encountered before an early exit occurs.

defer with early return	defer with a canceled async expression
expression0
if (conditions):
    return
defer:
    expression1
expression2
expression0
race:
    block: # canceled during slow-async-expression
        slow-async-expression
        defer:
            expression1
        expression2
     block: # finishes first
         fast-async-expression
         defer:
             expression3
         expression4
expression5

Click image to enlarge.


Click image to enlarge.

Multiple defer expressions appearing in the same scope accumulate. The order they are executed is the reverse order they are encountered ‚Äî first-in-last-out (FILO) order. Since the last encountered defer in a given scope is executed first, expressions inside that last encountered defer can refer to context (such as variables) that will be cleaned up by other defer expressions that were encountered earlier and executed later.

Verse does not have deterministic destruction, but defer allows behavior similar to RAII to ensure cleanup.

Multiple defer expressions in a code block	Multiple defer expressions in different code blocks
expression0
defer:
    expression1
expression2
defer:
    expression3
expression4
expression0
if (conditions):
    expression1
    defer:
        expression2
    expression3
expression4
defer:
    expression5
expression6

Click image to enlarge.


Click image to enlarge.

Exiting early is allowed within a defer block as long as the exit does not transfer control outside the scope of the defer. For example, using a loop with break is allowed within a defer, but that break must keep the code execution within the defer block. It cannot refer to a loop outside of the defer block.

Any variables that have been encountered in the outer nesting scope of a defer can be used within that defer expression.

Remember that defer runs last at the time of scope exit. This means that it uses whatever the state of the program is (including variable values) at that time, not at the time when the defer is encountered. The code below will print 10 because defer runs immediately after MyScore is set to 10.

var MyScore = 5
defer: 
	Print(MyScore)
set MyScore = 10
Using a defer expression as the last expression within a scope is the same as not using it at all. For example, these two sets of expressions will run in exactly the same order, so defer is not needed:

Without defer	With defer
expression0
expression1
expression2
expression0
expression1
defer:
    expression2

An expression in Verse can be either immediate or async. This describes the time an expression can take to evaluate relative to simulation updates.

Think of a simulation update as when a new frame is shown.

There are cases when multiple simulation updates can occur before a new frame, such as if an online game goes out of sync with the server.

immediate	async
An immediate expression evaluates with no delay, meaning that the evaluation will complete within the current simulation update.	An async expression has the possibility of taking time to evaluate, but doesn‚Äôt necessarily have to. An async expression may or may not complete in the current simulation update, or in a later one.
Async Contexts
Async expressions can be used in any Verse code that has an async context.

An async context is the body of a function that has the suspends effect specifier. The suspends effect indicates that async functions can suspend and cooperatively transfer control to other concurrent expressions at various points over several simulation updates before they complete.

The OnBegin() function in a Verse device is a common async function used as a starting point for async code.

Calling an async function has the same syntax as calling an immediate function:

OnBegin<override>()<suspends> : void =
    HideAllPlatforms()

HideAllPlatforms()<suspends> : void =
    for (Platform : Platforms):
        Platform.Hide()
        Sleep(Delay)
Like any other expression, an async expression can have a result. The result of an async expression is only available once it has completed.

# Npc is undefined until it is bound after MoveToNearestNPC() completes which may be several frames into the future
Npc := Player.MoveToNearestNPC()

#Only called after MoveToNearestNPC() completes
Print("Moved to {Npc}")
Any code block that is within an async context (inside the body of an async function) may have any mix of immediate and async expressions.

If any expressions in a code block are async, then the whole code block is considered to be async.
If all expressions in a code block are immediate, then the whole code block is considered to be immediate.
All the expressions in the example below are async expressions, so the overall code block is async:

Sleep(2.0)  # waits 2 seconds
Boss.TauntEmote() # waits until TauntEmote() completes
Player.MoveToNearestNPC() # waits until MoveToNearestNPC() completes
All the expressions in the example below are immediate expressions, so the overall code block is immediate:

Print("Reset after explosion")
Platform.Show()
set SecondsUntilExplosion = 12.0
The expressions in the example below are a mix of async and immediate expressions, so the overall code block is async:

Print("Started")
var Seconds := 1.0
Sleep(Seconds)

Print("Waited {Second} seconds")
set Second += 1.0
Sleep(Seconds)

Print("Waited {Second} seconds")
set Second += 1.0
Sleep(Seconds)

Print("Waited {Second} seconds")
Immediate expressions stick together on their own. All adjacent immediate (non-async) expressions are considered to be atomic ‚Äî their code is guaranteed to run without interruption within the same update, and without preemption or context switching. It is as though such code had an automatic mutual-exclusion primitive wrapped around them.

So from the code example above, these immediate expressions are treated atomically:

# These two expressions are always kept together
Print("Started")
var Seconds := 1.0

Sleep(Seconds)

# These two expressions are always kept together
Print("Waited {Second} seconds")
set Second += 1.0

Sleep(Seconds)

# These two expressions are always kept together
Print("Waited {Second} seconds")
set Second += 1.0

Sleep(Seconds)

Print("Waited {Second} seconds")
Like any other code block, the last expression in an async code block is used as a result.

Concurrency Expressions
Verse uses concurrency expressions to determine whether expressions execute concurrently (at the same time), or in sequence, one after another. An async expression is executed or invoked over time, so these concurrency expressions can be especially useful when you‚Äôre using async expressions.

Structured Concurrency
An async expression will block other expressions from executing if it takes a long time to execute. For example, using Sleep(90.0) will cause the program to wait 90 seconds, blocking the next expression until Sleep(90.0) is fully executed.

Structured concurrency expressions are used to specify async logical time flow, and to modify the blocking nature of async expressions with a lifespan that is logically constrained to a specific async context scope (such as an async function body).

This is similar to structured flow control such as block, if, for, and loop that constrain to their associated scope.

Verse async expressions do not use the yield and await primitives used by async implementations in other languages. The same mechanisms are accomplished by using Verse concurrency expressions and internal mechanisms.

For more on structured concurrency, see Sync, Race, Rush, and Branch.

Unstructured Concurrency
There is only one unstructured concurrency expression ‚Äî spawn. This expression has a lifespan that is not logically constrained to a specific async context scope, but that potentially can extend beyond the scope where it was executed.

Unstructured concurrency is like an emergency escape hatch ‚Äî you shouldn't use it on a regular basis although sometimes it is your best and only option.

Structured concurrency expressions (sync, race, rush and branch) should be used before unstructured concurrency (spawn) expressions whenever possible.

For more on unstructured concurrency, see Spawn.

Tasks for Tracking Currently Executing Async Expressions
An async expression has a task associated with it.

A task is an object that represents an async function that has started to execute, but has suspended to allow another task to complete.

The task can be used to check the status of an async expression and to cancel the async expression, if desired.

For more on tasks, see Task.


You can use the sync expression to run two or more async expressions at the same time. For example:

Copy code

# All three async functions effectively start at the same time
Results = sync:
    AsyncFunction1()  # task 1
    AsyncFunction2()  # task 2
    AsyncFunction3()  # task 3
# Called after all three tasks complete (regardless of order)
MyLog.Print("Done with list of results: {Results}")
The following code shows the syntax for the sync expression with an accompanying diagram that shows the execution flow of the expressions.

Copy code

expression0
sync:
    slow-expression
    mid-expression
    fast-expression
expression1
Sync Expression Use
Where you can use a sync expressionAsync contextsInvocation time of the sync expressionAsyncRequirements for sync code blockThe body of the sync expression must have at least two expressions that are async; otherwise, you have no need to run the expressions simultaneously.What the sync expression doesExecutes all expressions in its code block concurrently and waits for them all to finish before executing the next expression after the sync.When the sync expression completesWhen all the expressions in the sync code block have completed.When the next expression after sync startsWhen all the expressions in the sync code block have completed.Result of the sync expressionIts result is a tuple of results from each expression in the order that the top-level expressions were specified. The result types of the expressions can be of any type, and each tuple element will have the type of its corresponding expression.

At least two top-level expressions must be async.

Copy code

sync:
    AsyncFunction1()
    MyLog.Print("Second top level expression")
    AsyncFunction2()
    MyLog.Print("Third top level expression")

sync:
    AsyncFunction1()
    # Error: expected at least two top-level expressions
Top-level expressions can be compound expressions, such as nested code blocks:

Copy code

# sync may also have compound expressions
# with each top-level expression its own task
sync:
    block: # task 1
        # Evaluated in serial order
        AsyncFunction1a()
        AsyncFunction1b()
    block: # task 2
        AsyncFunction2a()
        AsyncFunction2b()
        AsyncFunction2c()
    AsyncFunction3() # task 3

# AsyncFunction1a(), AsyncFunction2a() and AsyncFunction3() all start essentially at the same time
Since tuples can be used as self-splatting arguments, sync expressions can be used directly as arguments since they have a tuple result. This allows async arguments to evaluate simultaneously, and the function they are being passed to is called when all the expressions in the sync code block are completed.

Copy code

# All three coroutine arguments start their evaluation at the same time
DoStuff(sync{AsyncFunctionArg1(); AsyncFunctionArg2(); AsyncFunctionArg3()})

# Not every argument needs to be async - a minimum of two justifies the use of sync
DoOtherStuff(sync{AsyncFunctionArg1(); 42; AsyncFunctionArg2(); AsyncFunctionArg3()}
S

The rush expression is used to run a block of two or more async expressions concurrently (simultaneously).

When the fastest subexpression completes, any expression that follows the rush is evaluated, and any remaining subexpressions continue to evaluate.

Copy code

set WinnerResult = rush:
    # All three async functions start at the same time
    AsyncFunctionLongTime()
    AsyncFunctionShortTime()  # This will win and its result is used
    AsyncFunctionMediumTime()
# Next expression is called after the fastest async function (AsyncFunctionShortTime()) completes.
# All other subexpression tasks (AsyncFunctionLongTime(), AsyncFunctionMediumTime()) continue.    
NextExpression(WinnerResult)
AsyncFunction4()
# If any rush subexpression tasks are still running when AsyncFunction4 completes
# then they are now canceled.
The following code shows the syntax for the rush expression.

Copy code

expression0
rush:
    slow-expression
    mid-expression
    fast-expression
expression1
The diagram below shows the execution flow for the expressions.

Rush Expression Use
Where you can use a rush expressionAsync contextsInvocation time of the rush expressionAsyncRequirements for rush code blockThe body of the rush expression must have at least two expressions, and all of the expressions must be async.What the rush expression doesIs similar to race, but expressions that complete after first completion continue. If any expressions effectively complete at the same simulation update, then the earlier encountered expression that completes breaks any tie. Any incomplete expressions continue to evaluate until they complete, or until the enclosing async context completes, at which point, any remaining losing expressions are canceled ‚Äî whichever occurs first.When the rush expression completesThe rush expression completes when the first expression in the code block has completed. This could be the fastest, shortest length, first completed, or least amount of time to complete.When the next expression after rush startsAny next expression that follows the rush expression is started when the completed expression finishes.Result of the rush expressionThe result of a rush expression is the result of the first completed expression. The result type is the most common compatible type of all expressions in the code block.

A rush expression cannot currently be used in the body of an iteration expression like loop or for. If it must be used, then wrap it in an async function and have the iteration expression call that function.

A branch expression starts a block of one or more async subexpressions, and any expression that follows after is executed immediately, without waiting for the branch expressions to complete.

You can use branch essentially to treat any async block of code as though it were fire-and-forget immediate, but it still must be called within an async context.

Copy code

branch:
    # This block continues until completed
    AsyncFunction1()    # Starts effectively the same time as AsyncFunction3()
    Method1()  # Block can be mixed with immediate expressions
    AsyncFunction2()
AsyncFunction3()  # Starts effectively the same time as AsyncFunction1()
# If branch block task is still running when AsyncFunction3 completes
# then any remaining branch task is canceled
The following code shows the syntax for the branch expression.

Copy code

expression0
branch:
    slow-expression
    mid-expression
    fast-expression
expression1
The diagram below shows the execution flow of the expressions.

It is similar to the unstructured concurrency spawn expression, but branch allows for any arbitrary block of code, and is only permissible within, and bounded by, an enclosing async context. Because of this, branch is preferred over spawn whenever possible.

Branch Expression Use
Where you can use a branch expressionAsync contextsInvocation time of the branch expressionImmediateRequirements for branch code blockThe branch expression must have at least one async expression.What the branch expression doesThe body of the branch expression is started as soon as it is encountered. The body of the branch expression continues to evaluate until the code block completes or the enclosing async context completes ‚Äî whichever occurs first ‚Äî at which point the branch code block task is canceled.When the branch expression completesThe branch expression completes immediately.When the next expression after branch startsAny expression that follows the branch expression is started immediately.Result of the branch expressionA branch expression has no result, so its result type is void.

A branch expression may not currently be used in the body of an iteration expression such as loop or for. If it must be used then wrap it in an async function and have the iteration expression call that function.

The spawn expression starts one async function invocation, and any expression that follows the spawn is executed immediately while the started async function task continues independently until it completes.

Copy code

# Continues until completed without blocking
spawn{AsyncFunction1()}  # Started at same time as expression0
expression0         # Started at same time as AsyncFunction1()
The following code shows the syntax for the spawn expression.

Copy code

expression0
spawn{ expression1 }
expression2
The diagram below shows the execution flow of the expressions.

While similar to branch, the spawn body is limited to a single async function call. It is also allowed outside of an async context, so it can be called within both non-async and async functions.

A spawn expression should be treated like an emergency escape hatch, while branch should be used in place of spawn whenever possible.

Spawn Expression Use
Where you can use a spawn expressionAny context.Invocation time of the spawn expressionImmediate.Requirements for spawn code blockThe body of the spawn expression is started as soon as it is encountered. It must have at least one async expression.What the spawn expression doesThe body of a spawn creates an async context like the body of an async function. However, only a single async function call is allowed within the spawn body. The async function of the spawn is started as soon as it is encountered, and evaluates as much as possible until it encounters something suspending or blocking. The spawned async function continues to evaluate until it completes without any further connection to the location where it was spawned.When the spawn expression completesThe spawn expression completes immediately.When the next expression after spawn startsAny next expression that follows the spawn expression is started immediately.Result of the spawn expressionA spawn has a task result.

task is an object used to represent the state of a currently-executing async function. Task objects are used to identify where an async function is suspended, and the values of local variables at that suspend point.

Tasks execute concurrently in a cooperatively multitasked environment.

A task can be durational, based on a lifespan of one or more updates before it completes.

Tasks can be sequential, overlapped, staggered, and so on, in any logical order.

The sequence and overlapping flow of tasks is specified through the use of structured or unstructured concurrency expressions.

Each task can be concurrently arranged sequentially, overlapped, staggered, and so on, in any logical order of time. Internally, a task could have a caller (or even several callers), and zero or more dependent sub-tasks that form a call graph (as opposed to a call stack).

A task is similar to a thread, but has the advantage over threads in that context switching between tasks does not involve any system calls, expensive context-state saving, or processor-blocking calls, and a processor can be 100% utilized). You don‚Äôt need synchronization such as mutexes or semaphores to guard critical sections, and there is no need for support from the operating system.

The task(t:type) class allows direct programmatic querying and manipulation of tasks in an unstructured manner, though it is generally recommended that tasks be manipulated through structured concurrency expressions for greater clarity, power and efficiency.

Currently, the only exposed function for task is Await(), which waits until the current task has completed. This essentially anchors a task and adds a caller for it to return to at the call point.

Copy code

spawn{AsyncFunction3()}

# Get task to query / give commands to
# starts and continues independently
Task2 := spawn{Player.MoveTo(Target1)}

Sleep(1.5) # Wait 1.5 Seconds
MyLog.Print("1.5 Seconds into Move_to()")

Task2.Await() # wait until MoveTo() completed
Wait(0.5)     # Wait 0.5 Seconds
# Explicit start and wait until completed
# Task1 could still be running
Target1.MoveTo(Target2)
Similar to the example above, the one below uses structured concurrency expressions:

Copy code

sync:
    AsyncFunction3()  # Task 1
    block:
        Player.MoveTo(Target1)  # Task 2
        Sleep(0.5)  # Wait 0.5 Seconds
        Target1.MoveTo(Target2)
    block:  # Task 3
        Sleep(1.5)  # Wait 1.5 Seconds
        MyLog.Print("1.5 Seconds into Move_to()")

The range type represents a series of integers, for example 0..3, and Min..Max.

The start of the range is the first value in the expression, for example 0, and the end of the range is the value following .. in the expression, for example 3. The range contains all the integers between, and including, the start and end values. For example, the range expression 0..3 contains the numbers 0, 1, 2, and 3.

Range expressions only support int values, and can only be used in for, sync, race, and rush expressions.

For example:

Copy code

for (Index := 0..5):
    Print("{Index}")

When you have variables of the same type, you can collect them into an array. An array is a container type where you specify the type of the elements with []type, such as []float. An array is useful because it scales to however many elements you store in it without changing your code for accessing the elements.

For example, if you have multiple players in your game, you can create an array and initialize it with all the players.

Players : []player = array{Player1, Player2}
An array containing 2 players
Verse has the pattern where definition mirrors use. Defining an array and using it follows that pattern.

Array Length
You can get the number of elements in an array by accessing the member Length on the array. For example, array{10, 20, 30}.Length returns 3.

Accessing Elements in an Array
Elements in an array are ordered in the same position in the array as you inserted them, and you can access the element at that position, called its index, in the array. For example, to get the first player, you‚Äôd access the Players array with Players[0].

The first element in an array has an index of 0 and each subsequent element‚Äôs index increases in number. For example, array{10, 20, 30}[0] is 10 and array{10, 20, 30}[1] is 20.

Index	0	1	2
Element	10	20	30
The last index in an array is one less than the length of the array. For example, array{10, 20, 30}.Length is 3 and the index for 30 in array{10, 20, 30} is 2.

Accessing an element in an array is a failable expression and can only be used in a failure context, such as an if expression. For example:

ExampleArray : []int = array{10, 20, 30, 40, 50}
for (Index := 0..ExampleArray.Length - 1):
    if (Element := ExampleArray[Index]):
        Print("{Element} in ExampleArray at index {Index}")
This code will print:

    10 in ExampleArray at index 0
    20 in ExampleArray at index 1
    30 in ExampleArray at index 2
    40 in ExampleArray at index 3
    50 in ExampleArray at index 4
Changing an Array and its Elements
Arrays, like all other values in Verse, are immutable. If you define an array variable, that allows you to assign a new array to the variable, or mutate individual elements.

For example:

# Array1 is an array of integers
Array1 : []int = array{10, 11, 12}

# Array2 is an array variable of integers
var Array2 : []int = array{20, 21, 22}

# we concatenate Array1, Array2, and a new array of integers
# and assign that to the Array2 variable
set Array2 = Array1 + Array2 + array{30, 31}

# we assign the integer 77 to index 1 of Array2
if (set Array2[1] = 77) {}

for (Index := 0..Array2.Length - 1):
    if (Element := Array2[Index]):
        Print("{Element} at index {Index}")
This code will print:

    10 at index 0
    77 at index 1
    12 at index 2
    20 at index 3
    21 at index 4
    22 at index 5
    30 at index 6
    31 at index 7
Multi-Dimensional Arrays
The arrays in the previous examples were all one-dimensional, but you can also create multi-dimensional arrays. Multi-dimensional arrays have another array, or arrays, stored at each index, similar to columns and rows in a table.

For example, the following code produces a two-dimensional (2D) array, visualized in the following table:

var Counter : int = 0
Example : [][]int =
    for (Row := 0..3):
        for(Column := 0..2):
            set Counter += 1
 	Column 0	Column 1	Column 2
Row 0	1	2	3
Row 1	4	5	6
Row 2	7	8	9
Row 3	10	11	12
To access elements in a 2D array, you must use two indices. For example, Example[0][0] is 1, Example[0][1] is 2, and Example[1][0] is 4.

The following code shows how to use a for expression to iterate through the Example 2D array.

if (NumberOfColumns : int = Example[0].Length):
    for(Row := 0..Example.Length-1, Column := 0..NumberOfColumns):
         if (Element := Example[Row][Column]):
             Print("{Element} at index [{Row}][{Column}]")
This code will print:

    1 at index [0][0]
    2 at index [0][1]
    3 at index [0][2]
    4 at index [1][0]
    5 at index [1][1]
    6 at index [1][2]
    7 at index [2][0]
    8 at index [2][1]
    9 at index [2][2]
    10 at index [3][0]
    11 at index [3][1]
    12 at index [3][2]
The number of columns in each row is not required to be constant.

For example, the following code produces a two-dimensional (2D) array, visualized in the following table, where the number of columns in each row is greater than the previous row:

Example : [][]int =
    for (Row := 0..3):
        for(Column := 0..Row):
            Row * Column
 	Column 0	Column 1	Column 2	Column 3
Row 0	0	 	 	 
Row 1	0	1	 	 
Row 2	0	2	4	 
Row 3	0	3	6	9

A map is a container type that holds key-value pairs, which are mappings from one value to another value. Elements in a map are ordered based on the order of key-value pairs when you create the map, and you access elements in the map using the unique keys you define.

For example, if you want to keep a count of how many times you encounter a word, you can create a map using the word as the key and its count as the value.

WordCount : [string]int = map{"apple" => 11, "pear" => 7}

Click image to enlarge.

If you use the same key multiple times when initializing a map, the map will only keep the last value provided for that key. In the following example, WordCount will only have the "apple" => 2 key-value pair. The "apple" => 0 and "apple" => 1 pairs are discarded.

WordCount : [string]int = map{"apple" => 0, "apple" => 1, "apple" => 2}
Supported Key Types
Key-value pairs can be of any type as long as the key type is comparable, because there needs to be a way to check if a key already exists for a map.

The following types can be used as keys:

logic
int
float
char
string
enum
A class, if it‚Äôs comparable
An option, if the element type is comparable
An array, if the element type is comparable
A map if both the key and the value types are comparable
A tuple if all elements in the tuple are comparable
Map Length
You can get the number of key-value pairs in a map by accessing the field Length on the map. For example, map{"a" => "apple", "b" => "bear", "c" => "candy"}.Length returns 3.

Accessing Elements in a Map
You can access an element in a map by using a key, for example WordCount["apple"].

Accessing an element in a map is a failable expression and can only be used in a failure context, such as an if expression. For example:

ExampleMap : [string]string = map{"a" => "apple", "b" => "bear", "c" => "candy"}
for (Key->Value : ExampleMap):
    Print("{Value} in ExampleMap at key {Key}")
Key	"a"	"b"	"c"
Value	"apple"	"bear"	"candy"
Adding and Modifying Elements in a Map
You can add elements to a map variable by setting the key in a map to a specific value. For example set ExampleMap["d"] = 4. Existing key-value pairs can be updated by similarly assigning a value to a key that already exists in the map. Adding an element to a map is a failable expression and can only be used in a failure context, such as an if expression. For example:

var ExampleMap : [string]int = map{"a" => 1, "b" => 2, "c" => 3}
# Modifying an existing element
if (set ExampleMap["b"] = 3, ValueOfB := ExampleMap["b"]):
    Print("Updated key b in ExampleMap to {ValueOfB}")
# Adding a new element
if (set ExampleMap["d"] = 4, ValueOfD := ExampleMap["d"]):
    Print("Added a new key-value pair to ExampleMap with value {ValueOfD}")
Removing Elements from a Map
Elements can be removed from a map variable by creating a new map that excludes the key you want to remove. An example of a function that provides removal from [string]int maps is provided below.

# Removes an element from the given map and returns a new map without that element
RemoveKeyFromMap(ExampleMap:[string]int, ElementToRemove:string):[string]int=
    var NewMap:[string]int = map{}
    # Concatenate Keys from ExampleMap into NewMap, excluding ElementToRemove
    for (Key -> Value : ExampleMap, Key <> ElementToRemove):
        set NewMap = ConcatenateMaps(NewMap, map{Key => Value})
    return NewMap
Weak Map
The type weak_map is a supertype of the map type. You would use a weak_map in a similar way to how you‚Äôd use the map type in most cases, but with the following exceptions:

You cannot query how many elements a weak_map contains because weak_map does not have a Length member.
You cannot iterate through the elements of a weak_map.
You cannot use ConcatenateMaps() on a weak_map.
Another difference is that the type definition for a weak_map requires you to define the key-value pair types using the weak_map function, such as MyWeakMap:weak_map(string, int) = map{}, which defines a weak map named MyWeakMap that will have a string key paired with an integer value. Since weak_map is a supertype of map, you can initialize it with a standard map{}.

The following shows an example of creating a weak_map variable, and accessing an element in the weak map:

ExampleFunction():void=
    var MyWeakMap:weak_map(int, int) = map{} # Supertype of the standard map, so it can be assigned from the standard map
    if: 
        set MyWeakMap[0] = 1 # Same means of mutation of a particular element as the standard map
    then:
        if (Value := MyWeakMap[0]):
            Print("Value of map at key 0 is {Value}")
    set MyWeakMap = map{0 => 2} # Same means of mutation of the entire map as the standard map


In Verse, a class is a template for creating objects with similar behaviors and properties. It is a composite type, which means that it‚Äôs bundled data of other types and functions that can operate on that data.

For example, let‚Äôs say you want to have multiple cats in your game. A cat has a name and an age, and they can meow. Your cat class could look like this:

cat := class:
    Name : string
    var Age : int = 0
    Sound : string

    Meow() : void = DisplayMessage(Sound)
Definitions of variables that are nested inside the class define fields of the class. Functions defined inside a class may also be called methods. Functions and methods are referred to as class members. In the above example, Sound is a field, and Meow is a method of cat.

Fields of a class may or may not have a default value, or may only define a type that limits the values that the field may have. In the above example, Name does not have a default value, while Age does.

Constructing a Class
With a class that defines what a cat is and what the cat can do, you can construct an instance of the class from an archetype. An archetype defines the values of the class fields. For example, let‚Äôs make an old cat named Percy from the cat class:

OldCat := cat{Name := ‚ÄùPercy‚Äù, Age := 20, Sound:= ‚ÄùRrrr‚Äù}
In this example, the archetype is the part between { and }. It doesn't need to define values for all fields of the class, but must at least define values for all fields that don't have a default value. If any field is omitted, then the instance constructed will have the default value for that field.

In this case, the cat class Age field has a default value assigned to it of (0). Since the field has a default value, you‚Äôre not required to provide a value for it when constructing an instance of the class. The field is a variable, which means that though you might provide a value at construction time, the value of that variable can be changed after construction.

By contrast, the Name field of cat is not a mutable variable, and so is immutable by default. This means that you can provide a default value for it at construction time, but after construction, it cannot change: it is immutable.

Since a class in Verse is a template, you can make as many instances as you want from the cat class. Let‚Äôs make a kitten named Flash:

Kitten := cat{Name := ‚ÄùFlash‚Äù, Age := 1, Sound := ‚ÄùMew‚Äù}
Accessing Fields
Now that you have some instances of cat, you can access each cat‚Äôs Name field with OldCat.Name or Kitten.Name, and call each cat's Meow method with OldCat.Meow() or Kitten.Meow().

Both cats have the same named fields, but those fields have different values. For example, OldCat.Meow() and Kitten.Meow() behave differently because their Sound fields have different values.

Self
Self is a special identifier in Verse that can be used in a class method to refer to the instance of the class that the method was called on. You can refer to other fields of the instance the method was called on without using Self, but if you want to refer to the instance as a whole, you must use Self.

For example, if DisplayMessage required an argument for which pet to associate a message with:

DisplayMessage(Pet:pet, Message:string) : void = ‚Ä¶
cat := class:
    ‚Ä¶
    Meow() : void = DisplayMessage(Self, Sound)
Subclasses and Inheritance
Classes can inherit from a superclass, which includes all fields of the superclass in the inheriting class. Such classes are said to be a subclass of the superclass. For example:

pet := class:
    Name : string
    var Age : int = 0

cat := class(pet):
    Sound : string
    Meow() : void = DisplayMessage(Self, Sound)

dog := class(pet):
    Trick : string
    DoTrick() : void = DisplayMessage(Self, Trick)
Here, the use of class(pet) when defining cat and dog declares that they inherit from the pet class. In other words, they are subclasses of pet.

This has several advantages:

Since both cats and dogs have names and ages, those fields only have to be defined once, in the pet class. Both the cat and the dog field will inherit those fields.
The pet class can be used as a type to refer to instance of any subclass of pet. For example, if you want to write a function that just needs the name of a pet, you can write the function once for both cats and dogs, and any other pet subclasses you might introduce in the future:
IncreaseAge(Pet : pet) : void=
 set Pet.Age += 1
For more information, see the Subclass page.

Overrides
When you define a subclass, you can override fields defined in the superclass to make their type more specific, or change their default value. To do so, you must write the definition of the field in your subclass again, but with the <override> specifier on its name. For example, you can add a Lives field to pet with a default value of 1, and override the default value for cats to be 9:

pet := class:
    ‚Ä¶
    Lives : int = 1

cat := class(pet):
    ‚Ä¶
    Lives<override> : int = 9
Method Calls
When you access a field of a class instance, you access that instance's value for the field. For methods, the field is a function, and overriding it replaces the field's value with a new function. Calling a method calls the value of the field. This means that the method called is determined by the instance. Consider the follow example:

pet := class:
    ‚Ä¶
    OnHearName() : void = {}

cat := class(pet):
    ‚Ä¶
    OnHearName<override>() : void = Meow()

dog := class(pet):
    ‚Ä¶
    OnHearName<override>() : void = DoTrick()

CallFor(Pet:pet):void=
    DisplayMessage("Yoo hoo {Pet.Name}!")
    Pet.OnHearName()
If you write CallFor(Percy), it will call the OnHearName method as defined by cat. If you write CallFor(Fido) where Fido is an instance of the dog class, then it will call the OnHearName method as defined by dog.

Visibility Specifiers
You can add visibility specifiers to class fields and methods to control who has access to them. For example, you can add the private specifier to the Sound field so only the owning class can access that private field.

cat := class:
    ‚Ä¶
    Sound<private> : string

MrSnuffles := cat{Sound := "Purr"}
MrSnuffles.Sound # Error: cannot access a private field
The following are all the visibility specifiers you can use with classes:

public: Unrestricted access.
internal: Access limited to current module. This is the default visibility.
protected: Access limited to current class and any subclasses.
private: Access limited to current class.
Access Specifiers
You can add access specifiers to a class to control who can construct them. This is useful, for example, if you want to make sure an instance of a class can only be constructed at a certain scope.

pets := module:
    cat<public> := class<internal>:
        Sound<public> : string = "Meow"

GetCatSound(InCat:pets.cat):string =
    return InCat.Sound # Valid: References the cat class but does not call its constructor

MakeCat():void =
    MyNewCat := pets.cat{} # Error: Invalid access of internal class constructor
Calling the constructor for the cat class outside of its module pets wil fail because the class keyword is marked as internal. This is true even though the class identifier itself is marked as public, which means cat can be referenced by code outside the pets module.

The following are all the access specifiers you can use with the class keyword:

public: Unrestricted access. This is the default access.
internal: Access limited to the current module.
Concrete Specifier
When a class has the concrete specifier, it is possible to construct it with an empty archetype, such as cat{}. This means that every field of the class must have a default value. Furthermore, every subclass of a concrete class must itself be concrete.

For example:

class1 := class<concrete>:
    Property : int = 0

# Error: Property isn't initialized
class2 := class<concrete>:
    Property : int

# Error: class3 must also have the <concrete> specifier since it inherits from class1
class3 := class(class1):
    Property : int = 0
A concrete class can only inherit directly from an abstract class if both classes are defined in the same module. However, it does not hold transitively ‚Äî a concrete class can inherit directly from a second concrete class in another module where that second concrete class inherits directly from an abstract class in its module.

Unique Specifier
The unique specifier can be applied to a class to make it a unique class. To construct an instance of a unique class, Verse allocates a unique identity for the resulting instance. This allows instances of unique classes to be compared for equality by comparing their identities. Classes without the unique specifier don't have any such identity, and so can only be compared for equality based on the values of their fields.

This means that unique classes can be compared with the = and <> operators, and are subtypes of the comparable type.

For example:

unique_class := class<unique>:
    Field : int

Main()<decides> : void =
    X := unique_class{Field := 1}
    X = X # X is equal to itself
    Y := unique_class{Field := 1}
    X <> Y # X and Y are unique and therefore not equal
Final Specifier
You can only use the final specifier on classes and fields of classes.

When a class has the final specifier, you cannot create a subclass of the class. In the following example, you cannot use the pet class as a superclass, because the class has the final specifier.

pet := class<final>():
    ‚Ä¶

cat := class(pet): # Error: cannot subclass a ‚Äúfinal‚Äù class
    ‚Ä¶
When a field has the final specifier, you cannot override the field in a subclass. In the following example, the cat class can‚Äôt override the Owner field, because the field has the final specifier.

pet := class():
    Owner<final> : string = ‚ÄúAndy‚Äù

cat := class(pet):
    Owner<override> : string = ‚ÄúSid‚Äù # Error: cannot override ‚Äúfinal‚Äù field
When a method has the final specifier, you cannot override the method in a subclass. In the following example, the cat class can‚Äôt override the GetName() method, because the method has the final specifier.

pet := class():
    Name : string

    GetName<final>() : string = Name

cat := class(pet):
    ‚Ä¶
    GetName<override>() : string =  # Error: cannot override ‚Äúfinal‚Äù method
        ‚Ä¶
Block Expressions in a Class Body
You can use block expressions in a class body. When you create an instance of the class, the block expressions are executed in the order they are defined. Functions called in block expressions in the class body cannot have the NoRollback effect.

As an example, let‚Äôs add two block expressions to the cat class body and add the transacts effect specifier to the Meow() method because the default effect for methods has the NoRollback effect.

cat := class():
    Name : string
    Age : int
    Sound : string

    Meow()<transacts> : void =
        DisplayOnScreen(Sound)

    block:
	    Self.Meow()

    block:
        Log(Self.Name)

OldCat := cat{Name := "Garfield", Age := 20, Sound := "Rrrr"}
When the instance of the cat class, OldCat, is created, the two block expressions are executed: the cat will first say ‚ÄúRrrr‚Äù; then ‚ÄúGarfield‚Äù will print to the output log.

Interfaces
Interfaces are a limited form of classes that can only contain methods that don't have a value. Classes can only inherit from a single other class, but can inherit from any number of interfaces.

Enum is short for enumeration, which means to name or list a series of things, called enumerators. This is a type in Verse that can be used for things like days of the week or compass directions.

Click image to enlarge.

Copy code

direction := enum{Up, Down, Left, Right}
Creating an enum: Use the keyword enum followed by {}. If you want to specify initial elements in the enum, add the enumerators between the {}, separated by ,.

Copy code

direction.Up
Accessing an enumerator: Use . on the enum, followed by the enumerator you want to use. For example direction.Up.

Struct is short for structure, and is a way to group several related variables together. Any variables can be grouped, including variables of different types.

[

Click image to enlarge.

Copy code

coordinates := struct:
    X : float = 0.0
    Y : float = 0.0
Creating a struct: Use the keyword struct followed by a code block. Definitions in the struct‚Äôs code block define the fields of the struct.

Copy code

Position := coordinates{X := 1.0, Y := 1.0}
Instantiating a struct: You can construct an instance of a struct from an archetype. An archetype defines the values of a struct‚Äôs fields.

Copy code

Position.X
Accessing fields on a struct: You can access a struct‚Äôs fields to get their value by adding . between the struct instance and the field name.

In Verse, you can create a class that extends the definition of another class by adding or modifying the fields and methods of the other class. This is often called subclassing or inheritance, because one class inherits definitions from the other class.

Let‚Äôs look at the Class Designer device as an example of subclassing. With the Class Designer device, you can create character classes for player characters that let you define the attributes and inventories specific to a character class, such as a tank or DPS (damage per second) character.

DPS character class created with the Class Designer device	Tank character class created with the Class Designer device
In Verse, you could create a tank class and a dps class like this:

tank := class():
    StartingShields : int
    MaxShields : int
    AllowOvershield : logic
    DamageReduction : int

dps := class():
    StartingShields : int
    MaxShields : int
    AllowOvershield : logic
    MovementMultiplier : float
Because some of the fields in the two classes are the same, you can reduce duplication with a superclass that holds the shared properties and behaviors of the classes. Let‚Äôs call this superclass player_character, and make tank and dps subclasses of player_character:

player_character := class():
    StartingShields : int
    MaxShields : int
    AllowOvershield : logic

dps := class(player_character):
    MovementMultiplier : float

tank := class(player_character):
    DamageReduction : int
Since the tank and dps classes are subclasses of player_character, they automatically inherit the fields and methods of the player_character class, so you only need to specify what‚Äôs different in this class from the superclass.

For example, the dps class only adds the Movement Multiplier field, and the tank class only adds the DamageReduction field. This setup is useful if you change the shared behaviors of the two classes later because you‚Äôll only need to change it in the superclass.

Diagram showing inheritance relationship between the superclass player_character and the subclasses dps and tank
With Verse, you can add more changes to differentiate the tank and dps classes by adding methods to the subclasses.

A useful effect of subclassing is that you can use the relationship between a superclass and its subclasses. Because of inheritance, an instance of tank is a specialized player_character, and an instance of dps is a specialized player_character, which is referred to as an is-a relationship. Since tank and dps are both subclasses of the same superclass and diverge from their shared superclass, tank does not have a relationship with dps.

Override Specifier
To create instances of classes with initial values, a common practice is to have a function that generates the instances. For example:

CreateDPSPlayerCharacter() : dps =
    return dps{StartingShields := 0, MaxShields := 0, AllowOvershield := false, MovementMultiplier := 1.9}

CreateTankPlayerCharacter() : tank =
    return tank{StartingShields := 100, MaxShields := 200, AllowOvershield := true, DamageReduction := 50}
The CreateTankPlayerCharacter() and CreateDPSPlayerCharacter() functions create the instances with the appropriate initial values. Alternatively, you can override the fields from the superclass and assign initial values, so you don‚Äôt need to provide so many initial values when creating an instance.

For example, the tank class from the previous section could look like this with overrides on the fields:

tank := class(player_character):
    StartingShields<override> : int = 100
    MaxShields<override> : int = 200
    AllowOvershield<override> : logic = true
    DamageReduction : int = 50

CreateTankPlayerCharacter() : tank =
    return tank{}
Diagram showing overrides in the inheritance relationship between the superclass player_character and the subclasses dps and tank
You can also override methods in the subclass, which means you can use the overriding method everywhere the overriden method can be used. This means:

The method must accept at least any argument accepted by the overriden method, so the parameter type must be a supertype of the overriden function's parameter type.
The method must not return a value that the overriden method couldn't have, so the return type must be a subtype of the overriden method's return type.
The method must not have more effects than the overriden method, so the effect specifier must be a subtype of the overriden method's effect specifier.
Super
Similar to Self, you can use (super:) to access the superclass implementations of fields and methods. To be able to use (super:), the field or method must be implemented in the superclass definition.

pet := class():
    Sound : string

    Speak() : void =
        Log(Sound)

cat := class(pet):
    Sound<override> : string = "Meow"

    Speak<override>() : void =
        (super:)Speak() # "Meow" appears in the Output Log
        Log("Purr") # "Purr" appears in the Output Log
Block Expressions in a Subclass Body
Any block expressions that are in a subclass body will be executed after the block expressions specified in the superclass body. For example, in the following code, when the instance of the cat class named MrSnuffles is created, Speak() is executed first, then Purr().

pet := class():
    Speak() : void =
    ...

    block:
        Speak()

cat := class(pet):
    Purr() : void =
    ...

    block:
        Purr()

MrSnuffles := cat{}
Abstract Specifier
When a class or a class method has the abstract specifier, you cannot create an instance of the class. Abstract classes are intended to be used as a superclass with partial implementation, or as a common interface. This is useful for when it doesn‚Äôt make sense to have instances of a superclass but you don‚Äôt want to duplicate properties and behaviors across similar classes.

In the following example, because pet is an abstract concept, an instance of the pet class isn‚Äôt specific enough, but a pet cat or pet dog does make sense, so those subclasses aren‚Äôt marked as abstract.

pet := class<abstract>():
    Speak() : void

cat := class(pet):
    Speak() : void = 
    ...

dog := class(pet):
    Speak() : void =
    ...

The interface type provides a contract for how to interact with any class that implements the interface. An interface cannot be instantiated, but a class can inherit from the interface and implement its methods. An interface is similar to an abstract class, except that it does not allow partial implementation or fields as part of the definition.

For example, let‚Äôs create an interface for anything that you can ride on, such as a bicycle or a horse:

Copy code

rideable := interface():
    Mount()<decides> : void
    Dismount()<decides> : void
Any classes that inherit the interface must implement the interface‚Äôs functions and add the override specifier:

Copy code

bicycle := class(rideable):
    ...
    Mount<override>()<decides> : void =
        ...
    Dismount<override>()<decides> : void =
        ...

horse := class(rideable):
    ...
    Mount<override>()<decides> : void =
        ...
    Dismount<override>()<decides> : void =
        ...
An interface can extend another interface. For example, you can specify that anything that you can ride should also be able to move.

Copy code

moveable := interface():
    MoveForward() : void

rideable := interface(moveable):
    Mount()<decides> : void
    Dismount()<decides> : void
A class can inherit from an interface and another class. For example, you can define a horse, and differentiate it from one that has a saddle you can ride on:

Copy code

horse := class(moveable):
    ...
    MoveForward()<decides> : void =
        ...

saddle_horse := class(horse, rideable):
    ...
    Mount<override>()<decides> : void =
        ...
    Dismount<override>()<decides> : void =
        ...
A class can inherit from multiple interfaces.

Copy code

lockable := interface():
    Lock() : void =
        ...
    Unlock() : void =
        ...

bicycle := class(rideable, lockable):
    ‚Ä¶
    Mount<override>()<decides> : void =
        ...
    Dismount<override>()<decides> : void =
        ...
    Lock<override>() : void =
        ...
    Unlock<override>() : void =
        ...
    MoveForward<override>() : void =


A constructor is a special function that creates an instance of the class that it‚Äôs associated with. It can be used to set initial values for the new object.

Copy code

class1 := class:
    Property1 : int
 
MakeClass1<constructor>(Arg1:int) := class1:
    Property1 := Arg
 
Main():void =
    X := MakeClass1(1)
    F := MakeClass1()
    Z := F(2)
Defining a constructor for a class: You can add a constructor for a class by adding the <constructor> specifier on the function name. Instead of specifying a return type on the function, the function is assigned the class name followed by any initialization of fields. A class can have more than one constructor.

Copy code

MakeOtherClass1<constructor>(Arg1 : int) := class1:
    let:
        OnePlusArg1 := Arg1 + 1

    block:
        DoSomething(OnePlusArg1)

    Property1 := OnePlusArg1

    block:
        DoOtherStuff()
Adding variables and executing code in the constructor: You can execute expressions within a constructor with the block expression, and introduce new variables with the keyword let.

Copy code

MakeClass1Plus1<constructor>(Arg1 : int) := class1:
    MakeClass1<constructor>(Arg1 + 1) # Note use of <constructor> on invocation

# The base type constructor can be invoked in any order with respect to properties,
# but the properties "win"
MakeOtherClass2<constructor>(Arg1 : int, Arg2 : int) := class2:
    Property2 := Arg2
    MakeClass1<constructor>(Arg1)
    # Note that effects are still ordered as they appear in the code
Calling other constructors in a constructor: You can call other constructors from a constructor. You can also call constructors for the superclass of the class from a constructor of the class as long as all fields are initialized. When a constructor calls another constructor and both constructors initialize fields, only the values provided to the first constructor are used for the fields. The order of evaluation for expressions between the two constructors will be in the order the expressions are written (as far as side effects are concerned), but only the values provided to the first constructor are used.



When working with data, it is often necessary to convert variables from one data type to another. For example, displaying the result of a calculation requires converting from a float to a string.

All type conversion within Verse is explicit, which means that you must use a function like ToString() or use an operator like multiply (*) to convert an object to a different data type. Explicit conversion of one type to another is also called type casting.

Converting Float to Int
Converting from a float to an int requires a function that explicitly specifies how it will convert from a floating point number to an integer. The following functions all handle the conversion, but they all work differently. It's up to you to decide which one works best in a given situation.

Round[]
Floor[]
Ceil[]
Int[]
In this example, different functions convert four float literal values into int values. Next, set assigns the values to variables of type int. The if expression creates the failure context for these failable functions.

var WoodCollected:int = 0
var StoneCollected:int = 0
var GoldCollected:int = 0
var FoodCollected:int = 0

if:
    # WoodCollected is now 2
    set WoodCollected = Round[1.5]

    # StoneCollected is now 1
    set StoneCollected = Floor[1.9]

    # GoldCollected is now 2
    set GoldCollected = Ceil[1.2]

    # FoodCollected is now 1
    set FoodCollected = Int[1.56]

Print("WoodCollected: {WoodCollected}")
Print("StoneCollected: {StoneCollected}")
Print("GoldCollected: {GoldCollected}")
Print("FoodCollected: {FoodCollected}")
Converting Int to Float
The way to convert from an int to a float data type is to multiply the integer by 1.0. The multiply operator (*) converts the integer to a floating point number before performing the multiplication.

This code converts the int variable StartingPositionX into a float through multiplication so it can be used in the declaration of a vector3 variable. The data type vector3 requires float type values for its X, Y, and Z fields.

var StartingPositionX:int = 960

# CurrentX = 960.0
var CurrentX:float = StartingPositionX * 1.0
var CurrentPosition:vector3 = vector3{X := CurrentX, Y := 0.0, Z := 0.0}
Print("CurrentX: {CurrentX}")
Converting to a String
You can convert multiple data types to a string using either a ToString() function or string interpolation, which calls a ToString() function. Currently, the following types have built-in ToString() functions in Verse.

float
int
[]char
char
vector2
vector3
rotation
In this example, you can see variables being converted to a string through string interpolation and ToString() functions. Both methods have the same result because string interpolation calls ToString().

var WoodCollected:int = 100
# Convert using string interpolation
Print("WoodCollected: { WoodCollected }")
# or ToString() function
Print("WoodCollected: " + ToString(WoodCollected))

var InitialDistance:float = 3.625
# Convert using string interpolation
Print("InitialDistance: { InitialDistance }")
# or ToString() function
Print("InitialDistance: " + ToString(InitialDistance))

var CurrentPosition : vector3 = vector3{X:= 960.0, Y:= 540.0, Z := 20.0}
# Convert using string interpolation
Print("CurrentPosition: { CurrentPosition }")
# or ToString() function
Print("CurrentPosition: " + ToString(CurrentPosition))
Converting a Custom Data Type to a String
Custom data types can also be converted to strings by implementing a ToString(custom_type) function for the data type. If a ToString(custom_type) function exists, string interpolation will use it to automatically convert data types to strings.

Here is an example of a custom ToString() function for an enum of fruits.

fruit := enum:
    Apple 
    Banana 
    Strawberry

ToString(Fruit: fruit):string =
    case(Fruit):
        fruit.Apple => "Apple"
        fruit.Banana => "Banana"
        fruit.Strawberry => "Strawberry"

PickUpFruit():void =
    # Examples of using string interpolation to convert data to strings
    var FruitItem:fruit = fruit.Banana

    # Picked up: Banana
    Print("Picked up: {FruitItem}")
    
    set FruitItem = fruit.Apple
    # Picked Up: Apple
    Print("Picked up: {FruitItem}")
Here is an example of a custom ToString() function for a custom class. Notice that the ToString() function is declared outside of the waypoint class. In the SetDestination() function, the string interpolation of Destination is calling the custom ToString() function.

# Custom class with constructor and a ToString() function
waypoint := class():
    DisplayName:string
    Position:vector3 = vector3{}

MakeWaypoint<constructor>(Name:string, X:float, Y:float, Z:float) := waypoint:
    DisplayName := Name
    Position := vector3{X := X, Y := Y, Z := Z}

ToString(Waypoint: waypoint):string =
    return "{Waypoint.DisplayName} at {Waypoint.Position}"

SetDestination():void =
    Destination:waypoint = MakeWaypoint("River", 919.0, 452.0, 545.0)
    # River at {x=919.0, y=452.0, z=545.0}
    Print("Destination: {Destination}")
Converting an Object Reference to a Different Type
You can explicitly convert references to objects (or type cast) to different classes or interfaces using the following syntax:

if (NewObjectReference := object_type_to_cast_to[ObjectReference]) {}
The object_type_to_cast_to represents the class or interface that you are attempting to convert the reference to. This is a failable expression because the type conversion will fail if the object can't be converted to the specified type. Attempting to convert an object reference to a class will fail if the class does not match the object's type, the type of a superclass, or an interface that the object's class implements.

This code declares an interface positionable, an abstract class shape that inherits from positionable, and two subclasses of shape: triangle and square. It then creates an object of type square called MyShape and attempts to type cast it to three other types. Here is a breakdown of the results.

square Type Cast To	Result
square	succeeds because MyShape is a square
triangle	fails because triangle is not a superclass of square, and triangle is not an interface that square implements
positionable	succeeds because square is a subclass of shape, and all subclasses of shape must implement positionable.
# Class and interface definitions
positionable := interface() {}
shape := class<abstract>(positionable) {}
triangle := class(shape) {}
square := class(shape) {}

# Create a square object referenced using the superclass type shape
MyShape:shape = square{}

# This will succeed since MySquare is a square object
if(MySquare := square[MyShape]):
    Print("Successfully cast shape to square")

if(MyTriangle := triangle[MyShape]):
    Print("This will never print.")
else:
    Print("Failed to cast MyShape to triangle. This is expected behavior.")

# This will succeed since the positionable interface must be implemented by subclasses of shape
if(MyDrawable := positionable[MyShape]):
    Print("Successfully cast shape to positionable")
In the last example, type casting will work but is not necessary. This code will have the same result:

MyDrawable:positionable = MyShape

Parametric types refer to any type that can take a parameter. You can use parametric types in Verse to define generalized data structures and operations. There are two ways to use parametric types as arguments: either in functions as explicit or implicit type arguments, or in classes as explicit type arguments.

Events are a common example of parametric types and are used extensively throughout devices in UEFN. For instance, the Button device has the InteractedWithEvent, which occurs whenever a player interacts with the button. To see a parametric type in action, check out the CountdownEndedEvent from the Custom Countdown Timer Tutorial.

Explicit Type Arguments
Consider a box that takes two arguments. The first_item initializes an ItemOne, and the second_item initializes an ItemTwo, both of type type. Both first_item and second_item are examples of parametric types that are explicit arguments to a class.

box(first_item:type, second_item:type) := class:
    ItemOne:first_item
    ItemTwo:second_item
Because type is the type argument for first_item and second_item, the box class can be created with any two types. You could have a box of two string values, a box of two int values, a string and an int, or even a box of two boxes!

For another example, consider the MakeOption() function, which takes any type and returns an option of that type.

MakeOption(t:type):?t = false

IntOption := MakeOption(int)
FloatOption := MakeOption(float)
StringOption := MakeOption(string)
You could modify the MakeOption() function to instead return any other container type, such as an array or a map.

Implicit Type Arguments
Implicit type arguments for functions are introduced using the where keyword. For example, given a function ReturnItem(), which simply takes a parameter and returns it:

ReturnItem(Item:t where t:type):t = Item
Here, t is an implicit type parameter of the function ReturnItem(), which takes an argument of type type and immediately returns it. The type of t restricts what type of Item we can pass to this function. In this case since t is of type type, we can call ReturnItem() with any type. The reason to use implicit parametric types with functions is that it allows you to write code that works regardless of the type passed to it.

For example, instead of having to write:

ReturnInt(Item:int):int = Item

ReturnFloat(Item:float):float = Item
The single function could be written instead.

ReturnItem(Item:t where t:type):t = Item
This comes with the guarantee that ReturnItem() doesn't need to know what particular type the t is ‚Äî whatever operation it performs, it will work regardless of the type of t.

The actual type to be used for t depends on how ReturnItem() is used. For example, if ReturnItem() is called with argument 0.0, then t is a float.

ReturnItem("t") # t is a string
ReturnItem(0.0) # t is a float
Here "hello" and 0.0 are the explicit arguments (the Item) passed to ReturnItem(). Both of these will work because the implicit type of Item is t, which can be any type.

For another example of a parametric type as an implicit argument to a function, consider the following MakeBox() function which operates on the box class.

box(first_item:type, second_item:type) := class:
    ItemOne:first_item
    ItemTwo:second_item

MakeBox(ItemOneVal:ValOne, SecondItemVal:ValTwo where ValOne:type, ValTwo:type):box(ValOne, ValTwo) =
    box(ValOne, ValTwo){ItemOne := ItemOneVal, ItemTwo := SecondItemVal}

Main():void =
    MakeBox("A", "B")
    MakeBox(1, "B")
    MakeBox("A", 2) 
    MakeBox(1, 2)
Here the MakeBox() function takes two arguments, FirstItemVal and SecondItemVal, both of type type, and returns a box of type (type, type). Using type here means we‚Äôre telling MakeBox that the returned box could be made up of any two objects; it could be an array, a string, a function, etc. The MakeBox() function passes both arguments to Box, uses them to create a box, and returns it. Note that both box and MakeBox() use the same syntax as a function call.

A built-in example of this is the function for the Map container type, given below.

Map(F(:t) : u, X : []t) : []u =
    for (Y : X):
        F(Y)
Type Constraints
You can specify a constraint on the type of an expression. The only currently supported constraint is subtype, and only for implicit type parameters. For example:

int_box := class:
    Item:int

MakeSubclassOfIntBox(NewBox:subtype_box where subtype_box:(subtype(int_box))) : tuple(subtype_box, int) = (NewBox, NewBox.Item)
In this example, MakeSubclassOfIntBox() will only compile when passed a class that subclasses from IntBox, since SubtypeBox has the type (subtype(IntBox)). Note that type can be seen as shorthand for subtype(any). In other words, this function accepts any subtype of any, which is every type.

Covariance and Contravariance
Covariance and Contravariance refer to the relationship of two types when the types are used in composite types or functions. Two types that are related in some way, such as when one subclasses from the other, are either covariant or contravariant to each other depending on how they are used in a particular piece of code.

Covariant: Using a more specific type when the code expects something more generic.

Contravariant: Using a more general type when the code expects something more specific.

For instance, if we we could use an int in a situation where any comparable would be accepted (such as a float), our int would be acting covariantly, since we‚Äôre using a more specific type when a more generic one is expected. On the reverse, if we could use any comparable when normally an int would be used, our comparable would be acting contravariantly, since we‚Äôre using a more generic type when a more specific one is expected.

An example of covariance and contravariance in a parametric type might look like the following:

MyFunction(Input:t where t:type):logic = true
Here t is used contravariantly as the input to the function, and logic is used covariantly as the output to the function.

It is important to keep in mind that the two types are not inherently covariant or contravariant to each other, rather whether they‚Äôre acting as covariant or contravariant depends on how they‚Äôre used in the code.

Covariant
Covariance means to use something more specific when you expect something generic. Usually this is for output from a function. All type uses that aren‚Äôt inputs to functions are covariant uses. A generic parametric type example below has payload acting covariantly.

DoSomething():int =
    payload:int = 0
For instance, suppose we have a class animal, and a class cat that subclasses animal. We also have a class pet_sanctuary that adopts out pets with the function AdoptPet(). Since we don‚Äôt know what kind of pet we‚Äôre going to get, AdoptPet() returns a generic animal.

animal := class:
cat := class(animal):
pet_sanctuary := class:
    AdoptPet():animal = animal{}
Suppose we have another pet sanctuary that only deals with cats. This class, cat_sanctuary, is a subclass of pet_sanctuary. Since this is a cat sanctuary, we override AdoptPet() to only return a cat instead of an animal.

cat_sanctuary := class(pet_sanctuary):
    AdoptPet<override>():cat = cat{}
In this case, the return type cat of AdoptPet() is covariant to animal. We‚Äôre using a more specific type when the original used a more general one.

This can also apply to composite types. Given an array of cat, we can initialize an array of animal using the cat array. The opposite does not work since animal cannot be converted to its subclass cat. The array of cat is covariant to the array of animal, because we‚Äôre treating a narrower type as a more generic type.

CatArray:[]cat = array{}
AnimalArray:[]animal = CatArray
Inputs to functions cannot be used covariantly. The following code will fail because the assignment of AnimalExample(), to CatExample(), is of type cat, which is too specific to be the return type of AnimalExample(). Reversing this order by assigning CatExample() to AnimalExample would work due to cat subtyping from animal.

CatExample:type{CatFunction(MyCat:cat):void} = ‚Ä¶
AnimalExample:type{AnimalFunction(MyAnimal:animal):void} = CatExample
An additional example follows where the variable t is only used covariantly.

# The line below will fail because t is used only covariantly.
MyFunction(:logic where t:type):?t = false
Contravariant
Contravariance is the opposite of covariant, and means to use something more generic when you expect something specific. This is usually input to a function. A generic parametric type example below has payload acting contravariantly.

DoSomething(Payload:payload where payload:type):void
Say our pet sanctuary has a specific procedure for handling new cats. We add a new method to pet_sanctuary called RegisterCat().

pet_sanctuary := class:
    AdoptPet():animal = animal{}
    RegisterCat(NewAnimal:cat):void = {}
For our cat_sanctuary, we‚Äôre going to override this method to accept an animal as a type parameter because we already know that every cat is an animal.

cat_sanctuary := class(pet_sanctuary):
    AdoptPet<override>():cat = cat{}
    RegisterCat<override>(NewAnimal:animal):void = {}
Here animal is contravariant to cat, since we‚Äôre using something more generic when something more specific would work.

Using an implicit type introduced by a where clause covariantly produces an error. For example, payload here is used contravariantly, but errors out due to not being defined as an argument.

DoSomething(:logic where payload:type) : ?payload = false
To fix this, this could be rewritten to exclude a type parameter:

DoSomething(:logic) : ?false = false
Contravariant-only uses do not result in an error, but can be rewritten using any instead of false. For example:

ReturnFirst(First:first_item, :second_item where first_item:type, second_item:type) : first_item = First
Since second_item was of type type and was not returned, we can replace it with any in the second example and avoid doing type checking on it.

ReturnFirst(First:first_item, :any where first_item:type) : first_item = First
Replacing the type first_item with either any or false loses precision. For example, the following code will fail to compile:

ReturnFirst(First:any, :any) :any = First

Main() : void =
    FirstInt:int = ReturnFirst(1, "ignored")
Known Limitations
Explicit type parameters for data types may only be used with classes, and not interfaces or structs. Inheritance related to parametric types is also disallowed.	
OriginalBox(item:type) := class:
    Item:type = item
# InheritingBox cannot inherit from OriginalBox
# because Parametric types cannot inherit
InheritingBox(item : type) := class(OriginalBox):
    Item:type = item
Parametric types can reference themselves recursively as long as the recursion is direct. Parametric types cannot recursively reference other parametric types.	
# Will compile
box_with_a_box(FirstItem : type) := class:
    ItemOne : FirstItem
    SecondThing : box_with_a_box(FirstItem)

# Will not compile
box_with_a_box(FirstItem : type) := class:
    ItemOne : FirstItem
    SecondThing : ListOfBoxes(FirstItem)

ListOfBoxes(FirstItem:type) := box_with_a_box(FirstItem)
Currently, classes only support immutable parametric type data. For example, this code would not compile because ItemOne is a variable.	
box(first_item:type, second_item:type) := class:
    var ItemOne:first_item
    ItemTwo:second_item
Explicit type parameters can be freely combined with a class, just as implicit type parameters can be combined with a function.	
OptionBox(FirstItem : type) := class:
    Item:?FirstItem

Flatten(Box1:?OptionBox(item) where item:type)<decides><transacts>:?item =
    Box1?.Item

Main() : void =
    Box1 := OptionBox(int){Item := option{1}}
    if(Flatten[option{Box1}] = Box1.Item):
        Print("Retrieved the item from Box1")












